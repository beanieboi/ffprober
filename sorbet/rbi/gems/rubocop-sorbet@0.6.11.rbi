# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-sorbet` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-sorbet`.

module RuboCop; end

module RuboCop::AST
  extend ::RuboCop::AST::RuboCopCompatibility
end

class RuboCop::AST::AliasNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/alias_node.rb#19
  def new_identifier; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/alias_node.rb#12
  def old_identifier; end
end

class RuboCop::AST::AndAsgnNode < ::RuboCop::AST::OpAsgnNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/and_asgn_node.rb#12
  def operator; end
end

class RuboCop::AST::AndNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/and_node.rb#16
  def alternate_operator; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/and_node.rb#24
  def inverse_operator; end
end

class RuboCop::AST::ArgNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/arg_node.rb#29
  def default?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/arg_node.rb#20
  def default_value; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/arg_node.rb#13
  def name; end
end

class RuboCop::AST::ArgsNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::CollectionNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/args_node.rb#34
  def argument_list; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/args_node.rb#24
  def empty_and_without_delimiters?; end
end

class RuboCop::AST::ArrayNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/array_node.rb#60
  def bracketed?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/array_node.rb#21
  def each_value(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/array_node.rb#47
  def percent_literal?(type = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/array_node.rb#32
  def square_brackets?; end

  # source://ast/2.4.2/lib/ast/node.rb#56
  def values; end
end

class RuboCop::AST::AsgnNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/asgn_node.rb#19
  def expression; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/asgn_node.rb#12
  def name; end
end

module RuboCop::AST::BasicLiteralNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/basic_literal_node.rb#11
  def value; end
end

module RuboCop::AST::BinaryOperatorNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/binary_operator_node.rb#28
  def conditions; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/binary_operator_node.rb#11
  def lhs; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/binary_operator_node.rb#18
  def rhs; end
end

class RuboCop::AST::BlockNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::MethodIdentifierPredicates

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#42
  def argument_list; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#30
  def arguments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#67
  def arguments?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#53
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#74
  def braces?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#102
  def closing_delimiter; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#88
  def delimiters; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#81
  def keywords?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#125
  def lambda?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#60
  def method_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#118
  def multiline?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#95
  def opening_delimiter; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#20
  def send_node; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#110
  def single_line?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#132
  def void_context?; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/block_node.rb#139
  def numbered_arguments; end
end

class RuboCop::AST::BreakNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
end

class RuboCop::AST::Builder < ::Parser::Builders::Default
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/builder.rb#97
  def n(type, children, source_map); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/builder.rb#103
  def string_value(token); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/builder.rb#109
  def node_klass(type); end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/builder.rb#21
RuboCop::AST::Builder::NODE_MAP = T.let(T.unsafe(nil), Hash)

class RuboCop::AST::CaseMatchNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_match_node.rb#38
  def branches; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_match_node.rb#19
  def each_in_pattern(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_match_node.rb#59
  def else?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_match_node.rb#52
  def else_branch; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_match_node.rb#30
  def in_pattern_branches; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_match_node.rb#14
  def keyword; end
end

class RuboCop::AST::CaseNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_node.rb#38
  def branches; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_node.rb#19
  def each_when(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_node.rb#55
  def else?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_node.rb#48
  def else_branch; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_node.rb#14
  def keyword; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/case_node.rb#30
  def when_branches; end
end

class RuboCop::AST::CasgnNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/casgn_node.rb#26
  def expression; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/casgn_node.rb#19
  def name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/casgn_node.rb#12
  def namespace; end
end

class RuboCop::AST::ClassNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/class_node.rb#26
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/class_node.rb#12
  def identifier; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/class_node.rb#19
  def parent_class; end
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable

  # source://forwardable/1.3.2/forwardable.rb#229
  def &(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def *(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def +(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def -(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def []=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def all?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def any?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def append(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def assoc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def at(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def bsearch(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def bsearch_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def chain(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def chunk(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def chunk_while(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def clear(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def collect(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def collect!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def collect_concat(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def combination(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def compact(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def compact!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def concat(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def count(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def cycle(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def deconstruct(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete_at(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete_if(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def detect(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def difference(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def dig(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def drop(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def drop_while(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_cons(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_entry(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_slice(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_with_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_with_object(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def empty?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def entries(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def fetch(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def fill(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def filter(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def filter!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def filter_map(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def find(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def find_all(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def find_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def first(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flat_map(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flatten(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flatten!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def grep(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def grep_v(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def group_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def include?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def index(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def inject(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def insert(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def intersect?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def intersection(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def join(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def keep_if(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def last(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def lazy(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def map(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def map!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def max(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def max_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def member?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def min(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def min_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def minmax(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def minmax_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def none?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def one?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def pack(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def partition(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def permutation(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def place(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def pop(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def prepend(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def product(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def push(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def rassoc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reduce(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reject(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reject!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def repeated_combination(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def repeated_permutation(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def replace(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reverse(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reverse!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reverse_each(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def rindex(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def rotate(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def rotate!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sample(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def select(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def select!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def shelljoin(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def shift(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def shuffle(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def shuffle!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def size(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice_after(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice_before(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice_when(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sort(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sort!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sort_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sort_by!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sum(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def take(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def take_while(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def tally(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_ary(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_h(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_set(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def transpose(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def union(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def uniq(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def uniq!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def unshift(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def values_at(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def zip(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def |(*args, **_arg1, &block); end
end

module RuboCop::AST::ConditionalNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/conditional_node.rb#40
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/conditional_node.rb#29
  def condition; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/conditional_node.rb#21
  def multiline_condition?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/conditional_node.rb#13
  def single_line_condition?; end
end

class RuboCop::AST::ConstNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#26
  def absolute?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#20
  def class_name?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#43
  def each_path(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#20
  def module_name?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#8
  def namespace; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#33
  def relative?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/const_node.rb#13
  def short_name; end
end

class RuboCop::AST::DefNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#26
  def argument_forwarding?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#40
  def arguments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#51
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#63
  def endless?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#33
  def method_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#58
  def receiver; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/def_node.rb#15
  def void_context?; end
end

class RuboCop::AST::DefinedNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://ast/2.4.2/lib/ast/node.rb#56
  def arguments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/defined_node.rb#12
  def node_parts; end
end

module RuboCop::AST::Descendence
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/descendence.rb#38
  def child_nodes; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/descendence.rb#69
  def descendants; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/descendence.rb#22
  def each_child_node(*types); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/descendence.rb#57
  def each_descendant(*types, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/descendence.rb#92
  def each_node(*types, &block); end

  protected

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/descendence.rb#104
  def visit_descendants(types, &block); end
end

class RuboCop::AST::DstrNode < ::RuboCop::AST::StrNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/dstr_node.rb#9
  def value; end
end

class RuboCop::AST::EnsureNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/ensure_node.rb#12
  def body; end
end

module RuboCop::AST::Ext; end

module RuboCop::AST::Ext::Range
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/ext/range.rb#20
  def line_span(exclude_end: T.unsafe(nil)); end
end

module RuboCop::AST::Ext::RangeMinMax; end

class RuboCop::AST::FloatNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::ForNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/for_node.rb#48
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/for_node.rb#41
  def collection; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/for_node.rb#19
  def do?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/for_node.rb#12
  def keyword; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/for_node.rb#34
  def variable; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/for_node.rb#27
  def void_context?; end
end

class RuboCop::AST::ForwardArgsNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::CollectionNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/forward_args_node.rb#28
  def to_a; end
end

module RuboCop::AST::HashElementNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/hash_element_node.rb#61
  def delimiter_delta(other); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/hash_element_node.rb#13
  def key; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/hash_element_node.rb#43
  def key_delta(other, alignment = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/hash_element_node.rb#32
  def same_line?(other); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/hash_element_node.rb#22
  def value; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/hash_element_node.rb#52
  def value_delta(other); end
end

class RuboCop::AST::HashNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#117
  def braces?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#59
  def each_key(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#33
  def each_pair; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#83
  def each_value(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#22
  def empty?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#48
  def keys; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#110
  def mixed_delimiters?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#15
  def pairs; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#100
  def pairs_on_same_line?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/hash_node.rb#72
  def values; end
end

class RuboCop::AST::IfNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#147
  def branches; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#164
  def each_branch(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#42
  def else?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#126
  def else_branch; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#32
  def elsif?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#104
  def elsif_conditional?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#16
  def if?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#115
  def if_branch; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#66
  def inverse_keyword; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#57
  def keyword; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#80
  def modifier_form?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#90
  def nested_conditional?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#134
  def node_parts; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#49
  def ternary?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/if_node.rb#24
  def unless?; end
end

class RuboCop::AST::InPatternNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/in_pattern_node.rb#33
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/in_pattern_node.rb#19
  def branch_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/in_pattern_node.rb#12
  def pattern; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/in_pattern_node.rb#26
  def then?; end
end

class RuboCop::AST::IndexNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/index_node.rb#29
  def assignment_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/index_node.rb#24
  def attribute_accessor?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/index_node.rb#34
  def method_name; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/index_node.rb#43
  def first_argument_index; end
end

class RuboCop::AST::IndexasgnNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/indexasgn_node.rb#31
  def assignment_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/indexasgn_node.rb#26
  def attribute_accessor?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/indexasgn_node.rb#36
  def method_name; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/indexasgn_node.rb#45
  def first_argument_index; end
end

class RuboCop::AST::IntNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::KeywordSplatNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::HashElementNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/keyword_splat_node.rb#26
  def colon?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/keyword_splat_node.rb#18
  def hash_rocket?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/keyword_splat_node.rb#41
  def node_parts; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/keyword_splat_node.rb#33
  def operator; end
end

class RuboCop::AST::LambdaNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#43
  def assignment_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#38
  def attribute_accessor?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#28
  def lambda?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#33
  def lambda_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#53
  def method_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#48
  def receiver; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/lambda_node.rb#60
  def first_argument_index; end
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#53
  def access_modifier?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#262
  def adjacent_def_modifier?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#164
  def arithmetic_operation?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#96
  def assignment?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#62
  def bare_access_modifier?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#267
  def bare_access_modifier_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#237
  def binary_operation?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#156
  def block_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#35
  def block_node; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#89
  def command?(name); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#141
  def const_receiver?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#188
  def def_modifier(node = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#176
  def def_modifier?(node = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#108
  def dot?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#116
  def double_colon?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#149
  def implicit_call?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#246
  def in_macro_scope?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#202
  def lambda?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#213
  def lambda_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#46
  def macro?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#27
  def method_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#71
  def non_bare_access_modifier?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#272
  def non_bare_access_modifier_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#20
  def receiver; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#124
  def safe_navigation?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#132
  def self_receiver?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#96
  def setter_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#80
  def special_modifier?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_dispatch_node.rb#224
  def unary_operation?; end
end

module RuboCop::AST::MethodIdentifierPredicates
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#142
  def assignment_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#171
  def bang_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#179
  def camel_case_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#135
  def comparison_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#193
  def const_receiver?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#157
  def enumerable_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#149
  def enumerator_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#79
  def method?(name); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#200
  def negation_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#114
  def nonmutating_array_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#93
  def nonmutating_binary_operator_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#121
  def nonmutating_hash_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#107
  def nonmutating_operator_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#128
  def nonmutating_string_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#100
  def nonmutating_unary_operator_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#86
  def operator_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#164
  def predicate_method?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#214
  def prefix_bang?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#207
  def prefix_not?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#186
  def self_receiver?; end
end

module RuboCop::AST::ModifierNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/modifier_node.rb#12
  def modifier_form?; end
end

class RuboCop::AST::ModuleNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/module_node.rb#19
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/module_node.rb#12
  def identifier; end
end

class RuboCop::AST::NextNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
end

class RuboCop::AST::Node < ::Parser::AST::Node
  include ::RuboCop::AST::Sexp
  include ::RuboCop::AST::Descendence
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#88
  def initialize(type, children = T.unsafe(nil), properties = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def __ENCODING___type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def __FILE___type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def __LINE___type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def alias_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#237
  def ancestors; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def and_asgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def and_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def arg_expr_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def arg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def args_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#454
  def argument?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#458
  def argument_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def array_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def array_pattern_with_tail_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def array_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#406
  def assignment?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#345
  def assignment_or_similar?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def back_ref_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#410
  def basic_conditional?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#353
  def basic_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def begin_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def block_pass_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def block_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def blockarg_expr_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def blockarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#462
  def boolean_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def break_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#446
  def call_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def case_match_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def case_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def casgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def cbase_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#450
  def chained?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#502
  def class_constructor?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#514
  def class_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def class_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#132
  def complete!; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#137
  def complete?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def complex_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#414
  def conditional?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#283
  def const_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def const_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def const_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def csend_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def cvar_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def cvasgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def def_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#304
  def defined_module; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#309
  def defined_module_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def defined_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def defs_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def dstr_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def dsym_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#225
  def each_ancestor(*types, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def eflipflop_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def empty_else_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#339
  def empty_source?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def ensure_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#398
  def equals_asgn?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def erange_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def false_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#361
  def falsey_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def find_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#251
  def first_line; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def float_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def for_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def forward_arg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def forward_args_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def forwarded_args_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#499
  def global_const?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#474
  def guard_clause?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def gvar_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def gvasgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def hash_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def hash_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def ident_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def if_guard_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def if_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def iflipflop_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#369
  def immutable_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def in_match_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def in_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def index_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def indexasgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def int_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def irange_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def ivar_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def ivasgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#427
  def keyword?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwargs_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwbegin_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwnilarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwoptarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwrestarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def kwsplat_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#493
  def lambda?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#496
  def lambda_or_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def lambda_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#255
  def last_line; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#175
  def left_sibling; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#185
  def left_siblings; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#259
  def line_count; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#349
  def literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#423
  def loop_keyword?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def lvar_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def lvasgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def masgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_alt_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_as_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_current_line_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#481
  def match_guard_clause?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_nil_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_pattern_p_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_pattern_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_rest_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_var_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_with_lvasgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def match_with_trailing_comma_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def mlhs_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#521
  def module_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def module_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#331
  def multiline?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#365
  def mutable_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#655
  def new_class_or_module_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def next_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def nil_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#206
  def node_parts; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#265
  def nonempty_line_count; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def not_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def nth_ref_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def numargs_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def numblock_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#466
  def numeric_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def objc_kwarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def objc_restarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def objc_varargs_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def op_asgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#438
  def operator_keyword?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def optarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def or_asgn_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def or_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def pair_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#114
  def parent; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#123
  def parent?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#315
  def parent_module_name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#442
  def parenthesized_call?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def pin_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#418
  def post_condition_loop?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def postexe_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def preexe_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#486
  def proc?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def procarg0_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#566
  def pure?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#470
  def range_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def rational_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#276
  def receiver(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#376
  def recursive_basic_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#376
  def recursive_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def redo_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#394
  def reference?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def regexp_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def regopt_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def resbody_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def rescue_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def restarg_expr_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def restarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def retry_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def return_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#166
  def right_sibling; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#194
  def right_siblings; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#128
  def root?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def sclass_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def self_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def send_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def shadowarg_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#402
  def shorthand_asgn?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#159
  def sibling_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#335
  def single_line?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#243
  def source; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#269
  def source_length; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#247
  def source_range; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#434
  def special_keyword?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def splat_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#281
  def str_content(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def str_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#509
  def struct_constructor?(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def super_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def sym_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def true_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#357
  def truthy_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def undef_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def unless_guard_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def until_post_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def until_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#148
  def updated(type = T.unsafe(nil), children = T.unsafe(nil), properties = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#535
  def value_used?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#390
  def variable?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def when_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def while_post_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def while_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def xstr_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def yield_type?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#106
  def zsuper_type?; end

  protected

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#118
  def parent=(node); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#594
  def begin_value_used?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#605
  def case_if_value_used?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#295
  def defined_module0(param0 = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#599
  def for_value_used?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#641
  def parent_module_name_for_block(ancestor); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#629
  def parent_module_name_for_sclass(sclass_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#616
  def parent_module_name_part(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#584
  def visit_ancestors(types); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#611
  def while_until_value_used?; end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#80
RuboCop::AST::Node::ARGUMENT_TYPES = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#55
RuboCop::AST::Node::ASSIGNMENTS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#58
RuboCop::AST::Node::BASIC_CONDITIONALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#42
RuboCop::AST::Node::BASIC_LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#28
RuboCop::AST::Node::COMPARISON_OPERATORS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#39
RuboCop::AST::Node::COMPOSITE_LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#60
RuboCop::AST::Node::CONDITIONALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#50
RuboCop::AST::Node::EQUALS_ASSIGNMENTS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#35
RuboCop::AST::Node::FALSEY_LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#47
RuboCop::AST::Node::IMMUTABLE_LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#70
RuboCop::AST::Node::KEYWORDS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#37
RuboCop::AST::Node::LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#64
RuboCop::AST::Node::LOOP_TYPES = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#44
RuboCop::AST::Node::MUTABLE_LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#76
RuboCop::AST::Node::OPERATOR_KEYWORDS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#62
RuboCop::AST::Node::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#68
RuboCop::AST::Node::REFERENCES = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#53
RuboCop::AST::Node::SHORTHAND_ASSIGNMENTS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#78
RuboCop::AST::Node::SPECIAL_KEYWORDS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#31
RuboCop::AST::Node::TRUTHY_LITERALS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node.rb#66
RuboCop::AST::Node::VARIABLES = T.let(T.unsafe(nil), Set)

class RuboCop::AST::NodePattern
  include ::RuboCop::AST::NodePattern::MethodDefiner
  extend ::Forwardable

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#61
  def initialize(str, compiler: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#74
  def ==(other); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#91
  def as_json(_options = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#57
  def ast; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def captures(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#95
  def encode_with(coder); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#74
  def eql?(other); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#119
  def freeze; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#99
  def init_with(coder); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#87
  def marshal_dump; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#83
  def marshal_load(pattern); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#69
  def match(*args, **rest, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#57
  def match_code; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def named_parameters(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#57
  def pattern; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def positional_parameters(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#79
  def to_s; end

  class << self
    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#105
    def descend(element, &block); end
  end
end

class RuboCop::AST::NodePattern::Builder
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#17
  def emit_atom(type, value); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#29
  def emit_call(type, selector, args = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#11
  def emit_capture(capture_token, node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#25
  def emit_list(type, _begin, children, _end); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#41
  def emit_subsequence(node_list); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#21
  def emit_unary_op(type, _operator = T.unsafe(nil), *children); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#34
  def emit_union(begin_t, pattern_lists, end_t); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#53
  def n(type, *args); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#49
  def optimizable_as_set?(children); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/builder.rb#57
  def union_children(pattern_lists); end
end

class RuboCop::AST::NodePattern::Comment
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/comment.rb#14
  def initialize(range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/comment.rb#31
  def ==(other); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/comment.rb#39
  def inspect; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/comment.rb#8
  def loc; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/comment.rb#8
  def location; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/comment.rb#20
  def text; end
end

class RuboCop::AST::NodePattern::Compiler
  extend ::Forwardable

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#15
  def initialize; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def bind(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#13
  def binding; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#13
  def captures; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#42
  def compile_as_atom(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#46
  def compile_as_node_pattern(node, **options); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#50
  def compile_sequence(sequence, var:); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#38
  def each_union(enum, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#74
  def freeze; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#31
  def named_parameter(name); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#13
  def named_parameters; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#70
  def next_capture; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#54
  def parser; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#26
  def positional_parameter(number); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#13
  def positional_parameters; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#60
  def with_temp_variables(*names, &block); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#81
  def enforce_same_captures(enum); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler.rb#96
  def new_capture; end
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler < ::RuboCop::AST::NodePattern::Compiler::Subcompiler
  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#28
  def visit_const; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#32
  def visit_named_parameter; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#21
  def visit_number; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#46
  def visit_other_type; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#36
  def visit_positional_parameter; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#21
  def visit_regexp; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#40
  def visit_set; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#21
  def visit_string; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#21
  def visit_symbol; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#15
  def visit_unify; end
end

class RuboCop::AST::NodePattern::Compiler::Binding
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/binding.rb#9
  def initialize; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/binding.rb#16
  def bind(name); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/binding.rb#30
  def union_bind(enum); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/binding.rb#69
  def forbid(names); end
end

class RuboCop::AST::NodePattern::Compiler::Debug < ::RuboCop::AST::NodePattern::Compiler
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#123
  def initialize; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def comments(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#128
  def named_parameters; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#33
  def node_ids; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#132
  def parser; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def tokens(*args, **_arg1, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#96
  def initialize(pattern, compiler: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#94
  def compiler; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#94
  def node_pattern; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#94
  def pattern; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#103
  def test(ruby, trace: T.unsafe(nil)); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#111
  def ruby_ast(ruby); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#116
  def ruby_parser; end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#37
RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::COLOR_SCHEME = T.let(T.unsafe(nil), Hash)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#92
RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Compiler = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result < ::Struct
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#56
  def color_map(color_scheme = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#48
  def colorize(color_scheme = T.unsafe(nil)); end

  def colorizer; end
  def colorizer=(_); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#66
  def match_map; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#74
  def matched?(node); end

  def returned; end
  def returned=(_); end
  def ruby_ast; end
  def ruby_ast=(_); end
  def trace; end
  def trace=(_); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#87
  def ast; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#81
  def color_map_for(node, color); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#140
  def do_compile; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#150
  def node_id; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#146
  def tracer(kind); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler < ::RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler < ::RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#14
  def initialize; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#18
  def enter(node_id); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#28
  def matched?(node_id); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/debug.rb#23
  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler < ::RuboCop::AST::NodePattern::Compiler::Subcompiler
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#16
  def initialize(compiler, var: T.unsafe(nil), access: T.unsafe(nil), seq_head: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#14
  def access; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#14
  def seq_head; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#119
  def access_element; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#123
  def access_node; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#113
  def compile_args(arg_list, first: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#129
  def compile_guard_clause; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#107
  def compile_value_match(value); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#133
  def multiple_access(kind); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#30
  def visit_ascend; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#58
  def visit_capture; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#37
  def visit_descend; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#84
  def visit_function_call; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#73
  def visit_intersection; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#25
  def visit_negation; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#88
  def visit_node_type; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#100
  def visit_other_type; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#80
  def visit_predicate; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#92
  def visit_sequence; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#49
  def visit_unify; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#64
  def visit_union; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#45
  def visit_wildcard; end
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler < ::RuboCop::AST::NodePattern::Compiler::Subcompiler
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#25
  def initialize(compiler, sequence:, var:); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#31
  def compile_sequence; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#251
  def in_sync; end

  protected

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#226
  def compile_terms(children = T.unsafe(nil), last_arity = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#251
  def cur_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#242
  def sync; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#165
  def compile_and_advance(term); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#128
  def compile_any_order_branches(matched_var); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#137
  def compile_any_order_else; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#180
  def compile_captured_repetition(child_code, child_captures); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#119
  def compile_case(when_branches, else_code); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#361
  def compile_child_nb_guard(arity_range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#319
  def compile_cur_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#325
  def compile_index(cur = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#353
  def compile_loop(term); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#347
  def compile_loop_advance(to = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#198
  def compile_matched(kind); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#304
  def compile_max_matched; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#270
  def compile_min_check; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#285
  def compile_remaining; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#373
  def compile_union_forks; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#313
  def empty_loop; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#214
  def handle_prev; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#400
  def merge_forks!(forks); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#384
  def preserve_union_start(forks); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#259
  def remaining_arities(children, last_arity); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#341
  def use_index_from_end; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#88
  def visit_any_order; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#150
  def visit_capture; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#62
  def visit_other_type; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#78
  def visit_repetition; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#159
  def visit_rest; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#104
  def visit_union; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#333
  def within_loop; end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#18
RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler::DELTA = T.let(T.unsafe(nil), Integer)

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#15
  def initialize(compiler); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#20
  def compile(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#13
  def compiler; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#34
  def do_compile; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#32
  def node; end

  class << self
    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#47
    def inherited(base); end

    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#42
    def method_added(method); end

    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#40
    def registry; end
  end
end

class RuboCop::AST::NodePattern::Invalid < ::StandardError; end

class RuboCop::AST::NodePattern::Lexer < ::RuboCop::AST::NodePattern::LexerRex
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#31
  def initialize(source); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#29
  def comments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#29
  def source_buffer; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#29
  def tokens; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#60
  def do_parse; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#40
  def emit(type); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#48
  def emit_comment; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#52
  def emit_regexp; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#64
  def token(type, value); end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rb#19
RuboCop::AST::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::LexerRex
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#69
  def action; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#43
  def filename; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#43
  def filename=(_arg0); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#104
  def location; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#48
  def match; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#60
  def matches; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#113
  def next_token; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#84
  def parse(str); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#94
  def parse_file(path); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#77
  def scanner_class; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#48
  def ss; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#48
  def ss=(_arg0); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#53
  def state; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#53
  def state=(_arg0); end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#31
RuboCop::AST::NodePattern::LexerRex::CALL = T.let(T.unsafe(nil), Regexp)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#27
RuboCop::AST::NodePattern::LexerRex::CONST_NAME = T.let(T.unsafe(nil), Regexp)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#29
RuboCop::AST::NodePattern::LexerRex::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

class RuboCop::AST::NodePattern::LexerRex::LexerError < ::StandardError; end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#30
RuboCop::AST::NodePattern::LexerRex::NODE_TYPE = T.let(T.unsafe(nil), Regexp)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#33
RuboCop::AST::NodePattern::LexerRex::REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#32
RuboCop::AST::NodePattern::LexerRex::REGEXP_BODY = T.let(T.unsafe(nil), Regexp)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/lexer.rex.rb#28
RuboCop::AST::NodePattern::LexerRex::SYMBOL_NAME = T.let(T.unsafe(nil), Regexp)

class RuboCop::AST::NodePattern::LexerRex::ScanError < ::RuboCop::AST::NodePattern::LexerRex::LexerError; end

module RuboCop::AST::NodePattern::Macros
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#36
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#46
  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::MethodDefiner
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#37
  def as_lambda; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#27
  def compile_as_lambda; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#8
  def def_node_matcher(base, method_name, **defaults); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#21
  def def_node_search(base, method_name, **defaults); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#139
  def compile_init; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#50
  def def_helper(base, method_name, **defaults); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#114
  def emit_keyword_list(forwarding: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#132
  def emit_lambda_code; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#125
  def emit_method_code; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#63
  def emit_node_search(method_name); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#74
  def emit_node_search_body(method_name, prelude:, on_match:); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#110
  def emit_param_list; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#119
  def emit_params(*first, forwarding: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#100
  def emit_retval; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#89
  def emit_yield_capture(when_no_capture = T.unsafe(nil), yield_with: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/method_definer.rb#44
  def wrapping_block(method_name, **defaults); end
end

class RuboCop::AST::NodePattern::Node < ::Parser::AST::Node
  include ::RuboCop::AST::Descendence
  extend ::Forwardable

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#29
  def arity; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#69
  def arity_range; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#23
  def capture?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#48
  def child; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#43
  def children_nodes; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#34
  def in_sequence_head; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#64
  def matches_within_set?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#53
  def nb_captures; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#19
  def rest?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#58
  def variadic?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#74
  def with(type: T.unsafe(nil), children: T.unsafe(nil), location: T.unsafe(nil)); end
end

class RuboCop::AST::NodePattern::Node::AnyOrder < ::RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#194
  def arity; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#186
  def ends_with_rest?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#190
  def rest_node; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#182
  def term_nodes; end
end

class RuboCop::AST::NodePattern::Node::Capture < ::RuboCop::AST::NodePattern::Node
  # source://forwardable/1.3.2/forwardable.rb#229
  def arity(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#97
  def capture?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#105
  def in_sequence_head; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#101
  def nb_captures; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def rest?(*args, **_arg1, &block); end
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#83
  def in_sequence_head; end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#136
RuboCop::AST::NodePattern::Node::FunctionCall = RuboCop::AST::NodePattern::Node::Predicate

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#246
RuboCop::AST::NodePattern::Node::MAP = T.let(T.unsafe(nil), Hash)

class RuboCop::AST::NodePattern::Node::Predicate < ::RuboCop::AST::NodePattern::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#132
  def arg_list; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#128
  def method_name; end
end

class RuboCop::AST::NodePattern::Node::Repetition < ::RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#152
  def arity; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#142
  def operator; end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#146
RuboCop::AST::NodePattern::Node::Repetition::ARITIES = T.let(T.unsafe(nil), Hash)

class RuboCop::AST::NodePattern::Node::Rest < ::RuboCop::AST::NodePattern::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#166
  def arity; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#170
  def in_sequence_head; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#162
  def rest?; end
end

class RuboCop::AST::NodePattern::Node::Sequence < ::RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#117
  def initialize(type, children = T.unsafe(nil), properties = T.unsafe(nil)); end
end

class RuboCop::AST::NodePattern::Node::Subsequence < ::RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#205
  def arity; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#210
  def in_sequence_head; end
end

class RuboCop::AST::NodePattern::Node::Union < ::RuboCop::AST::NodePattern::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#221
  def arity; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/node.rb#228
  def in_sequence_head; end
end

class RuboCop::AST::NodePattern::Parser < ::Racc::Parser
  extend ::Forwardable

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#19
  def initialize(builder = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#333
  def _reduce_10(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#337
  def _reduce_11(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#343
  def _reduce_13(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#347
  def _reduce_14(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#351
  def _reduce_15(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#355
  def _reduce_16(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#359
  def _reduce_17(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#363
  def _reduce_18(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#367
  def _reduce_19(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#301
  def _reduce_2(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#371
  def _reduce_20(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#375
  def _reduce_21(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#379
  def _reduce_22(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#387
  def _reduce_25(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#393
  def _reduce_26(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#305
  def _reduce_3(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#413
  def _reduce_33(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#423
  def _reduce_37(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#427
  def _reduce_38(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#431
  def _reduce_39(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#309
  def _reduce_4(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#435
  def _reduce_40(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#439
  def _reduce_41(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#443
  def _reduce_42(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#447
  def _reduce_43(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#451
  def _reduce_44(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#455
  def _reduce_45(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#459
  def _reduce_46(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#313
  def _reduce_5(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#317
  def _reduce_6(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#321
  def _reduce_7(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#325
  def _reduce_8(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#329
  def _reduce_9(val, _values); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#463
  def _reduce_none(val, _values); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def emit_atom(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def emit_call(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def emit_capture(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def emit_list(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def emit_unary_op(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def emit_union(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#40
  def inspect; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def next_token(*args, **_arg1, &block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#31
  def parse(source); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#50
  def enforce_unary(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#59
  def on_error(token, val, _vstack); end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#16
RuboCop::AST::NodePattern::Parser::Builder = RuboCop::AST::NodePattern::Builder

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.rb#17
RuboCop::AST::NodePattern::Parser::Lexer = RuboCop::AST::NodePattern::Lexer

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#227
RuboCop::AST::NodePattern::Parser::Racc_arg = T.let(T.unsafe(nil), Array)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#293
RuboCop::AST::NodePattern::Parser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/parser.racc.rb#243
RuboCop::AST::NodePattern::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

class RuboCop::AST::NodePattern::Parser::WithMeta < ::RuboCop::AST::NodePattern::Parser
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#99
  def comments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#101
  def do_parse; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#99
  def tokens; end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder < ::RuboCop::AST::NodePattern::Builder
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#40
  def emit_atom(type, token); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#61
  def emit_call(type, selector_t, args = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#55
  def emit_list(type, begin_t, children, end_t); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#49
  def emit_unary_op(type, operator_t = T.unsafe(nil), *children); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#81
  def join_exprs(left_expr, right_expr); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#75
  def loc(token_or_range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#71
  def n(type, children, source_map); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#86
  def source_map(token_or_range, begin_t: T.unsafe(nil), end_t: T.unsafe(nil), operator_t: T.unsafe(nil), selector_t: T.unsafe(nil)); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer < ::RuboCop::AST::NodePattern::Lexer
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#13
  def initialize(str_or_buffer); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#27
  def emit_comment; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#33
  def pos; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#11
  def source_buffer; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/with_meta.rb#23
  def token(type, value); end
end

module RuboCop::AST::NodePattern::Sets
  class << self
    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#31
    def [](set); end

    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#15
    def name(set); end

    # source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#22
    def uniq(name); end
  end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#14
RuboCop::AST::NodePattern::Sets::MAX = T.let(T.unsafe(nil), Integer)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#8
RuboCop::AST::NodePattern::Sets::REGISTRY = T.let(T.unsafe(nil), Hash)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_0_1 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_10_10 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_1_1 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ABSTRACT_OVERRIDE_OVERRIDABLE_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ANY_ALL_NORETURN_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_BRANCH_REF_TAG = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CIPHER_DIGEST = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CLASS_EVAL_INSTANCE_EVAL = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CLASS_EVAL_MODULE_EVAL = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CLASS_MODULE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CLASS_MODULE_STRUCT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_CONSTANTIZE_CONSTANTS_CONST_GET = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_COUNT_LENGTH_SIZE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_DEFINE_METHOD = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_EACH_WITH_INDEX_WITH_INDEX = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_EACH_WITH_OBJECT_WITH_OBJECT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ENUMERATOR_RATIONAL_COMPLEX_THREAD = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ESCAPE_ENCODE_UNESCAPE_DECODE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_EXIST_EXISTS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_FILETEST_FILE_DIR_SHELL = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_FIRST_LAST__ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_FIXNUM_BIGNUM = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_FORMAT_SPRINTF_PRINTF = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_GSUB_GSUB = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_INCLUDE_EXTEND_PREPEND = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_KEYS_VALUES = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_KEY_HAS_KEY_FETCH_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_LAST_FIRST = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_LENGTH_SIZE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_LOAD_RESTORE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_MAP_COLLECT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_NEW_ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_NEW_OPEN = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_NIL_ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_PRIVATE_PROTECTED = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_PRIVATE_PROTECTED_PUBLIC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_PROP_CONST = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_RAISE_FAIL = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_RAISE_FAIL_THROW_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_REDUCE_INJECT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_REJECT_REJECT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_REQUIRE_REQUIRE_RELATIVE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_SELECT_SELECT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_SEND_PUBLIC_SEND___SEND__ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_SORT_BY_SORT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_SPAWN_SYSTEM = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_SPRINTF_FORMAT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_STRUCT_CLASS = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_SUCC_PRED_NEXT = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_TEMPFILE_STRINGIO = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_TO_ENUM_ENUM_FOR = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_TO_H_TO_HASH = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_TO_I_TO_F_TO_C_TO_R = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_TRUE_FALSE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_TYPE_TEMPLATE_TYPE_MEMBER = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_ZERO_POSITIVE_NEGATIVE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET__ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET__AT_SLICE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET__EQUAL_EQL = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET__FETCH = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET__GLOB = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___2 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___3 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___4 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___5 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___6 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___7 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___EQL_ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___EQL_INCLUDE = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET___METHOD_____CALLEE__ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET____ = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET____ETC = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET____ETC_2 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET____ETC_3 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern/sets.rb#10
RuboCop::AST::NodePattern::Sets::SET_____2 = T.let(T.unsafe(nil), Set)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/node_pattern.rb#55
RuboCop::AST::NodePattern::VAR = T.let(T.unsafe(nil), String)

module RuboCop::AST::NumericNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/numeric_node.rb#17
  def sign?; end
end

class RuboCop::AST::OpAsgnNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/op_asgn_node.rb#10
  def assignment_node; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/op_asgn_node.rb#31
  def expression; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/op_asgn_node.rb#17
  def name; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/op_asgn_node.rb#24
  def operator; end
end

class RuboCop::AST::OrAsgnNode < ::RuboCop::AST::OpAsgnNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/or_asgn_node.rb#12
  def operator; end
end

class RuboCop::AST::OrNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/or_node.rb#16
  def alternate_operator; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/or_node.rb#24
  def inverse_operator; end
end

class RuboCop::AST::PairNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::HashElementNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/pair_node.rb#30
  def colon?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/pair_node.rb#39
  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/pair_node.rb#23
  def hash_rocket?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/pair_node.rb#51
  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/pair_node.rb#69
  def value_omission?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/pair_node.rb#62
  def value_on_new_line?; end
end

module RuboCop::AST::ParameterizedNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#40
  def arguments?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#58
  def block_argument?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#24
  def first_argument; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#33
  def last_argument; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#15
  def parenthesized?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#48
  def rest_argument?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#48
  def splat_argument?; end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#86
  def arguments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#111
  def arguments?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#95
  def first_argument; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#104
  def last_argument; end
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/parameterized_node.rb#69
  def arguments; end
end

module RuboCop::AST::PredicateOperatorNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/predicate_operator_node.rb#27
  def logical_operator?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/predicate_operator_node.rb#20
  def operator; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/mixin/predicate_operator_node.rb#34
  def semantic_operator?; end
end

class RuboCop::AST::Procarg0Node < ::RuboCop::AST::ArgNode
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/procarg0_node.rb#12
  def name; end
end

class RuboCop::AST::ProcessedSource
  include ::RuboCop::Ext::ProcessedSource

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#26
  def initialize(source, ruby_version, path = T.unsafe(nil)); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#63
  def [](*args); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def ast; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#41
  def ast_with_comments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#102
  def blank?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def buffer; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#74
  def checksum; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#107
  def comment_at_line(line); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#129
  def commented?(source_range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def comments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#137
  def comments_before_line(line); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#129
  def contains_comment?(source_range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#151
  def current_line(token); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def diagnostics; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#79
  def each_comment(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#117
  def each_comment_in_lines(line_range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#89
  def each_token(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#98
  def file_path; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#84
  def find_comment(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#94
  def find_token(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#172
  def first_token_of(range_or_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#155
  def following_line(token); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#176
  def last_token_of(range_or_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#159
  def line_indentation(line_number); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#112
  def line_with_comment?(line); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#49
  def lines; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def parser_error; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def path; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#147
  def preceding_line(token); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def raw_source; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def ruby_version; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#183
  def sorted_tokens; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#141
  def start_with?(string); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#15
  def tokens; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#166
  def tokens_within(range_or_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#67
  def valid_syntax?; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#190
  def comment_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#275
  def create_parser(ruby_version); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#291
  def first_token_index(range_or_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#296
  def last_token_index(range_or_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#196
  def parse(source, ruby_version); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#230
  def parser_class(ruby_version); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#301
  def source_range(range_or_node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#213
  def tokenize(parser); end

  class << self
    # source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#18
    def from_file(path, ruby_version); end
  end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/processed_source.rb#13
RuboCop::AST::ProcessedSource::STRING_SOURCE_NAME = T.let(T.unsafe(nil), String)

class RuboCop::AST::RangeNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/range_node.rb#9
  def begin; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/range_node.rb#13
  def end; end
end

class RuboCop::AST::RegexpNode < ::RuboCop::AST::Node
  include ::RuboCop::Ext::RegexpNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#37
  def content; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#57
  def delimiter?(char); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#52
  def delimiters; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#72
  def extended?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#92
  def fixed_encoding?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#77
  def ignore_case?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#62
  def interpolation?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#67
  def multiline_mode?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#87
  def no_encoding?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#32
  def options; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#47
  def percent_r_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#25
  def regopt; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#82
  def single_interpolation?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#42
  def slash_literal?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#20
  def to_regexp; end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/regexp_node.rb#98
  def regopt_include?(option); end
end

class RuboCop::AST::ResbodyNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/resbody_node.rb#12
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/resbody_node.rb#40
  def branch_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/resbody_node.rb#33
  def exception_variable; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/resbody_node.rb#19
  def exceptions; end
end

class RuboCop::AST::RescueNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/rescue_node.rb#12
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/rescue_node.rb#27
  def branches; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/rescue_node.rb#44
  def else?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/rescue_node.rb#37
  def else_branch; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/rescue_node.rb#19
  def resbody_branches; end
end

class RuboCop::AST::ReturnNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
end

module RuboCop::AST::RuboCopCompatibility
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/rubocop_compatibility.rb#13
  def rubocop_loaded; end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/rubocop_compatibility.rb#9
RuboCop::AST::RuboCopCompatibility::INCOMPATIBLE_COPS = T.let(T.unsafe(nil), Hash)

class RuboCop::AST::SelfClassNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/self_class_node.rb#19
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/self_class_node.rb#12
  def identifier; end
end

class RuboCop::AST::SendNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/send_node.rb#13
  def attribute_accessor?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/send_node.rb#20
  def first_argument_index; end
end

module RuboCop::AST::Sexp
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/sexp.rb#11
  def s(type, *children); end
end

class RuboCop::AST::StrNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BasicLiteralNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/str_node.rb#11
  def heredoc?; end
end

class RuboCop::AST::SuperNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://ast/2.4.2/lib/ast/node.rb#56
  def arguments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/super_node.rb#16
  def node_parts; end
end

class RuboCop::AST::SymbolNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::Token
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#15
  def initialize(pos, type, text); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#30
  def begin_pos; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#26
  def column; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#99
  def comma?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#55
  def comment?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#103
  def dot?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#115
  def end?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#34
  def end_pos; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#119
  def equal_sign?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#63
  def left_array_bracket?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#79
  def left_brace?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#71
  def left_bracket?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#83
  def left_curly_brace?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#91
  def left_parens?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#67
  def left_ref_bracket?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#22
  def line; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#123
  def new_line?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#7
  def pos; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#107
  def regexp_dots?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#111
  def rescue_modifier?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#75
  def right_bracket?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#87
  def right_curly_brace?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#95
  def right_parens?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#59
  def semicolon?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#43
  def space_after?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#48
  def space_before?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#7
  def text; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#38
  def to_s; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#7
  def type; end

  class << self
    # source://rubocop-ast/1.22.0/lib/rubocop/ast/token.rb#9
    def from_parser_token(parser_token); end
  end
end

module RuboCop::AST::Traversal
  extend ::RuboCop::AST::Traversal::CallbackCompiler

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#172
  def on_(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on___ENCODING__(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on___FILE__(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on___LINE__(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_alias(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_and(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_and_asgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_arg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_arg_expr(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_args(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_array(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_array_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_array_pattern_with_tail(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_back_ref(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_begin(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#150
  def on_block(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#128
  def on_block_pass(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_blockarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_break(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_case(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_case_match(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#145
  def on_casgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_cbase(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#146
  def on_class(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_complex(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#144
  def on_const(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_const_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#154
  def on_csend(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_cvar(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#130
  def on_cvasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#147
  def on_def(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_defined?(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#152
  def on_defs(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_dstr(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_dsym(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_eflipflop(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_empty_else(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_ensure(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_erange(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_false(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_find_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_float(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_for(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_forward_arg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_forward_args(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_forwarded_args(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_gvar(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#130
  def on_gvasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_hash(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_hash_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#149
  def on_if(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_if_guard(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_iflipflop(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_in_match(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_in_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_index(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_indexasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_int(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_irange(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_ivar(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#130
  def on_ivasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_kwarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_kwargs(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_kwbegin(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_kwnilarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#131
  def on_kwoptarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#123
  def on_kwrestarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#124
  def on_kwsplat(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_lambda(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_lvar(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#130
  def on_lvasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_masgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_match_alt(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_match_as(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_match_current_line(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_match_nil_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_match_pattern(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_match_pattern_p(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#124
  def on_match_rest(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_match_var(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_match_with_lvasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_match_with_trailing_comma(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_mlhs(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#132
  def on_module(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_mrasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_next(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_nil(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_not(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_nth_ref(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#151
  def on_numblock(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#148
  def on_op_asgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#131
  def on_optarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_or(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_or_asgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_pair(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_pin(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#128
  def on_postexe(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#128
  def on_preexe(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_procarg0(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_rasgn(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_rational(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_redo(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_regexp(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#134
  def on_regopt(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_resbody(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_rescue(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#123
  def on_restarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_retry(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_return(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#132
  def on_sclass(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_self(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#154
  def on_send(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_shadowarg(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#124
  def on_splat(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_str(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_super(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#126
  def on_sym(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_true(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_undef(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#127
  def on_unless_guard(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#132
  def on_until(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_until_post(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#138
  def on_when(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#132
  def on_while(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_while_post(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_xstr(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#135
  def on_yield(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#122
  def on_zsuper(node); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#17
  def walk(node); end
end

module RuboCop::AST::Traversal::CallbackCompiler
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#61
  def arity_check(range); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#52
  def body(signature, prelude); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#35
  def def_callback(type, *signature, arity: T.unsafe(nil), arity_check: T.unsafe(nil), body: T.unsafe(nil)); end
end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#26
RuboCop::AST::Traversal::CallbackCompiler::SEND = T.let(T.unsafe(nil), String)

# source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#29
RuboCop::AST::Traversal::CallbackCompiler::TEMPLATE = T.let(T.unsafe(nil), Hash)

class RuboCop::AST::Traversal::DebugError < ::RuntimeError; end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/traversal.rb#15
RuboCop::AST::Traversal::TYPE_TO_METHOD = T.let(T.unsafe(nil), Hash)

class RuboCop::AST::UntilNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/until_node.rb#30
  def do?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/until_node.rb#23
  def inverse_keyword; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/until_node.rb#15
  def keyword; end
end

module RuboCop::AST::Version; end

# source://rubocop-ast/1.22.0/lib/rubocop/ast/version.rb#6
RuboCop::AST::Version::STRING = T.let(T.unsafe(nil), String)

class RuboCop::AST::WhenNode < ::RuboCop::AST::Node
  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/when_node.rb#42
  def body; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/when_node.rb#28
  def branch_index; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/when_node.rb#12
  def conditions; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/when_node.rb#17
  def each_condition(&block); end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/when_node.rb#35
  def then?; end
end

class RuboCop::AST::WhileNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/while_node.rb#30
  def do?; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/while_node.rb#23
  def inverse_keyword; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/while_node.rb#15
  def keyword; end
end

class RuboCop::AST::YieldNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://ast/2.4.2/lib/ast/node.rb#56
  def arguments; end

  # source://rubocop-ast/1.22.0/lib/rubocop/ast/node/yield_node.rb#16
  def node_parts; end
end

class RuboCop::CLI
  # source://rubocop/1.36.0/lib/rubocop/cli.rb#22
  def initialize; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#20
  def config_store; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#20
  def options; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#37
  def run(args = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#106
  def act_on_options; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#140
  def apply_default_formatter; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#75
  def execute_runners; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#131
  def handle_exiting_options; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#94
  def parallel_by_default!; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#71
  def run_command(name); end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#123
  def set_options_to_config_loader; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#83
  def suggest_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli.rb#87
  def validate_options_vs_config; end
end

module RuboCop::CLI::Command
  class << self
    # source://rubocop/1.36.0/lib/rubocop/cli/command.rb#10
    def run(env, name); end

    private

    # source://rubocop/1.36.0/lib/rubocop/cli/command.rb#16
    def class_for(name); end
  end
end

class RuboCop::CLI::Command::AutoGenerateConfig < ::RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#20
  def run; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#90
  def add_formatter; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#98
  def add_inheritance_from_auto_generated_file(config_file); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#94
  def execute_runner; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#119
  def existing_configuration(config_file); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#56
  def line_length_cop(config); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#44
  def line_length_enabled?(config); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#52
  def max_line_length(config); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#29
  def maybe_run_line_length_cop; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#141
  def options_config_in_root?; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#132
  def relative_path_to_todo_from_options_config; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#83
  def reset_config_and_auto_gen_file; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#74
  def run_all_cops(line_length_contents); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#63
  def run_line_length_cop; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#48
  def same_max_line_length?(config1, config2); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#39
  def skip_line_length_cop(reason); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#125
  def write_config_file(file_name, file_string, rubocop_yml_contents); end
end

# source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#11
RuboCop::CLI::Command::AutoGenerateConfig::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#14
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1 = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#18
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_DISABLED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#17
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_OVERRIDDEN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#15
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_2 = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cli/command/auto_generate_config.rb#12
RuboCop::CLI::Command::AutoGenerateConfig::YAML_OPTIONAL_DOC_START = T.let(T.unsafe(nil), Regexp)

class RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/base.rb#26
  def initialize(env); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/base.rb#9
  def env; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cli/command/base.rb#21
    def by_command_name(name); end

    # source://rubocop/1.36.0/lib/rubocop/cli/command/base.rb#14
    def command_name; end

    # source://rubocop/1.36.0/lib/rubocop/cli/command/base.rb#14
    def command_name=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/cli/command/base.rb#16
    def inherited(subclass); end
  end
end

class RuboCop::CLI::Command::ExecuteRunner < ::RuboCop::CLI::Command::Base
  include ::RuboCop::Formatter::TextUtil

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#16
  def run; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#69
  def display_error_summary(errors); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#56
  def display_summary(runner); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#61
  def display_warning_summary(warnings); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#22
  def execute_runner(paths); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#86
  def maybe_print_corrected_source; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#42
  def with_redirect; end
end

# source://rubocop/1.36.0/lib/rubocop/cli/command/execute_runner.rb#12
RuboCop::CLI::Command::ExecuteRunner::INTEGRATION_FORMATTERS = T.let(T.unsafe(nil), Array)

class RuboCop::CLI::Command::InitDotfile < ::RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/init_dotfile.rb#13
  def run; end
end

# source://rubocop/1.36.0/lib/rubocop/cli/command/init_dotfile.rb#9
RuboCop::CLI::Command::InitDotfile::DOTFILE = T.let(T.unsafe(nil), String)

class RuboCop::CLI::Command::ShowCops < ::RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#12
  def initialize(env); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#19
  def run; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#67
  def config_lines(cop); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#63
  def cops_of_department(cops, department); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#25
  def print_available_cops; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#48
  def print_cop_details(cops); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#36
  def print_cops_of_department(registry, department, show_all); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_cops.rb#57
  def selected_cops_of_department(cops, department); end
end

class RuboCop::CLI::Command::ShowDocsUrl < ::RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_docs_url.rb#12
  def initialize(env); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_docs_url.rb#18
  def run; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_docs_url.rb#38
  def cops_array; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_docs_url.rb#24
  def print_documentation_url; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/show_docs_url.rb#42
  def registry_hash; end
end

class RuboCop::CLI::Command::SuggestExtensions < ::RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#17
  def run; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#73
  def all_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#69
  def current_formatter; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#104
  def dependent_gems; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#80
  def extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#96
  def installed_and_not_loaded_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#84
  def installed_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#108
  def installed_gems; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#92
  def loaded_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#100
  def lockfile; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#88
  def not_installed_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#41
  def print_install_suggestions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#51
  def print_load_suggestions; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#60
  def print_opt_out_instruction; end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#112
  def puts(*args); end

  # source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#30
  def skip?; end
end

# source://rubocop/1.36.0/lib/rubocop/cli/command/suggest_extensions.rb#13
RuboCop::CLI::Command::SuggestExtensions::INCLUDED_FORMATTERS = T.let(T.unsafe(nil), Array)

class RuboCop::CLI::Command::Version < ::RuboCop::CLI::Command::Base
  # source://rubocop/1.36.0/lib/rubocop/cli/command/version.rb#11
  def run; end
end

# source://rubocop/1.36.0/lib/rubocop/cli.rb#11
RuboCop::CLI::DEFAULT_PARALLEL_OPTIONS = T.let(T.unsafe(nil), Array)

class RuboCop::CLI::Environment
  # source://rubocop/1.36.0/lib/rubocop/cli/environment.rb#10
  def initialize(options, config_store, paths); end

  # source://rubocop/1.36.0/lib/rubocop/cli/environment.rb#8
  def config_store; end

  # source://rubocop/1.36.0/lib/rubocop/cli/environment.rb#8
  def options; end

  # source://rubocop/1.36.0/lib/rubocop/cli/environment.rb#8
  def paths; end

  # source://rubocop/1.36.0/lib/rubocop/cli/environment.rb#17
  def run(name); end
end

class RuboCop::CLI::Finished < ::StandardError; end

# source://rubocop/1.36.0/lib/rubocop/cli.rb#9
RuboCop::CLI::STATUS_ERROR = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cli.rb#10
RuboCop::CLI::STATUS_INTERRUPTED = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cli.rb#8
RuboCop::CLI::STATUS_OFFENSES = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cli.rb#7
RuboCop::CLI::STATUS_SUCCESS = T.let(T.unsafe(nil), Integer)

class RuboCop::CacheConfig
  class << self
    # source://rubocop/1.36.0/lib/rubocop/cache_config.rb#7
    def root_dir; end
  end
end

class RuboCop::CachedData
  # source://rubocop/1.36.0/lib/rubocop/cached_data.rb#9
  def initialize(filename); end

  # source://rubocop/1.36.0/lib/rubocop/cached_data.rb#13
  def from_json(text); end

  # source://rubocop/1.36.0/lib/rubocop/cached_data.rb#17
  def to_json(offenses); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cached_data.rb#47
  def deserialize_offenses(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/cached_data.rb#40
  def message(offense); end

  # source://rubocop/1.36.0/lib/rubocop/cached_data.rb#23
  def serialize_offense(offense); end
end

class RuboCop::CommentConfig
  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#11
  def initialize(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#31
  def comment_only_line?(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#23
  def cop_disabled_line_ranges; end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#15
  def cop_enabled_at_line?(cop, line_number); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#27
  def extra_enabled_comments; end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#9
  def processed_source; end

  private

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#51
  def analyze; end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#67
  def analyze_cop(analysis, directive); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#87
  def analyze_disabled(analysis, directive); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#98
  def analyze_rest(analysis, directive); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#78
  def analyze_single_line(analysis, directive); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#107
  def cop_line_ranges(analysis); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#113
  def each_directive; end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#37
  def extra_enabled_comments_with_names(extras:, names:); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#131
  def handle_enable_all(directive, names, extras); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#145
  def handle_switch(directive, names, extras); end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#124
  def non_comment_token_line_numbers; end

  # source://rubocop/1.36.0/lib/rubocop/comment_config.rb#120
  def qualified_cop_name(cop_name); end
end

class RuboCop::CommentConfig::CopAnalysis < ::Struct
  def line_ranges; end
  def line_ranges=(_); end
  def start_line_number; end
  def start_line_number=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  extend ::Forwardable

  # source://rubocop/1.36.0/lib/rubocop/config.rb#24
  def initialize(hash = T.unsafe(nil), loaded_path = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def []=(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#149
  def active_support_extensions_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#92
  def add_excludes_from_higher_level(highest_config); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#172
  def allowed_camel_case_file?(file); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#216
  def base_dir_for_path_parameters; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#241
  def bundler_lock_file_path; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#47
  def check; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#104
  def deprecation_check; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def dig(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#141
  def disabled_new_cops?; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_key(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#145
  def enabled_new_cops?; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def fetch(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#194
  def file_to_exclude?(file); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#153
  def file_to_include?(file); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#137
  def for_all_cops; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#124
  def for_badge(badge); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#118
  def for_cop(cop); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#132
  def for_department(department_name); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#72
  def internal?; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def key?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def keys(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#43
  def loaded_features; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#22
  def loaded_path; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#77
  def make_excludes_absolute; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def map(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def merge(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#207
  def path_relative_to_config(path); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#203
  def patterns_to_exclude; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#199
  def patterns_to_include; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#252
  def pending_cops; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#186
  def possibly_include_hidden?; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def replace(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#67
  def signature; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#237
  def smart_loaded_path; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#226
  def target_rails_version; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def target_ruby_version(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_h(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_hash(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#63
  def to_s; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def transform_values(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def validate(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#54
  def validate_after_resolution; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config.rb#294
  def department_of(qualified_cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#282
  def enable_cop?(qualified_cop_name, cop_options); end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#270
  def read_rails_version_from_bundler_lock_file; end

  # source://rubocop/1.36.0/lib/rubocop/config.rb#266
  def target_rails_version_from_bundler_lock_file; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/config.rb#36
    def create(hash, path, check: T.unsafe(nil)); end
  end
end

class RuboCop::Config::CopConfig < ::Struct
  def metadata; end
  def metadata=(_); end
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/config.rb#21
RuboCop::Config::DEFAULT_RAILS_VERSION = T.let(T.unsafe(nil), Float)

class RuboCop::ConfigFinder
  extend ::RuboCop::FileFinder

  class << self
    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#19
    def find_config_path(target_dir); end

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#26
    def project_root; end

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#17
    def project_root=(_arg0); end

    private

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#59
    def expand_path(path); end

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#40
    def find_project_dotfile(target_dir); end

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#32
    def find_project_root; end

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#44
    def find_user_dotfile; end

    # source://rubocop/1.36.0/lib/rubocop/config_finder.rb#52
    def find_user_xdg_config; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/config_finder.rb#12
RuboCop::ConfigFinder::DEFAULT_FILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/config_finder.rb#9
RuboCop::ConfigFinder::DOTFILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/config_finder.rb#11
RuboCop::ConfigFinder::RUBOCOP_HOME = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/config_finder.rb#10
RuboCop::ConfigFinder::XDG_CONFIG = T.let(T.unsafe(nil), String)

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder

  class << self
    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#123
    def add_excludes_from_files(config, config_file); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#185
    def add_loaded_features(loaded_features); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#73
    def add_missing_namespaces(path, hash); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#34
    def clear_options; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#97
    def configuration_file_for(target_dir); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#101
    def configuration_from_file(config_file, check: T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def debug; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def debug=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def debug?; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#133
    def default_configuration; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#28
    def default_configuration=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def disable_pending_cops; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def disable_pending_cops=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def enable_pending_cops; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def enable_pending_cops=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def ignore_parent_exclusion; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def ignore_parent_exclusion=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def ignore_parent_exclusion?; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def ignore_unrecognized_cops; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#26
    def ignore_unrecognized_cops=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#40
    def load_file(file, check: T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#60
    def load_yaml_configuration(absolute_path); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#29
    def loaded_features; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#88
    def merge(base_hash, derived_hash); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#178
    def merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#118
    def possible_new_cops?(config); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#143
    def project_root; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#160
    def warn_on_pending_cops(pending_cops); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#170
    def warn_pending_cop(cop); end

    private

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#199
    def check_duplication(yaml_code, absolute_path); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#191
    def file_path(file); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#219
    def read_file(absolute_path); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#195
    def resolver; end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#225
    def yaml_safe_load(yaml_code, filename); end

    # source://rubocop/1.36.0/lib/rubocop/config_loader.rb#236
    def yaml_safe_load!(yaml_code, filename); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/config_loader.rb#21
RuboCop::ConfigLoader::DEFAULT_FILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/config_loader.rb#19
RuboCop::ConfigLoader::DOTFILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/config_loader.rb#20
RuboCop::ConfigLoader::RUBOCOP_HOME = T.let(T.unsafe(nil), String)

class RuboCop::ConfigLoaderResolver
  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#45
  def fix_include_paths(base_config_path, hash, path, key, value); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#99
  def merge(base_hash, derived_hash, **opts); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#75
  def merge_with_default(config, config_file, unset_nil:); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#119
  def override_department_setting_for_cops(base_hash, derived_hash); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#136
  def override_enabled_for_disabled_departments(base_hash, derived_hash); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#19
  def resolve_inheritance(path, hash, file, debug); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#55
  def resolve_inheritance_from_gems(hash); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#10
  def resolve_requires(path, hash); end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#208
  def base_configs(path, inherit_from, file); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#176
  def determine_inherit_mode(hash, key); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#152
  def disabled?(hash, department); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#156
  def duplicate_setting?(base_hash, derived_hash, key, inherited_file); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#264
  def gem_config_path(gem_name, relative_config_path); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#242
  def handle_disabled_by_default(config, new_default_configuration); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#216
  def inherited_file(path, inherit_from, file); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#204
  def merge_hashes?(base_hash, derived_hash, key); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#237
  def remote_file?(uri); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#196
  def should_merge?(mode, key); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#200
  def should_override?(mode, key); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#182
  def should_union?(derived_hash, base_hash, root_mode, key); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#260
  def transform(config, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config_loader_resolver.rb#165
  def warn_on_duplicate_setting(base_hash, derived_hash, key, **opts); end
end

class RuboCop::ConfigNotFoundError < ::RuboCop::Error; end

class RuboCop::ConfigObsoletion
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#33
  def initialize(config); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#39
  def reject_obsolete!; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#19
  def rules; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#19
  def warnings; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#69
  def load_cop_rules(rules); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#82
  def load_parameter_rules(rules); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#50
  def load_rules; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#95
  def obsoletions; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#22
    def files; end

    # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#22
    def files=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#24
    def legacy_cop_names; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#8
RuboCop::ConfigObsoletion::COP_RULE_CLASSES = T.let(T.unsafe(nil), Hash)

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles < ::RuboCop::ConfigObsoletion::ParameterRule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/changed_enforced_styles.rb#14
  def message; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/changed_enforced_styles.rb#10
  def violated?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/changed_enforced_styles.rb#28
  def value; end
end

# source://rubocop/1.36.0/lib/rubocop/config_obsoletion/changed_enforced_styles.rb#8
RuboCop::ConfigObsoletion::ChangedEnforcedStyles::BASE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::ChangedParameter < ::RuboCop::ConfigObsoletion::ParameterRule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/changed_parameter.rb#10
  def message; end
end

# source://rubocop/1.36.0/lib/rubocop/config_obsoletion/changed_parameter.rb#8
RuboCop::ConfigObsoletion::ChangedParameter::BASE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::CopRule < ::RuboCop::ConfigObsoletion::Rule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/cop_rule.rb#10
  def initialize(config, old_name); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/cop_rule.rb#15
  def cop_rule?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/cop_rule.rb#19
  def message; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/cop_rule.rb#8
  def old_name; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/cop_rule.rb#28
  def violated?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/cop_rule.rb#24
  def warning?; end
end

# source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#7
RuboCop::ConfigObsoletion::DEFAULT_RULES_FILE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::ExtractedCop < ::RuboCop::ConfigObsoletion::CopRule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#11
  def initialize(config, old_name, gem); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#9
  def department; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#9
  def gem; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#23
  def rule_message; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#17
  def violated?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#32
  def affected_cops; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/extracted_cop.rb#41
  def feature_loaded?; end
end

# source://rubocop/1.36.0/lib/rubocop/config_obsoletion.rb#14
RuboCop::ConfigObsoletion::PARAMETER_RULE_CLASSES = T.let(T.unsafe(nil), Hash)

class RuboCop::ConfigObsoletion::ParameterRule < ::RuboCop::ConfigObsoletion::Rule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#10
  def initialize(config, cop, parameter, metadata); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#8
  def cop; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#8
  def metadata; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#8
  def parameter; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#17
  def parameter_rule?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#21
  def violated?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#25
  def warning?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#31
  def alternative; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#35
  def alternatives; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#39
  def reason; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/parameter_rule.rb#43
  def severity; end
end

class RuboCop::ConfigObsoletion::RemovedCop < ::RuboCop::ConfigObsoletion::CopRule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#13
  def initialize(config, old_name, metadata); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#9
  def metadata; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#9
  def old_name; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#18
  def rule_message; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#36
  def alternatives; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#32
  def reason; end
end

# source://rubocop/1.36.0/lib/rubocop/config_obsoletion/removed_cop.rb#11
RuboCop::ConfigObsoletion::RemovedCop::BASE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::RenamedCop < ::RuboCop::ConfigObsoletion::CopRule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/renamed_cop.rb#11
  def initialize(config, old_name, new_name); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/renamed_cop.rb#9
  def new_name; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/renamed_cop.rb#16
  def rule_message; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/renamed_cop.rb#22
  def moved?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/renamed_cop.rb#29
  def verb; end
end

class RuboCop::ConfigObsoletion::Rule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#8
  def initialize(config); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#13
  def cop_rule?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#18
  def parameter_rule?; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#22
  def violated?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#28
  def config; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#36
  def smart_loaded_path; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/rule.rb#30
  def to_sentence(collection, connector: T.unsafe(nil)); end
end

class RuboCop::ConfigObsoletion::SplitCop < ::RuboCop::ConfigObsoletion::CopRule
  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/split_cop.rb#11
  def initialize(config, old_name, metadata); end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/split_cop.rb#9
  def metadata; end

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/split_cop.rb#16
  def rule_message; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_obsoletion/split_cop.rb#22
  def alternatives; end
end

class RuboCop::ConfigRegeneration
  # source://rubocop/1.36.0/lib/rubocop/config_regeneration.rb#12
  def options; end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_regeneration.rb#29
  def generation_command; end

  # source://rubocop/1.36.0/lib/rubocop/config_regeneration.rb#25
  def todo_exists?; end
end

# source://rubocop/1.36.0/lib/rubocop/config_regeneration.rb#7
RuboCop::ConfigRegeneration::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/config_regeneration.rb#8
RuboCop::ConfigRegeneration::COMMAND_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/config_regeneration.rb#9
RuboCop::ConfigRegeneration::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class RuboCop::ConfigStore
  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#10
  def initialize; end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#52
  def for(file_or_dir); end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#61
  def for_dir(dir); end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#42
  def for_file(file); end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#46
  def for_pwd; end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#33
  def force_default_config!; end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#28
  def options_config=(options_config); end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#37
  def unvalidated; end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#7
  def validated; end

  # source://rubocop/1.36.0/lib/rubocop/config_store.rb#7
  def validated?; end
end

class RuboCop::ConfigValidator
  extend ::Forwardable

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#27
  def initialize(config); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def for_all_cops(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def smart_loaded_path(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#63
  def target_ruby_version; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#33
  def validate; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#59
  def validate_after_resolution; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#67
  def validate_section_presence(name); end

  private

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#104
  def alert_about_unrecognized_cops(invalid_cop_names); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#253
  def check_cop_config_value(hash, parent = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#77
  def check_obsoletions; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#84
  def check_target_ruby; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#195
  def each_invalid_parameter(cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#120
  def list_unknown_cops(invalid_cop_names); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#266
  def msg_not_boolean(parent, key, value); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#242
  def reject_conflicting_safe_settings; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#233
  def reject_mutually_exclusive_defaults; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#142
  def suggestion(name); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#75
  def target_ruby; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#207
  def validate_enforced_styles(valid_cop_names); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#169
  def validate_new_cops_parameter; end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#180
  def validate_parameter_names(valid_cop_names); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#227
  def validate_support_and_has_list(name, formats, valid); end

  # source://rubocop/1.36.0/lib/rubocop/config_validator.rb#158
  def validate_syntax_cop; end
end

# source://rubocop/1.36.0/lib/rubocop/config_validator.rb#12
RuboCop::ConfigValidator::COMMON_PARAMS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/config_validator.rb#14
RuboCop::ConfigValidator::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/config_validator.rb#18
RuboCop::ConfigValidator::NEW_COPS_VALUES = T.let(T.unsafe(nil), Array)

module RuboCop::Cop; end

module RuboCop::Cop::Alignment
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#26
  def check_alignment(items, base_column = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#12
  def column_delta; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#14
  def configured_indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#58
  def display_column(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#45
  def each_bad_alignment(items, base_column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#69
  def end_of_line_comment(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#18
  def indentation(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#22
  def offset(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#74
  def register_offense(offense_node, message_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#64
  def within?(inner, outer); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/alignment.rb#10
RuboCop::Cop::Alignment::SPACE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#29
    def align_end(corrector, processed_source, node, align_to); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#15
    def correct(corrector, processed_source, node, column_delta); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#13
    def processed_source; end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#124
    def alignment_column(align_to); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#40
    def autocorrect_line(corrector, line_begin_pos, expr, column_delta, taboo_ranges); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#81
    def block_comment_within?(expr); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#87
    def calculate_range(expr, line_begin_pos, column_delta); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#75
    def delimited_string_literal?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#110
    def each_line(expr); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#60
    def inside_string_range(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#54
    def inside_string_ranges(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#99
    def remove(range, corrector); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/alignment_corrector.rb#118
    def whitespace_range(node); end
  end
end

module RuboCop::Cop::AllowedIdentifiers
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_identifiers.rb#9
  def allowed_identifier?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_identifiers.rb#13
  def allowed_identifiers; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_identifiers.rb#7
RuboCop::Cop::AllowedIdentifiers::SIGILS = T.let(T.unsafe(nil), String)

module RuboCop::Cop::AllowedMethods
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_methods.rb#11
  def allowed_method?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_methods.rb#19
  def allowed_methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_methods.rb#27
  def cop_config_allowed_methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_methods.rb#31
  def cop_config_deprecated_values; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_methods.rb#11
  def ignored_method?(name); end
end

module RuboCop::Cop::AllowedPattern
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#10
  def allowed_line?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#30
  def allowed_patterns; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#46
  def cop_config_deprecated_methods_values; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#40
  def cop_config_patterns_values; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#10
  def ignored_line?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#23
  def matches_allowed_pattern?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#23
  def matches_ignored_pattern?(line); end
end

class RuboCop::Cop::AmbiguousCopName < ::RuboCop::Error
  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#11
  def initialize(name, origin, badges); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#8
RuboCop::Cop::AmbiguousCopName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::AnnotationComment
  extend ::Forwardable

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#13
  def initialize(comment, keywords); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#19
  def annotation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#31
  def bounds; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#9
  def colon; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#9
  def comment; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#23
  def correct?(colon:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#9
  def keyword; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#9
  def margin; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#9
  def note; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#9
  def space; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#60
  def just_keyword_of_sentence?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#56
  def keyword_appearance?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#39
  def keywords; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/annotation_comment.rb#41
  def split_comment(comment); end
end

module RuboCop::Cop::ArgumentRangeHelper
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/argument_range_helper.rb#25
  def all_arguments_range(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/argument_range_helper.rb#18
  def first_and_second_arguments_range(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/argument_range_helper.rb#12
  def first_argument_range(node); end
end

module RuboCop::Cop::ArrayMinSize
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/array_min_size.rb#19
  def array_style_detected(style, ary_size); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/array_min_size.rb#11
  def below_array_length?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/array_min_size.rb#38
  def largest_brackets_size(style, ary_size); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/array_min_size.rb#15
  def min_size_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/array_min_size.rb#48
  def smallest_percent_size(style, ary_size); end
end

module RuboCop::Cop::ArraySyntax
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/array_syntax.rb#10
  def bracketed_array_of?(element_type, node); end
end

module RuboCop::Cop::AutoCorrector
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/auto_corrector.rb#7
  def support_autocorrect?; end
end

module RuboCop::Cop::AutocorrectLogic
  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#7
  def autocorrect?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#31
  def autocorrect_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#15
  def autocorrect_requested?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#11
  def autocorrect_with_disable_uncorrectable?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#19
  def correctable?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#23
  def disable_uncorrectable?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#27
  def safe_autocorrect?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#46
  def disable_offense(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#95
  def disable_offense_at_end_of_line(range, eol_comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#99
  def disable_offense_before_and_after(range_by_lines); end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#91
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#81
  def range_by_lines(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#72
  def range_of_first_line(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/autocorrect_logic.rb#61
  def surrounding_heredoc(offense_range); end
end

class RuboCop::Cop::Badge
  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#31
  def initialize(class_name_parts); end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#37
  def ==(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#13
  def cop_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#13
  def department; end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#37
  def eql?(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#42
  def hash; end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#46
  def match?(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#54
  def qualified?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#50
  def to_s; end

  # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#58
  def with_department(department); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#25
    def camel_case(name_part); end

    # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#15
    def for(class_name); end

    # source://rubocop/1.36.0/lib/rubocop/cop/badge.rb#21
    def parse(identifier); end
  end
end

class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#71
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#223
  def active_support_extensions_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#107
  def add_global_offense(message = T.unsafe(nil), severity: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#118
  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#274
  def callbacks_needed; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#43
  def config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#207
  def config_to_allow_offenses; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#211
  def config_to_allow_offenses=(hash); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#201
  def cop_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#193
  def cop_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#233
  def excluded_file?(file); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#147
  def external_dependency_checksum; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#101
  def message(_range = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#193
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#266
  def offenses; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#85
  def on_investigation_end; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#79
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#91
  def on_other_file; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#238
  def parse(source, path = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#43
  def processed_source; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#257
  def ready; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#227
  def relevant_file?(file); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#219
  def target_rails_version; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#215
  def target_ruby_version; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#405
  def annotate(message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#294
  def apply_correction(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#369
  def attempt_correction(range, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#313
  def begin_investigation(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#290
  def callback_argument(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#322
  def complete_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#343
  def correct(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#300
  def current_offense_locations; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#304
  def currently_disabled_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#440
  def custom_severity; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#436
  def default_severity; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#383
  def disable_uncorrectable(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#426
  def enabled_line?(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#411
  def file_name_matches_any?(file, parameter, default_result); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#401
  def find_message(range, message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#432
  def find_severity(_range, severity); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#390
  def range_from_node_or_range(node_or_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#338
  def reset_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#358
  def use_corrector(range, corrector); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#59
    def autocorrect_incompatible_with; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#169
    def badge; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#279
    def callbacks_needed; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#173
    def cop_name; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#177
    def department; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#67
    def documentation_url; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#157
    def exclude_from_registry; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#151
    def inherited(subclass); end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#96
    def joining_forces; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#181
    def lint?; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#187
    def match?(given_names); end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#163
    def support_autocorrect?; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#251
    def support_multiple_source?; end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#330
    def builtin?; end

    # source://rubocop/1.36.0/lib/rubocop/cop/base.rb#308
    def restrict_on_send; end
  end
end

class RuboCop::Cop::Base::InvestigationReport < ::Struct
  def cop; end
  def cop=(_); end
  def corrector; end
  def corrector=(_); end
  def offenses; end
  def offenses=(_); end
  def processed_source; end
  def processed_source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/base.rb#51
RuboCop::Cop::Base::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

module RuboCop::Cop::Bundler; end

class RuboCop::Cop::Bundler::DuplicatedGem < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#57
  def gem_declarations(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#44
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#66
  def conditional_declaration?(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#59
  def duplicated_gem_nodes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#80
  def register_offense(node, gem_name, line_of_first_occurrence); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#74
  def within_conditional?(node, conditional_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/duplicated_gem.rb#41
RuboCop::Cop::Bundler::DuplicatedGem::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Bundler::GemComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::DefNode
  include ::RuboCop::Cop::GemDeclaration

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#94
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#135
  def checked_options_present?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#109
  def commented?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#105
  def commented_any_descendant?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#159
  def contains_checked_options?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#163
  def gem_options(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#130
  def ignored_gem?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#116
  def precede?(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#126
  def preceding_comment?(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#120
  def preceding_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#152
  def restrictive_version_specified_gem?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#145
  def version_specified_gem?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#88
RuboCop::Cop::Bundler::GemComment::CHECKED_OPTIONS_CONFIG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#87
RuboCop::Cop::Bundler::GemComment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#91
RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#90
RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#92
RuboCop::Cop::Bundler::GemComment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_comment.rb#89
RuboCop::Cop::Bundler::GemComment::VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Bundler::GemFilename < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#43
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#88
  def expected_gemfile?(basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#80
  def gemfile_offense?(basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#93
  def gemfile_required?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#84
  def gems_rb_offense?(basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#97
  def gems_rb_required?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#58
  def register_gemfile_offense(file_path, basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#69
  def register_gems_rb_offense(file_path, basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#53
  def register_offense(file_path, basename); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#40
RuboCop::Cop::Bundler::GemFilename::GEMFILE_FILES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#41
RuboCop::Cop::Bundler::GemFilename::GEMS_RB_FILES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#36
RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_MISMATCHED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#32
RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_REQUIRED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#38
RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_MISMATCHED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_filename.rb#34
RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_REQUIRED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Bundler::GemVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemDeclaration

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#67
  def includes_commit_reference?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#62
  def includes_version_specification?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#71
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#85
  def allowed_gem?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#89
  def allowed_gems; end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#113
  def forbidden_offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#119
  def forbidden_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#93
  def message(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#103
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#107
  def required_offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#123
  def required_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#127
  def version_specification?(expression); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#58
RuboCop::Cop::Bundler::GemVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#57
RuboCop::Cop::Bundler::GemVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/gem_version.rb#59
RuboCop::Cop::Bundler::GemVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Bundler::InsecureProtocolSource < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/insecure_protocol_source.rb#54
  def insecure_protocol_source?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/insecure_protocol_source.rb#59
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/insecure_protocol_source.rb#80
  def allow_http_protocol?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/insecure_protocol_source.rb#45
RuboCop::Cop::Bundler::InsecureProtocolSource::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/insecure_protocol_source.rb#49
RuboCop::Cop::Bundler::InsecureProtocolSource::MSG_HTTP_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/insecure_protocol_source.rb#51
RuboCop::Cop::Bundler::InsecureProtocolSource::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Bundler::OrderedGems < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/ordered_gems.rb#56
  def gem_declarations(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/ordered_gems.rb#35
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/bundler/ordered_gems.rb#49
  def previous_declaration(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/bundler/ordered_gems.rb#31
RuboCop::Cop::Bundler::OrderedGems::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::CheckAssignment
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_and_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_masgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_or_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#19
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#29
  def extract_rhs(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_assignment.rb#29
    def extract_rhs(node); end
  end
end

module RuboCop::Cop::CheckLineBreakable
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#45
  def extract_breakable_node(node, max); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#200
  def all_on_same_line?(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#220
  def already_on_multiple_lines?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#133
  def breakable_collection?(node, elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#187
  def children_could_be_broken_up?(children); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#150
  def contained_by_breakable_collection_on_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#170
  def contained_by_multiline_collection_that_could_be_broken_up?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#60
  def extract_breakable_node_from_elements(node, elements, max); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#72
  def extract_first_element_over_column_limit(node, elements, max); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#92
  def first_argument_is_heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#207
  def process_args(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#117
  def safe_to_ignore?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#101
  def shift_elements_for_heredoc_arg(node, elements, index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/check_line_breakable.rb#112
  def within_column_limit?(element, max, line); end
end

module RuboCop::Cop::CodeLength
  extend ::RuboCop::ExcludeLimit

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#49
  def build_code_length_calculator(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#31
  def check_code_length(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#27
  def count_as_one; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#23
  def count_comments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#45
  def irrelevant_line(source_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#19
  def max_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#15
  def message(length, max_length); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/code_length.rb#9
RuboCop::Cop::CodeLength::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::CommentsHelp
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#18
  def comments_in_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#14
  def contains_comments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#7
  def source_range_with_comment(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#32
  def begin_pos_with_comment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#46
  def buffer; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#27
  def end_position_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#54
  def find_end_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/comments_help.rb#42
  def start_line_position(node); end
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#44
  def initialize(cops, forces = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#42
  def errors; end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#79
  def investigate(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on___ENCODING__(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on___FILE__(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on___LINE__(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_alias(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_and_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_arg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_arg_expr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_array_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_array_pattern_with_tail(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_back_ref(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_block_pass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_blockarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_break(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_cbase(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_complex(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_const(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_const_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_cvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_defined?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_dstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_dsym(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_eflipflop(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_empty_else(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_ensure(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_erange(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_false(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_find_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_float(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_forward_arg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_forward_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_forwarded_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_gvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_hash(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_hash_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_if_guard(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_iflipflop(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_in_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_in_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_index(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_indexasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_int(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_irange(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_ivar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwargs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwbegin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwnilarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwoptarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwrestarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_kwsplat(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_lambda(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_lvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_masgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_alt(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_as(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_current_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_nil_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_pattern_p(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_rest(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_var(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_with_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_match_with_trailing_comma(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_mlhs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_next(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_nil(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_not(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_nth_ref(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_optarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_or_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_pair(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_pin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_postexe(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_preexe(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_procarg0(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_rational(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_redo(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_regexp(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_regopt(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_restarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_retry(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_return(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_sclass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_self(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_shadowarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_splat(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_str(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_super(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_sym(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_true(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_undef(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_unless_guard(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_when(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_while_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_xstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_yield(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#68
  def on_zsuper(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#114
  def build_callbacks(cops); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#109
  def initialize_callbacks; end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#152
  def invoke(callback, cops, *args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#105
  def reset; end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#124
  def restrict_callbacks(callbacks); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#142
  def restricted_map(callbacks); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#97
  def trigger_responding_cops(callback, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#132
  def trigger_restricted_cops(event, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#159
  def with_cop_error_handling(cop, node = T.unsafe(nil)); end
end

class RuboCop::Cop::Commissioner::InvestigationReport < ::Struct
  def cop_reports; end
  def cop_reports=(_); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#19
  def cops; end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#27
  def correctors; end

  def errors; end
  def errors=(_); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#35
  def merge(investigation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#31
  def offenses; end

  # source://rubocop/1.36.0/lib/rubocop/cop/commissioner.rb#23
  def offenses_per_cop; end

  def processed_source; end
  def processed_source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::ConditionCorrector
  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/condition_corrector.rb#8
    def correct_negative_condition(corrector, node); end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/condition_corrector.rb#17
    def negated_condition(node); end
  end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#76
  def alternative_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#84
  def alternative_styles; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#19
  def ambiguous_style_detected(*possibilities); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#48
  def conflicting_styles_detected; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#11
  def correct_style_detected; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#52
  def detected_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#56
  def detected_style=(style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#48
  def no_acceptable_style!; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#44
  def no_acceptable_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#7
  def opposite_style_detected; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#67
  def style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#63
  def style_configured?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#23
  def style_detected(detected); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#95
  def style_parameter_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#88
  def supported_styles; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#15
  def unexpected_style_detected(unexpected); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_enforced_style.rb#48
  def unrecognized_style_detected; end
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_formatting.rb#9
  def check_name(node, name, name_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_formatting.rb#29
  def class_emitter_method?(node, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_formatting.rb#17
  def report_opposing_styles(node, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_formatting.rb#23
  def valid_name?(node, name, given_style = T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableMax
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_max.rb#11
  def max=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_max.rb#19
  def max_parameter_name; end
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_naming.rb#10
RuboCop::Cop::ConfigurableNaming::FORMATS = T.let(T.unsafe(nil), Hash)

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/configurable_numbering.rb#11
RuboCop::Cop::ConfigurableNumbering::FORMATS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Cop < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#25
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#60
  def corrections; end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#37
  def find_location(node, loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#12
  def offenses; end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#74
  def on_investigation_end; end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#68
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#43
  def support_autocorrect?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#109
  def apply_correction(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#98
  def begin_investigation(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#105
  def callback_argument(_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#126
  def correction_lambda; end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#132
  def dedup_on_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#114
  def emulate_v0_callsequence(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#139
  def suppress_clobbering; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#87
    def all; end

    # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#52
    def joining_forces; end

    # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#92
    def qualified_cop_name(name, origin); end

    # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#82
    def registry; end

    # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#48
    def support_autocorrect?; end
  end
end

class RuboCop::Cop::Cop::Correction < ::Struct
  # source://rubocop/1.36.0/lib/rubocop/cop/cop.rb#18
  def call(corrector); end

  def cop; end
  def cop=(_); end
  def lambda; end
  def lambda=(_); end
  def node; end
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::Corrector < ::Parser::Source::TreeRewriter
  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#18
  def initialize(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#49
  def remove_leading(node_or_range, size); end

  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#37
  def remove_preceding(node_or_range, size); end

  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#61
  def remove_trailing(node_or_range, size); end

  # source://parser/3.1.2.1/lib/parser/source/tree_rewriter.rb#252
  def rewrite; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#99
  def check_range_validity(node_or_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#84
  def to_range(node_or_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#103
  def validate_buffer(buffer); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#68
    def source_buffer(source); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/corrector.rb#12
RuboCop::Cop::Corrector::NOOP_CONSUMER = T.let(T.unsafe(nil), Proc)

module RuboCop::Cop::DefNode
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/def_node.rb#21
  def non_public_modifier?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/def_node.rb#12
  def non_public?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/def_node.rb#16
  def preceding_non_public_modifier?(node); end
end

module RuboCop::Cop::Documentation
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#24
  def base_url_for(cop_class, config); end

  # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#34
  def default_base_url; end

  # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#10
  def department_to_basename(department); end

  # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#15
  def url_for(cop_class, config = T.unsafe(nil)); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#24
    def base_url_for(cop_class, config); end

    # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#34
    def default_base_url; end

    # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#10
    def department_to_basename(department); end

    # source://rubocop/1.36.0/lib/rubocop/cop/documentation.rb#15
    def url_for(cop_class, config = T.unsafe(nil)); end
  end
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#47
  def annotation_keywords; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#11
  def documentation_comment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#39
  def interpreter_directive_comment?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#31
  def precede?(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#25
  def preceding_comment?(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#35
  def preceding_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/documentation_comment.rb#43
  def rubocop_directive_comment?(comment); end
end

module RuboCop::Cop::Duplication
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/duplication.rb#31
  def consecutive_duplicates(collection); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/duplication.rb#22
  def duplicates(collection); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/duplication.rb#13
  def duplicates?(collection); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/duplication.rb#41
  def grouped_duplicates(collection); end
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#12
  def initialize(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#18
  def call(corrector); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#24
  def argument_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#24
  def block_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#24
  def collection_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#26
  def correction; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#36
  def offending_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#44
  def replacement_range(end_pos); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#10
RuboCop::Cop::EachToForCorrector::CORRECTION_WITHOUT_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/correctors/each_to_for_corrector.rb#9
RuboCop::Cop::EachToForCorrector::CORRECTION_WITH_ARGUMENTS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::EmptyLineCorrector
  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/empty_line_corrector.rb#8
    def correct(corrector, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/empty_line_corrector.rb#19
    def insert_before(corrector, node); end
  end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_parameter.rb#12
  def empty_arguments?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_parameter.rb#16
  def check(node); end
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#60
  def accept_end_kw_alignment?(end_loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#50
  def add_offense_for_misalignment(node, align_with); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#19
  def check_end_kw_alignment(node, align_ranges); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#15
  def check_end_kw_in_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#75
  def line_break_before_keyword?(whole_expression, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#35
  def matching_ranges(end_loc, align_ranges); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#41
  def start_line_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#65
  def style_parameter_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#69
  def variable_alignment?(whole_expression, rhs, end_alignment_style); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/end_keyword_alignment.rb#10
RuboCop::Cop::EndKeywordAlignment::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::EnforceSuperclass
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/enforce_superclass.rb#35
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/enforce_superclass.rb#39
  def on_send(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/enforce_superclass.rb#16
    def included(base); end
  end
end

module RuboCop::Cop::FirstElementLineBreak
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/first_element_line_break.rb#23
  def check_children_line_break(node, children, start = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/first_element_line_break.rb#10
  def check_method_line_break(node, children); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/first_element_line_break.rb#37
  def first_by_line(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/first_element_line_break.rb#41
  def last_by_line(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/first_element_line_break.rb#18
  def method_uses_parens?(node, limit); end
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#11
  def initialize(for_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#17
  def call(corrector); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#55
  def collection_end; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def collection_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#29
  def collection_source; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#25
  def correction; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#43
  def end_position; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def for_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#51
  def keyword_begin; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#63
  def offending_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#67
  def replacement_range(end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#37
  def requires_parentheses?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def variable_node; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/correctors/for_to_each_corrector.rb#9
RuboCop::Cop::ForToEachCorrector::CORRECTION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Force
  # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#22
  def initialize(cops); end

  # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#7
  def cops; end

  # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#38
  def investigate(_processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#26
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#30
  def run_hook(method_name, *args); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#9
    def all; end

    # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#18
    def force_name; end

    # source://rubocop/1.36.0/lib/rubocop/cop/force.rb#13
    def inherited(subclass); end
  end
end

module RuboCop::Cop::FrozenStringLiteral
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#35
  def frozen_heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#21
  def frozen_string_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#15
  def frozen_string_literal_comment_exists?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#66
  def frozen_string_literal_specified?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#60
  def frozen_string_literals_disabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#41
  def frozen_string_literals_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#72
  def leading_comment_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#31
  def uninterpolated_string?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#15
    def frozen_string_literal_comment_exists?; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#9
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/frozen_string_literal.rb#10
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_ENABLED = T.let(T.unsafe(nil), String)

module RuboCop::Cop::GemDeclaration
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/gem_declaration.rb#10
  def gem_declaration?(param0 = T.unsafe(nil)); end
end

module RuboCop::Cop::Gemspec; end

class RuboCop::Cop::Gemspec::DependencyVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemspecHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#62
  def add_dependency_method_declarations(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#73
  def includes_commit_reference?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#68
  def includes_version_specification?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#77
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#118
  def add_dependency_method?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#122
  def add_dependency_method_nodes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#94
  def allowed_gem?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#98
  def allowed_gems; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#136
  def forbidden_offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#142
  def forbidden_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#112
  def match_block_variable_name?(receiver_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#102
  def message(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#126
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#130
  def required_offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#146
  def required_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#150
  def version_specification?(expression); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#58
RuboCop::Cop::Gemspec::DependencyVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#57
RuboCop::Cop::Gemspec::DependencyVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/dependency_version.rb#59
RuboCop::Cop::Gemspec::DependencyVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#35
  def gem_specification(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#43
  def on_block(block_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#86
  def format_message_from; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#63
  def node_and_method_name(node, attribute); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#72
  def use_deprecated_attributes?(node, block_parameter); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#32
RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::DuplicatedAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::GemspecHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/duplicated_assignment.rb#45
  def assignment_method_declarations(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/duplicated_assignment.rb#50
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/duplicated_assignment.rb#68
  def duplicated_assignment_method_nodes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/duplicated_assignment.rb#62
  def match_block_variable_name?(receiver_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/duplicated_assignment.rb#76
  def register_offense(node, assignment, line_of_first_occurrence); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/duplicated_assignment.rb#41
RuboCop::Cop::Gemspec::DuplicatedAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::OrderedDependencies < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ordered_dependencies.rb#87
  def dependency_declarations(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ordered_dependencies.rb#61
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ordered_dependencies.rb#82
  def get_dependency_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ordered_dependencies.rb#76
  def previous_declaration(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ordered_dependencies.rb#57
RuboCop::Cop::Gemspec::OrderedDependencies::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::RequireMFA < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::GemspecHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#70
  def metadata(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#87
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#78
  def rubygems_mfa_required(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#83
  def true_string?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#115
  def autocorrect(corrector, node, block_var, metadata); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#139
  def change_value(corrector, value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#125
  def correct_metadata(corrector, metadata); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#133
  def insert_mfa_required(corrector, node, block_var); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#108
  def mfa_value(metadata_value); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/require_mfa.rb#67
RuboCop::Cop::Gemspec::RequireMFA::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::RequiredRubyVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#70
  def defined_ruby_version(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#78
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#82
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#65
  def required_ruby_version?(param0); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#94
  def dynamic_version?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#100
  def extract_ruby_version(required_ruby_version); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#116
  def not_equal_message(required_ruby_version, target_ruby_version); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#62
RuboCop::Cop::Gemspec::RequiredRubyVersion::MISSING_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#59
RuboCop::Cop::Gemspec::RequiredRubyVersion::NOT_EQUAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/required_ruby_version.rb#58
RuboCop::Cop::Gemspec::RequiredRubyVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::GemspecHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#36
  def on_const(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#34
  def ruby_version?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#44
  def gem_spec_with_ruby_version?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#31
RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::GemspecHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/gemspec_help.rb#20
  def gem_specification(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/gemspec_help.rb#10
  def gem_specification?(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Generator
  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#113
  def initialize(name, output: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#133
  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#129
  def inject_require(root_file_path: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#146
  def todo; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#121
  def write_source; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#125
  def write_spec; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#160
  def badge; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#183
  def generate(template); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#175
  def generated_source; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#179
  def generated_spec; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#160
  def output; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#208
  def snake_case(camel_case_string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#198
  def source_path; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#188
  def spec_path; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#162
  def write_unless_file_exists(path, contents); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#109
RuboCop::Cop::Generator::CONFIGURATION_ADDED_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Generator::ConfigurationInjector
  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#17
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#24
  def inject; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#39
  def badge; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#41
  def configuration_entries; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#39
  def configuration_file_path; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#59
  def cop_name_line?(yaml); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#49
  def find_target_line; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#45
  def new_configuration_entry; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#39
  def output; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#39
  def version_added; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/generator/configuration_injector.rb#10
RuboCop::Cop::Generator::ConfigurationInjector::TEMPLATE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Generator::RequireFileInjector
  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#12
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#19
  def inject; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#64
  def injectable_require_directive; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#29
  def output; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#29
  def require_entries; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#31
  def require_exists?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#68
  def require_path; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#58
  def require_path_fragments(require_directive); end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#29
  def root_file_path; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#29
  def source_path; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#39
  def target_line; end

  # source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#35
  def updated_directives; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/generator/require_file_injector.rb#10
RuboCop::Cop::Generator::RequireFileInjector::REQUIRE_PATH = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#11
RuboCop::Cop::Generator::SOURCE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/generator.rb#85
RuboCop::Cop::Generator::SPEC_TEMPLATE = T.let(T.unsafe(nil), String)

module RuboCop::Cop::HashAlignmentStyles; end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#9
  def checkable_layout?(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#20
  def deltas(first_pair, current_pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#13
  def deltas_for_first_pair(first_pair, _node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#34
  def separator_delta(pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#45
  def value_delta(pair); end
end

class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#146
  def deltas(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#123
  def deltas_for_first_pair(*_nodes); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#133
  def hash_rocket_delta(first_pair, current_pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#129
  def key_delta(first_pair, current_pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#137
  def value_delta(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#84
  def initialize; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#88
  def deltas_for_first_pair(first_pair, node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#106
  def hash_rocket_delta(first_pair, current_pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#102
  def key_delta(first_pair, current_pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#100
  def max_key_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#100
  def max_key_width=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#110
  def value_delta(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#57
  def checkable_layout?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#61
  def deltas(first_pair, current_pair); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_alignment_styles.rb#71
  def separator_delta(first_pair, current_pair, key_delta); end
end

module RuboCop::Cop::HashShorthandSyntax
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#13
  def on_hash_for_mixed_shorthand(hash_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#25
  def on_pair(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#106
  def breakdown_value_types_of_hash(hash_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#130
  def each_omittable_value_pair(hash_value_type_breakdown, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#126
  def each_omitted_value_pair(hash_value_type_breakdown, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#65
  def enforced_shorthand_syntax; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#118
  def hash_with_mixed_shorthand_syntax?(hash_value_type_breakdown); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#122
  def hash_with_values_that_cant_be_omitted?(hash_value_type_breakdown); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#59
  def ignore_hash_shorthand_syntax?(pair_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#54
  def ignore_mixed_hash_shorthand_syntax?(hash_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#134
  def mixed_shorthand_syntax_check(hash_value_type_breakdown); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#150
  def no_mixed_shorthand_syntax_check(hash_value_type_breakdown); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#48
  def register_offense(node, message, replacement); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#69
  def require_hash_value?(hash_key_source, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#78
  def require_hash_value_for_around_hash_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#87
  def use_element_of_hash_literal_as_receiver?(ancestor, parent); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#92
  def use_modifier_form_without_parenthesized_method_call?(ancestor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#98
  def without_parentheses_call_expr_follows?(ancestor); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#11
RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_EXPLICIT_VALUE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#9
RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_MSG_PREFIX = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#10
RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_OMIT_VALUE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#8
RuboCop::Cop::HashShorthandSyntax::EXPLICIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#7
RuboCop::Cop::HashShorthandSyntax::OMIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#13
  def array_receiver?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#17
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#34
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#27
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#108
  def execute_correction(corrector, node, correction); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#83
  def extract_captures(_match); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#60
  def handle_possible_offense(node, match, match_desc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#90
  def new_method_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#41
  def on_bad_each_with_object(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#46
  def on_bad_hash_brackets_map(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#51
  def on_bad_map_to_h(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#56
  def on_bad_to_h(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#94
  def prepare_correction(node); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection < ::Struct
  def block_node; end
  def block_node=(_); end
  def leading; end
  def leading=(_); end
  def match; end
  def match=(_); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#177
  def set_new_arg_name(transformed_argname, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#181
  def set_new_body_expression(transforming_body_expr, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#167
  def set_new_method_name(new_method_name, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#161
  def strip_prefix_and_suffix(node, corrector); end

  def trailing; end
  def trailing=(_); end

  class << self
    def [](*_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#137
    def from_each_with_object(node, match); end

    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#141
    def from_hash_brackets_map(node, match); end

    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#145
    def from_map_to_h(node, match); end

    # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#157
    def from_to_h(node, match); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::HashTransformMethod::Captures < ::Struct
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#119
  def noop_transformation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#124
  def transformation_uses_both_args?; end

  def transformed_argname; end
  def transformed_argname=(_); end
  def transforming_body_expr; end
  def transforming_body_expr=(_); end
  def unchanged_body_expr; end
  def unchanged_body_expr=(_); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#128
  def use_transformed_argname?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/hash_transform_method.rb#10
RuboCop::Cop::HashTransformMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::Heredoc
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#9
  def on_dstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#17
  def on_heredoc(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#9
  def on_str(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#9
  def on_xstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#28
  def delimiter_string(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#32
  def heredoc_type(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#23
  def indent_level(str); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/heredoc.rb#7
RuboCop::Cop::Heredoc::OPENING_DELIMITER = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::IfThenCorrector
  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#9
  def initialize(if_node, indentation: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#14
  def call(corrector); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#50
  def branch_body_indentation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#20
  def if_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#20
  def indentation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#22
  def replacement(node = T.unsafe(nil), indentation = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#36
  def rewrite_else_branch(else_branch, indentation); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/correctors/if_then_corrector.rb#7
RuboCop::Cop::IfThenCorrector::DEFAULT_INDENTATION_WIDTH = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_methods.rb#38
RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

module RuboCop::Cop::IgnoredNode
  # source://rubocop/1.36.0/lib/rubocop/cop/ignored_node.rb#7
  def ignore_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/ignored_node.rb#24
  def ignored_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/ignored_node.rb#11
  def part_of_ignored_node?(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/ignored_node.rb#31
  def ignored_nodes; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/allowed_pattern.rb#54
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

module RuboCop::Cop::InDeltaMixin
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/in_delta_mixin.rb#10
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/in_delta_mixin.rb#35
  def assertion_method; end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/in_delta_mixin.rb#27
  def build_good_method(expected, actual, message); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/in_delta_mixin.rb#8
RuboCop::Cop::InDeltaMixin::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::IntegerNode
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/integer_node.rb#9
  def integer_part(node); end
end

module RuboCop::Cop::Interpolation
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/interpolation.rb#9
  def on_dstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/interpolation.rb#9
  def on_dsym(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/interpolation.rb#17
  def on_node_with_interpolations(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/interpolation.rb#9
  def on_regexp(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/interpolation.rb#9
  def on_xstr(node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#7
  def initialize(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#13
  def call(corrector); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#115
  def arg_to_unparenthesized_call?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def arguments; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#99
  def arguments_begin_pos; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#95
  def arguments_end_pos; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#107
  def block_begin; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#103
  def block_end; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def block_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#56
  def insert_arguments(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#40
  def insert_separating_space(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#85
  def lambda_arg_string; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def method; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#89
  def needs_separating_space?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#50
  def remove_arguments(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#63
  def remove_leading_whitespace(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#71
  def remove_trailing_whitespace(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#33
  def remove_unparenthesized_whitespace(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#76
  def replace_delimiters(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#46
  def replace_selector(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#111
  def selector_end; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#131
  def separating_space?; end
end

module RuboCop::Cop::Layout; end

class RuboCop::Cop::Layout::AccessModifierIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_sclass(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#54
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#58
  def check_body(body, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#65
  def check_modifier(send_node, end_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#88
  def expected_indent_offset; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#84
  def message(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#94
  def unexpected_indent_offset; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/access_modifier_indentation.rb#41
RuboCop::Cop::Layout::AccessModifierIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ArgumentAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#55
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#55
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#92
  def arguments_or_first_arg_pairs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#80
  def arguments_with_last_arg_pairs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#108
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#68
  def autocorrect_incompatible_with_other_cops?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#124
  def base_column(node, first_argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#144
  def enforce_hash_argument_with_separator?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#116
  def fixed_indentation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#72
  def flattened_arguments(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#152
  def hash_argument_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#112
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#101
  def multiple_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#135
  def target_method_lineno(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#120
  def with_first_argument_style?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#50
RuboCop::Cop::Layout::ArgumentAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/argument_alignment.rb#52
RuboCop::Cop::Layout::ArgumentAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ArrayAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#46
  def on_array(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#55
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#67
  def base_column(node, args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#63
  def fixed_indentation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#59
  def message(_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#78
  def target_method_lineno(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#40
RuboCop::Cop::Layout::ArrayAlignment::ALIGN_ELEMENTS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/array_alignment.rb#43
RuboCop::Cop::Layout::ArrayAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::AssignmentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/assignment_indentation.rb#42
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/assignment_indentation.rb#33
  def check_assignment(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/assignment_indentation.rb#46
  def leftmost_multiple_assignment(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/assignment_indentation.rb#29
RuboCop::Cop::Layout::AssignmentIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::BeginEndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/begin_end_alignment.rb#48
  def on_kwbegin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/begin_end_alignment.rb#63
  def alignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/begin_end_alignment.rb#59
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/begin_end_alignment.rb#54
  def check_begin_alignment(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/begin_end_alignment.rb#46
RuboCop::Cop::Layout::BeginEndAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::BlockAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#74
  def block_end_align_target?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#83
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#83
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#89
  def style_parameter_name; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#228
  def add_space_before(corrector, loc, delta); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#205
  def alt_start_msg(start_loc, source_line_column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#155
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#105
  def block_end_align_target(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#123
  def check_block_alignment(start_node, block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#178
  def compute_do_source_line_column(node, end_loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#220
  def compute_start_col(ancestor_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#119
  def disqualified_parent?(parent, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#115
  def end_align_target?(node, parent); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#168
  def format_message(start_loc, end_loc, do_source_line_column, error_source_line_column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#215
  def format_source_line_column(source_line_column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#197
  def loc_to_source_line_column(loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#136
  def register_offense(block_node, start_loc, end_loc, do_source_line_column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#232
  def remove_space_before(corrector, end_pos, delta); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#95
  def start_for_block_node(block_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/block_alignment.rb#71
RuboCop::Cop::Layout::BlockAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::BlockEndNewline < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#33
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#33
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#82
  def end_of_method_chain(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#64
  def last_heredoc_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#60
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#74
  def offense_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#46
  def register_offense(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/block_end_newline.rb#31
RuboCop::Cop::Layout::BlockEndNewline::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::CaseIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#120
  def on_case(case_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#127
  def on_case_match(case_match_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#193
  def base_column(case_node, base); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#150
  def check_when(when_node, branch_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#182
  def detect_incorrect_style(when_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#136
  def end_and_last_conditional_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#146
  def enforced_style_end?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#169
  def incorrect_style(when_node, branch_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#161
  def indent_one_step?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#165
  def indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#207
  def replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#200
  def whitespace_range(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/case_indentation.rb#118
RuboCop::Cop::Layout::CaseIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ClassStructure < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#150
  def dynamic_constant?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#156
  def on_class(class_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#171
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#288
  def begin_pos_with_comment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#311
  def buffer; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#323
  def categories; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#231
  def class_elements(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#191
  def classify(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#280
  def end_position_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#317
  def expected_order; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#209
  def find_category(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#307
  def find_heredoc(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#256
  def humanize_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#243
  def ignore?(classification); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#249
  def ignore_for_autocorrect?(node, sibling); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#265
  def source_range_with_comment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#303
  def start_line_position(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#222
  def walk_over_nested_class_definition(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#299
  def whole_line_comment_at_line?(line); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#140
RuboCop::Cop::Layout::ClassStructure::HUMANIZED_NODE_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/class_structure.rb#147
RuboCop::Cop::Layout::ClassStructure::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ClosingHeredocIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#58
  def on_heredoc(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#75
  def argument_indentation_correct?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#83
  def closing_indentation(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#102
  def find_node_used_heredoc_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#91
  def heredoc_closing(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#87
  def heredoc_opening(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#118
  def indent_level(source_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#95
  def indented_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#110
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#71
  def opening_indentation(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#54
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#55
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG_ARG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_heredoc_indentation.rb#53
RuboCop::Cop::Layout::ClosingHeredocIndentation::SIMPLE_HEREDOC = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ClosingParenthesisIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#84
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#79
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#88
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#88
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#79
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#157
  def all_elements_aligned?(elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#95
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#99
  def check(node, elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#107
  def check_for_elements(node, elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#125
  def check_for_no_elements(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#171
  def correct_column_candidates(node, left_paren); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#144
  def expected_column(left_paren, elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#167
  def first_argument_line(elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#187
  def indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#191
  def line_break_after_left_paren?(left_paren, elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#179
  def message(correct_column, left_paren, right_paren); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#77
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#75
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::CommentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#55
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#61
  def autocorrect(corrector, comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#88
  def autocorrect_one(corrector, comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#71
  def autocorrect_preceding_comments(corrector, comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#92
  def check(comment, comment_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#145
  def correct_indentation(next_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#121
  def correctly_aligned_with_preceding_comment?(comment_index, column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#156
  def less_indented?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#140
  def line_after_comment(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#131
  def message(column, correct_comment_indentation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#135
  def own_line_comment?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#82
  def should_correct?(preceding_comment, reference_comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#160
  def two_alternatives?(line); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/comment_indentation.rb#52
RuboCop::Cop::Layout::CommentIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ConditionPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/condition_position.rb#31
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/condition_position.rb#37
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/condition_position.rb#37
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/condition_position.rb#44
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/condition_position.rb#58
  def message(condition); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/condition_position.rb#29
RuboCop::Cop::Layout::ConditionPosition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::DefEndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/def_end_alignment.rb#43
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/def_end_alignment.rb#43
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/def_end_alignment.rb#48
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/def_end_alignment.rb#63
  def autocorrect(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/def_end_alignment.rb#41
RuboCop::Cop::Layout::DefEndAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::DotPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#34
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#34
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#137
  def ampersand_dot?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#49
  def autocorrect(corrector, dot, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#99
  def correct_dot_position_style?(dot_line, selector_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#126
  def end_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#122
  def heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#114
  def last_heredoc_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#95
  def line_between?(first_line, second_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#64
  def message(dot); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#74
  def proper_dot_position?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#106
  def receiver_end_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#130
  def selector_range(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/layout/dot_position.rb#30
    def autocorrect_incompatible_with; end
  end
end

class RuboCop::Cop::Layout::ElseAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#57
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#63
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#40
  def on_if(node, base = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#51
  def on_rescue(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#147
  def assignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#71
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#106
  def base_for_method_definition(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#80
  def base_range_of_if(node, base); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#89
  def base_range_of_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#131
  def check_alignment(base_range, else_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#115
  def check_assignment(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#75
  def check_nested(node, base); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/else_alignment.rb#38
RuboCop::Cop::Layout::ElseAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#69
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#131
  def allow_border_comment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#135
  def allow_margin_comment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#97
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#127
  def comment_text(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#108
  def concat_consecutive_comments(comments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#139
  def current_token(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#117
  def empty_comment_only?(comment_text); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#85
  def investigate(comments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#143
  def previous_token(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_comment.rb#67
RuboCop::Cop::Layout::EmptyComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#46
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#65
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#87
  def contains_guard_clause?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#80
  def correct_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#160
  def heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#153
  def heredoc_line(node, heredoc_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#129
  def last_heredoc_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#143
  def last_heredoc_argument_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#172
  def multiple_statements_on_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#98
  def next_line_empty?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#91
  def next_line_empty_or_enable_directive_comment?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#102
  def next_line_enable_directive_comment?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#108
  def next_line_rescue_or_ensure?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#122
  def next_sibling_empty_or_guard_clause?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#113
  def next_sibling_parent_empty_or_else?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#164
  def offense_location(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#44
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::END_OF_HEREDOC_LINE = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#43
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#29
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#54
  def last_magic_comment(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#43
  def offending_range(last_magic_comment); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#27
RuboCop::Cop::Layout::EmptyLineAfterMagicComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#82
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#60
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#93
  def on_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#70
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#75
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#70
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#75
  def on_while_post(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#127
  def autocorrect(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#105
  def check_condition(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#120
  def multiline_rescue_exceptions?(exception_nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#116
  def multiline_when_condition?(when_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#112
  def next_line_empty?(line); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#58
RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineBetweenDefs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#144
  def autocorrect(corrector, prev_def, node, count); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#130
  def check_defs(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#123
  def on_begin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#267
  def allowance_range?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#251
  def autocorrect_insert_lines(corrector, newline_pos, count); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#244
  def autocorrect_remove_lines(corrector, newline_pos, count); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#208
  def blank_lines_count_between(first_def_node, second_def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#162
  def candidate?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#172
  def class_candidate?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#232
  def def_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#228
  def def_start(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#236
  def end_loc(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#186
  def expected_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#204
  def line_count_allowed?(count); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#220
  def lines_between_defs(first_def_node, second_def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#216
  def maximum_empty_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#180
  def message(node, count: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#168
  def method_candidate?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#212
  def minimum_empty_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#176
  def module_candidate?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#195
  def multiple_blank_lines_groups?(first_def_node, second_def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#258
  def node_type(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#114
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_line_between_defs.rb#112
RuboCop::Cop::Layout::EmptyLineBetweenDefs::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines.rb#28
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines.rb#43
  def each_extra_empty_line(lines); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines.rb#61
  def exceeds_line_offset?(line_diff); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines.rb#65
  def previous_and_current_lines_empty?(line); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines.rb#26
RuboCop::Cop::Layout::EmptyLines::LINE_OFFSET = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines.rb#25
RuboCop::Cop::Layout::EmptyLines::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#54
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#79
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#60
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#69
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#79
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#74
  def on_sclass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#85
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#113
  def allowed_only_before_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#162
  def block_start?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#168
  def body_end?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#156
  def class_def?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#122
  def correct_next_line_if_denied_style(corrector, node, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#152
  def empty_lines_around?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#102
  def expected_empty_lines?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#178
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#187
  def message_for_around_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#197
  def message_for_only_before_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#174
  def next_empty_line_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#146
  def next_line_empty?(last_send_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#139
  def previous_line_empty?(send_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#135
  def previous_line_ignoring_comments(processed_source, send_line); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#48
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#52
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#49
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_AND_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#51
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#47
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#47
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#65
  def empty_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#71
  def extra_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#93
  def inner_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#84
  def line_numbers(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#97
  def outer_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#78
  def processed_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#61
  def receiver_and_method_call_on_different_lines?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_arguments.rb#45
RuboCop::Cop::Layout::EmptyLinesAroundArguments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#70
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#123
  def allow_alias?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#133
  def allow_alias_syntax?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#127
  def attribute_or_allowed_method?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#83
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#107
  def next_line_empty?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#94
  def next_line_empty_or_enable_directive_comment?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#101
  def next_line_enable_directive_comment?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#117
  def next_line_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#111
  def require_empty_line?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#68
RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#30
  def on_kwbegin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#36
  def style; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#28
RuboCop::Cop::Layout::EmptyLinesAroundBeginBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_block_body.rb#30
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_block_body.rb#30
  def on_numblock(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_block_body.rb#28
RuboCop::Cop::Layout::EmptyLinesAroundBlockBody::KIND = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#20
  def constant_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#23
  def empty_line_required?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#26
  def check(node, body, adjusted_first_line: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#81
  def check_beginning(style, first_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#67
  def check_both(style, first_line, last_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#108
  def check_deferred_empty_line(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#43
  def check_empty_lines_except_namespace(body, first_line, last_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#51
  def check_empty_lines_special(body, first_line, last_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#85
  def check_ending(style, last_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#98
  def check_line(style, line, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#89
  def check_source(style, line_no, desc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#159
  def deferred_message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#132
  def first_child_requires_empty_line?(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#140
  def first_empty_line_required_child(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#155
  def message(type, desc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#122
  def namespace?(body, with_one_child: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#148
  def previous_line_ignoring_comments(send_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#163
  def valid_body_style?(body); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#15
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_DEFERRED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#13
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_EXTRA = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/empty_lines_around_body.rb#14
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_MISSING = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_class_body.rb#73
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_class_body.rb#79
  def on_sclass(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_class_body.rb#71
RuboCop::Cop::Layout::EmptyLinesAroundClassBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#67
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#67
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#72
  def on_kwbegin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#79
  def check_body(body, line_of_def_or_kwbegin); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#106
  def keyword_locations(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#123
  def keyword_locations_in_ensure(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#119
  def keyword_locations_in_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#94
  def last_rescue_and_end_on_same_line(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#98
  def message(location, keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#102
  def style; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#65
RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_method_body.rb#29
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_method_body.rb#29
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_method_body.rb#36
  def style; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_method_body.rb#27
RuboCop::Cop::Layout::EmptyLinesAroundMethodBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_module_body.rb#53
  def on_module(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/empty_lines_around_module_body.rb#51
RuboCop::Cop::Layout::EmptyLinesAroundModuleBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#101
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#81
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#89
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#85
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#97
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#93
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#156
  def alignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#167
  def alignment_node_for_variable_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#137
  def asgn_variable_align_with(outer_node, inner_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#182
  def assignment_or_operator_method(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#111
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#126
  def check_asgn_alignment(outer_node, inner_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#115
  def check_assignment(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_alignment.rb#147
  def check_other_alignment(node); end
end

class RuboCop::Cop::Layout::EndOfLine < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_of_line.rb#71
  def offense_message(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_of_line.rb#47
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_of_line.rb#67
  def unimportant_missing_cr?(index, last_line, line); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/end_of_line.rb#85
  def last_line(processed_source); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/end_of_line.rb#44
RuboCop::Cop::Layout::EndOfLine::MSG_DETECTED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/end_of_line.rb#45
RuboCop::Cop::Layout::EndOfLine::MSG_MISSING = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ExtraSpacing < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#39
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#167
  def align_column(asgn_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#144
  def align_equal_sign(corrector, token, align_to); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#134
  def align_equal_signs(range, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#52
  def aligned_locations(locs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#104
  def aligned_tok?(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#156
  def all_relevant_assignment_lines(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#176
  def allow_for_trailing_comments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#73
  def check_assignment(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#82
  def check_other(token1, token2, ast); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#63
  def check_tokens(ast, token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#92
  def extra_space_range(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#130
  def force_equal_sign_alignment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#112
  def ignored_range?(ast, start_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#119
  def ignored_ranges(ast); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#37
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNALIGNED_ASGN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/extra_spacing.rb#36
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstArgumentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#216
  def eligible_method_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#155
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#155
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#275
  def argument_alignment_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#168
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#172
  def bare_operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#192
  def base_indentation(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#220
  def base_range(send_node, arg_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#232
  def column_of(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#253
  def comment_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#271
  def enable_layout_first_method_argument_line_break?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#265
  def enforce_first_argument_with_fixed_indentation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#176
  def message(arg_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#261
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#244
  def previous_code_line(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#200
  def special_inner_call_indentation?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_argument_indentation.rb#153
RuboCop::Cop::Layout::FirstArgumentIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstArrayElementIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#91
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#95
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#95
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#104
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#142
  def base_description(indent_base_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#108
  def brace_alignment_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#112
  def check(array_node, left_parenthesis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#126
  def check_right_bracket(right_bracket, first_elem, left_bracket, left_parenthesis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#155
  def message(base_description); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#163
  def message_for_right_bracket(indent_base_type); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_indentation.rb#88
RuboCop::Cop::Layout::FirstArrayElementIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstArrayElementLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_line_break.rb#26
  def on_array(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_line_break.rb#34
  def assignment_on_same_line?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_array_element_line_break.rb#24
RuboCop::Cop::Layout::FirstArrayElementLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstHashElementIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#126
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#122
  def on_hash(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#126
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#233
  def argument_alignment_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#137
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#191
  def base_description(indent_base_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#141
  def brace_alignment_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#145
  def check(hash_node, left_parenthesis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#184
  def check_based_on_longest_key(hash_node, left_brace, left_parenthesis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#164
  def check_right_brace(right_brace, first_pair, left_brace, left_parenthesis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#227
  def enforce_first_argument_with_fixed_indentation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#204
  def message(base_description); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#212
  def message_for_right_brace(indent_base_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#178
  def separator_style?(first_pair); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_indentation.rb#119
RuboCop::Cop::Layout::FirstHashElementIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstHashElementLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_line_break.rb#25
  def on_hash(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_hash_element_line_break.rb#23
RuboCop::Cop::Layout::FirstHashElementLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_argument_line_break.rb#29
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_argument_line_break.rb#29
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_argument_line_break.rb#29
  def on_super(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_argument_line_break.rb#27
RuboCop::Cop::Layout::FirstMethodArgumentLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_parameter_line_break.rb#35
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_parameter_line_break.rb#35
  def on_defs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_method_parameter_line_break.rb#33
RuboCop::Cop::Layout::FirstMethodParameterLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstParameterIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#53
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#53
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#63
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#83
  def base_description(_); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#67
  def brace_alignment_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#71
  def check(def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#91
  def message(base_description); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/first_parameter_indentation.rb#50
RuboCop::Cop::Layout::FirstParameterIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::HashAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#218
  def column_deltas; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#218
  def column_deltas=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#218
  def offenses_by; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#218
  def offenses_by=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#208
  def on_hash(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#195
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#195
  def on_super(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#195
  def on_yield(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#265
  def add_offenses; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#371
  def adjust(corrector, delta, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#300
  def alignment_for(pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#314
  def alignment_for_colons; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#310
  def alignment_for_hash_rockets; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#390
  def argument_alignment_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#233
  def argument_before_hash(hash_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#222
  def autocorrect_incompatible_with_other_cops?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#283
  def check_delta(delta, node:, alignment:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#246
  def check_pairs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#337
  def correct_key_value(corrector, delta, key, value, separator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#333
  def correct_no_value(corrector, key_delta, key); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#318
  def correct_node(corrector, node, delta); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#242
  def double_splat?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#384
  def enforce_first_argument_with_fixed_indentation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#380
  def good_alignment?(column_deltas); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#291
  def ignore_hash_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#353
  def new_alignment(key); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#273
  def register_offenses_with_format(offenses, format); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#237
  def reset!; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#183
RuboCop::Cop::Layout::HashAlignment::MESSAGES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/hash_alignment.rb#193
RuboCop::Cop::Layout::HashAlignment::SEPARATOR_ALIGNMENT_STYLES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#64
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#179
  def add_correct_closing_paren(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#265
  def add_correct_external_trailing_comma(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#108
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#217
  def exist_argument_between_heredoc_end_and_closing_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#283
  def external_trailing_comma?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#288
  def external_trailing_comma_offset_from_loc_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#138
  def extract_heredoc(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#134
  def extract_heredoc_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#224
  def find_most_bottom_of_heredoc_end(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#174
  def fix_closing_parenthesis(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#260
  def fix_external_trailing_comma(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#150
  def heredoc_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#192
  def incorrect_parenthesis_removal_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#208
  def incorrect_parenthesis_removal_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#238
  def internal_trailing_comma?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#243
  def internal_trailing_comma_offset_from_last_arg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#116
  def outermost_send_on_same_line(heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#183
  def remove_incorrect_closing_paren(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#271
  def remove_incorrect_external_trailing_comma(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#232
  def remove_internal_trailing_comma(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#202
  def safe_to_remove_line_containing_closing_paren?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#127
  def send_missing_closing_parens?(parent, child, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#154
  def single_line_send_with_heredoc_receiver?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#299
  def space?(pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#163
  def subsequent_closing_parentheses_in_same_line?(outermost_send); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#60
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#57
RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::HeredocIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#32
  def on_heredoc(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#116
  def adjust_minus(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#111
  def adjust_squiggly(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#140
  def base_indent_level(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#155
  def heredoc_body(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#159
  def heredoc_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#147
  def heredoc_indent_type(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#151
  def indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#122
  def indented_body(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#129
  def indented_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#87
  def line_too_long?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#99
  def longest_line(lines); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#107
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#65
  def message(heredoc_indent_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#53
  def register_offense(node, heredoc_indent_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#75
  def type_message(indentation_width, current_indent_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#103
  def unlimited_heredoc_length?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#83
  def width_message(indentation_width); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#28
RuboCop::Cop::Layout::HeredocIndentation::TYPE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/heredoc_indentation.rb#30
RuboCop::Cop::Layout::HeredocIndentation::WIDTH_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::IndentationConsistency < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#128
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#132
  def on_kwbegin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#138
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#145
  def bare_access_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#152
  def base_column_for_normal_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#172
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#187
  def check_indented_internal_methods_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#180
  def check_normal_style(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_consistency.rb#126
RuboCop::Cop::Layout::IndentationConsistency::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::IndentationStyle < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#42
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#55
  def autocorrect(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#79
  def autocorrect_lambda_for_spaces(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#74
  def autocorrect_lambda_for_tabs(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#63
  def find_offense(line, lineno); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#85
  def in_string_literal?(ranges, tabs_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#104
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#89
  def string_literal_ranges(ast); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_style.rb#40
RuboCop::Cop::Layout::IndentationStyle::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::IndentationWidth < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#57
  def access_modifier?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#81
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#138
  def on_case(case_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#146
  def on_case_match(case_match); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#95
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#104
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#121
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#121
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#66
  def on_ensure(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#66
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#156
  def on_if(node, base = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#73
  def on_kwbegin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#95
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#81
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#66
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#61
  def on_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#95
  def on_sclass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#104
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#128
  def on_until(node, base = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#128
  def on_while(node, base = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#227
  def access_modifier_indentation_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#165
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#235
  def check_assignment(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#255
  def check_if(node, body, else_clause, base_loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#268
  def check_indentation(base_loc, body_node, style = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#169
  def check_members(base, members); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#193
  def check_members_for_indented_internal_methods_style(members); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#199
  def check_members_for_normal_style(base, members); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#341
  def check_rescue?(rescue_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#377
  def configured_indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#207
  def each_member(members); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#231
  def indentation_consistency_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#323
  def indentation_to_check?(base_loc, body_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#219
  def indented_internal_methods_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#381
  def leftmost_modifier_of(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#302
  def message(configured_indentation_width, indentation, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#360
  def offending_range(body_node, indentation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#278
  def offense(body_node, indentation, style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#313
  def other_offense_in_same_range?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#181
  def select_check_member(member); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#345
  def skip_check?(base_loc, body_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#223
  def special_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#368
  def starts_with_access_modifier?(body_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/indentation_width.rb#53
RuboCop::Cop::Layout::IndentationWidth::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::InitialIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/initial_indentation.rb#26
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/initial_indentation.rb#36
  def first_token; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/initial_indentation.rb#40
  def space_before(token); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/initial_indentation.rb#24
RuboCop::Cop::Layout::InitialIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::LeadingCommentSpace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#58
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#95
  def allow_doxygen_comment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#103
  def allow_gemfile_ruby_comment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#79
  def allowed_on_first_line?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#99
  def doxygen_comment_style?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#107
  def gemfile?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#115
  def gemfile_ruby_comment?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#75
  def hash_mark(expr); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#91
  def rackup_config_file?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#87
  def rackup_options?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#111
  def ruby_comment_in_gemfile?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#83
  def shebang?(comment); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_comment_space.rb#56
RuboCop::Cop::Layout::LeadingCommentSpace::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::LeadingEmptyLines < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_empty_lines.rb#35
  def on_new_investigation; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/leading_empty_lines.rb#33
RuboCop::Cop::Layout::LeadingEmptyLines::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::LineContinuationLeadingSpace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#46
  def on_dstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#82
  def continuation?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#106
  def enforced_style_leading?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#68
  def investigate_leading_style(first_line, end_of_first_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#75
  def investigate_trailing_style(second_line, end_of_first_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#86
  def leading_offense_range(end_of_first_line, matches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#98
  def message(_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#64
  def raw_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_leading_space.rb#92
  def trailing_offense_range(end_of_first_line, matches); end
end

class RuboCop::Cop::Layout::LineContinuationSpacing < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#34
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#82
  def autocorrect(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#106
  def comment_ranges(comments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#66
  def find_offensive_spacing(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#116
  def ignore_range?(backtick_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#50
  def investigate(line, line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#110
  def last_line(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#74
  def message(_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#120
  def no_space_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#124
  def space_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_continuation_spacing.rb#91
  def string_literal_ranges(ast); end
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#95
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#83
  def on_dstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#135
  def add_offense_and_correction(node, message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#107
  def always_indented?(dstr_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#126
  def base_column(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#111
  def check_aligned(children, start_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#120
  def check_indented(children); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#101
  def strings_concatenated_with_backslash?(dstr_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#79
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#80
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#81
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::PARENT_TYPES_FOR_INDENTED = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::LineLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#80
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#74
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#80
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#80
  def on_hash(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#92
  def on_investigation_end; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#88
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#74
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#80
  def on_potential_breakable_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#80
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#217
  def allow_heredoc?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#221
  def allowed_heredoc; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#181
  def allowed_line?(line, line_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#133
  def breakable_block_range(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#100
  def breakable_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#100
  def breakable_range=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#141
  def breakable_range_after_semicolon(semicolon_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#154
  def breakable_range_by_line_index; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#248
  def check_directive_line(line, line_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#123
  def check_for_breakable_block(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#102
  def check_for_breakable_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#115
  def check_for_breakable_semicolons(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#169
  def check_line(line, line_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#265
  def check_uri_line(line, line_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#202
  def excess_range(uri_range, line, line_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#225
  def extract_heredocs(ast); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#158
  def heredocs; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#162
  def highlight_start(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#244
  def line_in_heredoc?(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#235
  def line_in_permitted_heredoc?(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#213
  def max; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#191
  def register_offense(loc, line, line_index, length: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#187
  def shebang?(line, line_index); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/line_length.rb#72
RuboCop::Cop::Layout::LineLength::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineArrayBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_brace_layout.rb#109
  def on_array(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_brace_layout.rb#103
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_brace_layout.rb#99
RuboCop::Cop::Layout::MultilineArrayBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_brace_layout.rb#95
RuboCop::Cop::Layout::MultilineArrayBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineArrayLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_line_breaks.rb#29
  def on_array(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_array_line_breaks.rb#27
RuboCop::Cop::Layout::MultilineArrayLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineAssignmentLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#72
  def check_assignment(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#81
  def check_by_enforced_style(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#90
  def check_new_line_offense(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#98
  def check_same_line_offense(node, rhs); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#111
  def supported_types; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#66
RuboCop::Cop::Layout::MultilineAssignmentLayout::NEW_LINE_OFFENSE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_assignment_layout.rb#69
RuboCop::Cop::Layout::MultilineAssignmentLayout::SAME_LINE_OFFENSE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineBlockLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#59
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#59
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#98
  def add_offense_for_expression(node, expr, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#75
  def args_on_beginning_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#105
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#120
  def autocorrect_arguments(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#130
  def autocorrect_body(corrector, node, block_body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#142
  def block_arg_string(node, args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#90
  def characters_needed_for_space_and_pipes(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#154
  def include_trailing_comma?(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#79
  def line_break_necessary_in_args?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#83
  def needed_length_for_args(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#56
RuboCop::Cop::Layout::MultilineBlockLayout::ARG_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#55
RuboCop::Cop::Layout::MultilineBlockLayout::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_block_layout.rb#57
RuboCop::Cop::Layout::MultilineBlockLayout::PIPE_SIZE = T.let(T.unsafe(nil), Integer)

class RuboCop::Cop::Layout::MultilineHashBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#109
  def on_hash(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#103
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#99
RuboCop::Cop::Layout::MultilineHashBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#95
RuboCop::Cop::Layout::MultilineHashBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#29
  def on_hash(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#40
  def starts_with_curly_brace?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#27
RuboCop::Cop::Layout::MultilineHashKeyLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#34
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#32
RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#109
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#115
  def children(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#119
  def ignored_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#123
  def single_line_ignoring_receiver?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#103
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#99
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#95
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodCallIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#55
  def validate_config; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#136
  def align_with_base_message(rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#152
  def alignment_base(node, rhs, given_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#67
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#140
  def base_source; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#101
  def extra_indentation(given_style, parent); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#222
  def first_call_has_a_dot(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#213
  def get_dot_right_above(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#113
  def message(node, lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#144
  def no_base_message(lhs, rhs, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#87
  def offending_range(node, lhs, rhs, given_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#232
  def operation_rhs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#242
  def operator_rhs?(node, receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#193
  def receiver_alignment_base(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#131
  def relative_to_receiver_message(rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#71
  def relevant_node?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#75
  def right_hand_side(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#181
  def semantic_alignment_base(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#201
  def semantic_alignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#127
  def should_align_with_base?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#123
  def should_indent_relative_to_receiver?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_call_indentation.rb#163
  def syntactic_alignment_base(lhs, rhs); end
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#121
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#121
  def on_defs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#115
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#118
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#111
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#107
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#37
  def on_def(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#35
RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineOperationIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#49
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#53
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#57
  def validate_config; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#68
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#78
  def check_and_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#110
  def message(node, lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#84
  def offending_range(node, lhs, rhs, given_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#72
  def relevant_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#121
  def right_hand_side(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/multiline_operation_indentation.rb#97
  def should_align?(node, rhs, given_style); end
end

class RuboCop::Cop::Layout::ParameterAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#81
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#81
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#90
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#102
  def base_column(node, args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#98
  def fixed_indentation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#94
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#113
  def target_method_lineno(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#75
RuboCop::Cop::Layout::ParameterAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/parameter_alignment.rb#78
RuboCop::Cop::Layout::ParameterAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::RedundantLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#51
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#64
  def check_assignment(node, _rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#113
  def comment_within?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#83
  def configured_to_not_be_inspected?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#107
  def convertible_block?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#133
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#77
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#90
  def other_cop_takes_precedence?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#70
  def register_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#96
  def single_line_block_chain_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#100
  def suitable_as_single_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#124
  def to_single_line(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#119
  def too_long?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/redundant_line_break.rb#49
RuboCop::Cop::Layout::RedundantLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::RescueEnsureAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#40
  def on_ensure(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#44
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#36
  def on_resbody(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#186
  def access_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#163
  def access_modifier_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#149
  def aligned_with_leading_dot?(do_keyword_line, send_node_loc, rescue_keyword_column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#136
  def aligned_with_line_break_method?(ancestor_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#195
  def alignment_location(alignment_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#116
  def alignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#95
  def alignment_source(node, starting_loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#132
  def ancestor_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#155
  def assignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#73
  def autocorrect(corrector, node, alignment_location); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#203
  def begin_end_alignment_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#57
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#83
  def format_message(alignment_node, alignment_loc, kw_loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#173
  def modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#179
  def whitespace_range(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#34
RuboCop::Cop::Layout::RescueEnsureAlignment::ALTERNATIVE_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#32
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#33
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/rescue_ensure_alignment.rb#29
RuboCop::Cop::Layout::RescueEnsureAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SingleLineBlockChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/single_line_block_chain.rb#28
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/single_line_block_chain.rb#51
  def call_method_after_block?(node, dot_range, closing_block_delimiter_line_num); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/single_line_block_chain.rb#35
  def offending_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/single_line_block_chain.rb#57
  def selector_range(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/single_line_block_chain.rb#26
RuboCop::Cop::Layout::SingleLineBlockChain::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAfterColon < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_colon.rb#29
  def on_kwoptarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_colon.rb#21
  def on_pair(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_colon.rb#43
  def followed_by_space?(colon); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_colon.rb#39
  def register_offense(colon); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_colon.rb#19
RuboCop::Cop::Layout::SpaceAfterColon::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAfterComma < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SpaceAfterPunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_comma.rb#26
  def kind(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_comma.rb#21
  def space_style_before_rcurly; end
end

class RuboCop::Cop::Layout::SpaceAfterMethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_method_name.rb#23
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_method_name.rb#23
  def on_defs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_method_name.rb#21
RuboCop::Cop::Layout::SpaceAfterMethodName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAfterNot < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_not.rb#21
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_not.rb#33
  def whitespace_after_operator?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_not.rb#18
RuboCop::Cop::Layout::SpaceAfterNot::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_not.rb#19
RuboCop::Cop::Layout::SpaceAfterNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceAfterSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SpaceAfterPunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_semicolon.rb#23
  def kind(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_after_semicolon.rb#18
  def space_style_before_rcurly; end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#32
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#65
  def check_after_closing_pipe(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#125
  def check_arg(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#103
  def check_closing_pipe_space(arguments, closing_pipe); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#121
  def check_each_arg(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#56
  def check_inside_pipes(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#150
  def check_no_space(space_begin_pos, space_end_pos, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#73
  def check_no_space_style_inside_pipes(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#92
  def check_opening_pipe_space(arguments, opening_pipe); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#136
  def check_space(space_begin_pos, space_end_pos, range, msg, node = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#85
  def check_space_style_inside_pipes(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#113
  def last_end_pos_inside_pipes(arguments, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#44
  def pipes(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#48
  def pipes?(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_block_parameters.rb#52
  def style_parameter_name; end
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#38
  def on_optarg(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#67
  def autocorrect(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#46
  def check_optarg(arg, equals, value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#58
  def incorrect_style_detected(arg, value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#83
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#79
  def no_surrounding_space?(arg, equals); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#75
  def space_on_both_sides?(arg, equals); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#36
RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAroundKeyword < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#40
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#44
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#48
  def on_break(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#52
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#56
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#156
  def on_defined?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#60
  def on_ensure(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#64
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#68
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#72
  def on_if_guard(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#76
  def on_in_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#80
  def on_kwbegin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#85
  def on_match_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#92
  def on_match_pattern_p(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#96
  def on_next(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#100
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#104
  def on_postexe(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#108
  def on_preexe(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#112
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#116
  def on_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#120
  def on_return(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#124
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#128
  def on_super(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#136
  def on_unless_guard(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#140
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#144
  def on_when(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#148
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#152
  def on_yield(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#132
  def on_zsuper(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#235
  def accept_left_parenthesis?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#239
  def accept_left_square_bracket?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#243
  def accept_namespace_operator?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#228
  def accepted_opening_delimiter?(range, char); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#162
  def check(node, locations, begin_keyword = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#177
  def check_begin(node, range, begin_keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#183
  def check_end(node, range, begin_keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#196
  def check_keyword(node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#192
  def do?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#251
  def namespace_operator?(range, pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#255
  def preceded_by_operator?(node, _range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#247
  def safe_navigation_call?(range, pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#217
  def space_after_missing?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#210
  def space_before_missing?(range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#36
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_PAREN = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#37
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#38
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#33
RuboCop::Cop::Layout::SpaceAroundKeyword::DO = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#31
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#30
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_BEFORE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#35
RuboCop::Cop::Layout::SpaceAroundKeyword::NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_keyword.rb#34
RuboCop::Cop::Layout::SpaceAroundKeyword::SAFE_NAVIGATION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#53
  def on_const(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#45
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#45
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#87
  def check_space(begin_pos, end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#67
  def check_space_after_dot(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#81
  def check_space_after_double_colon(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#61
  def check_space_before_dot(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#43
RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_method_call_operator.rb#41
RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Layout::SpaceAroundOperators < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_and_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_assignment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_binary(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#111
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#78
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_masgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#135
  def on_match_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#127
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_or_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#70
  def on_pair(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#85
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#66
  def on_sclass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#93
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#127
  def on_special_asgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#236
  def align_hash_cop_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#179
  def autocorrect(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#163
  def check_operator(type, operator, right_operand); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#189
  def enclose_operator_with_space(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#216
  def excess_leading_space?(type, operator, with_space); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#231
  def excess_trailing_space?(right_operand, with_space); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#248
  def force_equal_sign_alignment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#240
  def hash_table_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#174
  def offense(type, operator, with_space, right_operand); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#202
  def offense_message(type, operator, with_space, right_operand); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#159
  def operator_with_regular_syntax?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#155
  def regular_operator?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#252
  def should_not_have_surrounding_space?(operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#244
  def space_around_exponent_operator?; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#62
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#60
RuboCop::Cop::Layout::SpaceAroundOperators::EXCESSIVE_SPACE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_around_operators.rb#59
RuboCop::Cop::Layout::SpaceAroundOperators::IRREGULAR_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#56
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#56
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#124
  def autocorrect(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#144
  def block_delimiters_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#83
  def check_empty(left_brace, space_plus_brace, used_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#100
  def check_non_empty(left_brace, space_plus_brace, used_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#140
  def conflict_with_block_delimiters?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#148
  def empty_braces?(loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#115
  def space_detected(left_brace, space_plus_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#108
  def space_missing(left_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#131
  def style_for_empty_braces; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#52
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#50
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::DETECTED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_block_braces.rb#49
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::MISSING_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceBeforeBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#24
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#48
  def dot_before_brackets?(node, receiver_end_pos, selector_begin_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#35
  def offense_range(node, begin_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#54
  def offense_range_for_assignment(node, begin_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#67
  def reference_variable_with_brackets?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#63
  def register_offense(range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#21
RuboCop::Cop::Layout::SpaceBeforeBrackets::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_brackets.rb#22
RuboCop::Cop::Layout::SpaceBeforeBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceBeforeComma < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_comma.rb#23
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_comment.rb#20
  def on_new_investigation; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_comment.rb#18
RuboCop::Cop::Layout::SpaceBeforeComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceBeforeFirstArg < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#35
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#35
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#54
  def expect_params_after_method_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#64
  def no_space_between_method_name_and_first_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#50
  def regular_method_call_with_arguments?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#31
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_first_arg.rb#29
RuboCop::Cop::Layout::SpaceBeforeFirstArg::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceBeforeSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_before_semicolon.rb#18
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#30
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#50
  def arrow_lambda_with_args?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#72
  def lambda_arguments(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#65
  def range_of_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#58
  def space_after_arrow(lambda_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#54
  def space_after_arrow?(lambda_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#28
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_NO_SPACE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_in_lambda_literal.rb#27
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_SPACE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#78
  def on_array(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#106
  def array_brackets(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#92
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#215
  def compact(corrector, bracket, side); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#202
  def compact_corrections(corrector, node, left, right); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#194
  def compact_offense(node, token, side: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#157
  def compact_offenses(node, left, right, start_ok, end_ok); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#118
  def empty_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#126
  def end_has_own_line?(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#133
  def index_for(node, token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#141
  def issue_offenses(node, left, right, start_ok, end_ok); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#110
  def left_array_bracket(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#137
  def line_and_column_for(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#179
  def multi_dimensional_array?(node, token, side: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#188
  def next_to_bracket?(token, side: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#153
  def next_to_comment?(node, token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#122
  def next_to_newline?(node, token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#170
  def qualifies_for_compact?(node, token, side: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#114
  def right_array_bracket(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#76
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#75
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#23
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#27
  def on_percent_literal(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#37
  def each_unnecessary_space_match(node, &blk); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#20
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#21
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Layout::SpaceInsideBlockBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#85
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#85
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#122
  def adjacent_braces(left_brace, right_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#161
  def aligned_braces?(inner, right_brace, column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#130
  def braces_with_contents_inside(node, inner); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#105
  def check_inside(node, left_brace, right_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#137
  def check_left_brace(inner, left_brace, args_delimiter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#145
  def check_right_brace(node, inner, left_brace, right_brace, single_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#165
  def inner_last_space_count(inner); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#157
  def multiline_block?(left_brace, right_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#222
  def no_space(begin_pos, end_pos, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#169
  def no_space_inside_left_brace(left_brace, args_delimiter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#238
  def offense(begin_pos, end_pos, msg, style_param = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#201
  def pipe?(args_delimiter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#230
  def space(begin_pos, end_pos, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#186
  def space_inside_left_brace(left_brace, args_delimiter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#205
  def space_inside_right_brace(inner, right_brace, column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_block_braces.rb#251
  def style_for_empty_braces; end
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#74
  def on_hash(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#132
  def ambiguous_or_unexpected_style_detected(style, is_match); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#124
  def autocorrect(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#84
  def check(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#99
  def expect_space?(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#112
  def incorrect_style_detected(token1, token2, expect_space, is_empty_braces); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#145
  def message(brace, is_empty_braces, expect_space); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#140
  def offense?(token1, expect_space); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#171
  def range_of_space_to_the_left(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#163
  def range_of_space_to_the_right(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#155
  def space_range(token_range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#72
RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideParens < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#66
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#161
  def can_be_ignored?(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#115
  def correct_extaneus_space_between_consecutive_parens(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#99
  def correct_extraneous_space(tokens); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#124
  def correct_extraneous_space_in_empty_parens(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#135
  def correct_missing_space(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#153
  def left_parens?(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#149
  def parens?(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#88
  def process_with_compact_style(tokens); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#81
  def process_with_space_style(tokens); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#157
  def right_parens?(token1, token2); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#63
RuboCop::Cop::Layout::SpaceInsideParens::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_parens.rb#64
RuboCop::Cop::Layout::SpaceInsideParens::MSG_SPACE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#28
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#36
  def on_percent_literal(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#32
  def on_xstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#42
  def add_offenses_for_unnecessary_spaces(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#52
  def regex_matches(node, &blk); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#25
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::BEGIN_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#26
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::END_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#24
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_range_literal.rb#29
  def on_erange(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_range_literal.rb#25
  def on_irange(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_range_literal.rb#35
  def check(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_range_literal.rb#23
RuboCop::Cop::Layout::SpaceInsideRangeLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#66
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#88
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#117
  def closing_bracket(tokens, opening_bracket); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#133
  def empty_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#106
  def left_ref_bracket(node, tokens); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#128
  def previous_token(current_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#100
  def reference_brackets(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#62
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#61
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_reference_brackets.rb#64
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_string_interpolation.rb#31
  def on_interpolation(begin_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_string_interpolation.rb#46
  def autocorrect(corrector, begin_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_string_interpolation.rb#56
  def delimiters(begin_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_string_interpolation.rb#28
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::NO_SPACE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/layout/space_inside_string_interpolation.rb#29
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::SPACE_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::TrailingEmptyLines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_empty_lines.rb#45
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_empty_lines.rb#79
  def ends_in_end?(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_empty_lines.rb#89
  def message(wanted_blank_lines, blank_lines); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_empty_lines.rb#66
  def offense_detected(buffer, wanted_blank_lines, blank_lines, whitespace_at_end); end
end

class RuboCop::Cop::Layout::TrailingWhitespace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#58
  def on_heredoc(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#49
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#109
  def extract_heredocs(ast); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#104
  def find_heredoc(line_number); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#118
  def offense_range(lineno, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#62
  def process_line(line, lineno); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#76
  def process_line_in_heredoc(corrector, range, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#100
  def skip_heredoc?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#96
  def static?(heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#87
  def whitespace_is_indentation?(range, level); end

  # source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#91
  def whitespace_only?(range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/layout/trailing_whitespace.rb#47
RuboCop::Cop::Layout::TrailingWhitespace::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Legacy; end

class RuboCop::Cop::Legacy::CorrectionsProxy
  # source://rubocop/1.36.0/lib/rubocop/cop/legacy/corrections_proxy.rb#9
  def initialize(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/legacy/corrections_proxy.rb#13
  def <<(callable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/legacy/corrections_proxy.rb#21
  def concat(corrections); end

  # source://rubocop/1.36.0/lib/rubocop/cop/legacy/corrections_proxy.rb#17
  def empty?; end

  protected

  # source://rubocop/1.36.0/lib/rubocop/cop/legacy/corrections_proxy.rb#31
  def corrector; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/legacy/corrections_proxy.rb#35
  def suppress_clobbering; end
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#27
    def break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#15
    def correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#35
    def move_comment(eol_comment:, node:, corrector:); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#13
    def processed_source; end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#45
    def remove_semicolon(node, corrector); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#51
    def semicolon(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/line_break_corrector.rb#58
    def trailing_class_definition?(token, body); end
  end
end

module RuboCop::Cop::LineLengthHelp
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#22
  def allow_uri?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#26
  def allowed_uri_position?(line, uri_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#13
  def directive_on_source_line?(line_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#63
  def extend_uri_end_position(line, end_position); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#34
  def find_excessive_uri_range(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#9
  def ignore_cop_directives?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#57
  def indentation_difference(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#30
  def line_length(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#96
  def line_length_without_directive(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#49
  def match_uris(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#79
  def tab_indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#84
  def uri_regexp; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/line_length_help.rb#89
  def valid_uri?(uri_ish_string); end
end

module RuboCop::Cop::Lint; end

class RuboCop::Cop::Lint::AmbiguousAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_lvasgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#44
  def rhs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#28
RuboCop::Cop::Lint::AmbiguousAssignment::MISTAKES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#24
RuboCop::Cop::Lint::AmbiguousAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_assignment.rb#26
RuboCop::Cop::Lint::AmbiguousAssignment::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::AmbiguousBlockAssociation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_block_association.rb#62
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_block_association.rb#62
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_block_association.rb#81
  def allowed_method_pattern?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_block_association.rb#77
  def ambiguous_block_association?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_block_association.rb#87
  def message(send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_block_association.rb#58
RuboCop::Cop::Lint::AmbiguousBlockAssociation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AmbiguousOperator < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#41
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#60
  def find_offense_node_by(diagnostic); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#78
  def message(diagnostic); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#88
  def offense_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#84
  def offense_position?(node, diagnostic); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#97
  def unary_operator?(node, diagnostic); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#26
RuboCop::Cop::Lint::AmbiguousOperator::AMBIGUITIES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator.rb#36
RuboCop::Cop::Lint::AmbiguousOperator::MSG_FORMAT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#54
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#47
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#65
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#105
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#89
  def greater_precedence?(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#85
  def operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#97
  def operator_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#79
  def precedence(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#45
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#34
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::PRECEDENCE = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#44
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::AmbiguousRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#64
  def on_erange(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#64
  def on_irange(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#82
  def acceptable?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#89
  def acceptable_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#77
  def each_boundary(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#99
  def require_parentheses_for_method_chain?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_range.rb#62
RuboCop::Cop::Lint::AmbiguousRange::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#31
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#56
  def find_offense_node(node, regexp_receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#49
  def find_offense_node_by(diagnostic); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#67
  def first_argument_is_regexp?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#71
  def method_chain_to_regexp_receiver?(node, regexp_receiver); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#27
RuboCop::Cop::Lint::AmbiguousRegexpLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AssignmentInCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#49
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#49
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#49
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#72
  def allowed_construct?(asgn_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#76
  def conditional_assignment?(asgn_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#64
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#80
  def skip_children?(asgn_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#86
  def traverse_node(node, &block); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#47
RuboCop::Cop::Lint::AssignmentInCondition::ASGN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#44
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/assignment_in_condition.rb#40
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::BigDecimalNew < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/big_decimal_new.rb#25
  def big_decimal_new(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/big_decimal_new.rb#30
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/big_decimal_new.rb#20
RuboCop::Cop::Lint::BigDecimalNew::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/big_decimal_new.rb#22
RuboCop::Cop::Lint::BigDecimalNew::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#61
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#61
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#52
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#50
RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::ALLOWED_MATH_OPERATORS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#49
RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::BooleanSymbol < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/boolean_symbol.rb#35
  def boolean_symbol?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/boolean_symbol.rb#37
  def on_sym(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/boolean_symbol.rb#50
  def autocorrect(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/boolean_symbol.rb#32
RuboCop::Cop::Lint::BooleanSymbol::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::CircularArgumentReference < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/circular_argument_reference.rb#53
  def on_kwoptarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/circular_argument_reference.rb#57
  def on_optarg(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/circular_argument_reference.rb#63
  def check_for_circular_argument_references(arg_name, arg_value); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/circular_argument_reference.rb#51
RuboCop::Cop::Lint::CircularArgumentReference::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ConstantDefinitionInBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#70
  def constant_assigned_in_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#75
  def module_defined_in_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#79
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#85
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#85
  def on_module(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#94
  def method_name(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_definition_in_block.rb#67
RuboCop::Cop::Lint::ConstantDefinitionInBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ConstantOverwrittenInRescue < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#41
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#33
  def overwritten_constant(param0 = T.unsafe(nil)); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#37
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#30
RuboCop::Cop::Lint::ConstantOverwrittenInRescue::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ConstantResolution < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_resolution.rb#66
  def on_const(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_resolution.rb#62
  def unqualified_const?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_resolution.rb#79
  def allowed_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_resolution.rb#74
  def const_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_resolution.rb#83
  def ignored_names; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/constant_resolution.rb#59
RuboCop::Cop::Lint::ConstantResolution::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::Debugger < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/debugger.rb#70
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/debugger.rb#98
  def debugger_method?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/debugger.rb#82
  def debugger_methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/debugger.rb#78
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/debugger.rb#110
  def receiver_chain(send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/debugger.rb#68
RuboCop::Cop::Lint::Debugger::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DeprecatedClassMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#132
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#153
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#162
  def replacement(deprecated); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#129
RuboCop::Cop::Lint::DeprecatedClassMethods::CLASS_METHOD_DELIMITER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#102
RuboCop::Cop::Lint::DeprecatedClassMethods::DEPRECATED_METHODS_OBJECT = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#40
  def initialize(method, class_constant: T.unsafe(nil), correctable: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#38
  def class_constant; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#46
  def class_nodes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#58
  def correctable?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#38
  def method; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#62
  def to_s; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#68
  def delimiter; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#130
RuboCop::Cop::Lint::DeprecatedClassMethods::INSTANCE_METHOD_DELIMITER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#100
RuboCop::Cop::Lint::DeprecatedClassMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#127
RuboCop::Cop::Lint::DeprecatedClassMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::DeprecatedClassMethods::Replacement
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#79
  def initialize(method, class_constant: T.unsafe(nil), instance_method: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#77
  def class_constant; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#77
  def method; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#85
  def to_s; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#91
  def delimiter; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_class_methods.rb#95
  def instance_method?; end
end

class RuboCop::Cop::Lint::DeprecatedConstants < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_constants.rb#39
  def on_const(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_constants.rb#59
  def constant_name(node, nested_constant_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_constants.rb#75
  def deprecated_constants; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_constants.rb#65
  def message(good, bad, deprecated_version); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_constants.rb#37
RuboCop::Cop::Lint::DeprecatedConstants::DO_NOT_USE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_constants.rb#36
RuboCop::Cop::Lint::DeprecatedConstants::SUGGEST_GOOD_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#49
  def algorithm_const(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#59
  def digest_const?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#63
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#110
  def algorithm_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#75
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#139
  def build_cipher_arguments(node, algorithm_name, no_arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#102
  def correction_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#87
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#106
  def openssl_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#128
  def replacement_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#120
  def sanitize_arguments(arguments); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#44
RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#46
RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::NO_ARG_ALGORITHM = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#53
  def on_def(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#60
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#66
  def check_body(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#78
  def check_body_lines(lines); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#99
  def check_disjunctive_assignment(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#51
RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateBranch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#91
  def on_branching_statement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#91
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#91
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#91
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#91
  def on_rescue(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#119
  def branches(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#123
  def consider_branch?(branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#149
  def const_branch?(branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#134
  def ignore_constant_branches?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#130
  def ignore_literal_branches?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#138
  def literal_branch?(branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#105
  def offense_range(duplicate_branch); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_branch.rb#89
RuboCop::Cop::Lint::DuplicateBranch::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateCaseCondition < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_case_condition.rb#33
  def on_case(case_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_case_condition.rb#31
RuboCop::Cop::Lint::DuplicateCaseCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateElsifCondition < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_elsif_condition.rb#26
  def on_if(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_elsif_condition.rb#24
RuboCop::Cop::Lint::DuplicateElsifCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateHashKey < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Duplication

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_hash_key.rb#26
  def on_hash(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_hash_key.rb#24
RuboCop::Cop::Lint::DuplicateHashKey::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateMethods < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#57
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#97
  def alias_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#84
  def method_alias?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#88
  def on_alias(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#62
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#71
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#103
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#102
  def sym_name(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#116
  def check_const_receiver(node, name, const_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#123
  def check_self_receiver(node, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#178
  def found_attr(node, args, readable: T.unsafe(nil), writable: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#135
  def found_instance_method(node, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#148
  def found_method(node, method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#188
  def lookup_constant(node, const_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#130
  def message_for_dup(node, method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#164
  def on_attr(node, attr_name, args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#220
  def possible_dsl?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#206
  def qualified_name(enclosing, namespace, mod_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#230
  def source_location(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#53
RuboCop::Cop::Lint::DuplicateMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_methods.rb#55
RuboCop::Cop::Lint::DuplicateMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#35
  def each_repeated_character_class_element_loc(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#27
  def on_regexp(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#64
  def interpolation_locs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#58
  def within_interpolation?(node, child); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#25
RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement::MSG_REPEATED_ELEMENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateRequire < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_require.rb#39
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_require.rb#45
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_require.rb#35
  def require_call?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_require.rb#30
RuboCop::Cop::Lint::DuplicateRequire::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_require.rb#31
RuboCop::Cop::Lint::DuplicateRequire::REQUIRE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_require.rb#32
RuboCop::Cop::Lint::DuplicateRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Lint::DuplicateRescueException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_rescue_exception.rb#33
  def on_rescue(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/duplicate_rescue_exception.rb#31
RuboCop::Cop::Lint::DuplicateRescueException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EachWithObjectArgument < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/each_with_object_argument.rb#29
  def each_with_object?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/each_with_object_argument.rb#33
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/each_with_object_argument.rb#33
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/each_with_object_argument.rb#25
RuboCop::Cop::Lint::EachWithObjectArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/each_with_object_argument.rb#26
RuboCop::Cop::Lint::EachWithObjectArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ElseLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/else_layout.rb#49
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/else_layout.rb#80
  def autocorrect(corrector, node, first_else); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/else_layout.rb#60
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/else_layout.rb#70
  def check_else(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/else_layout.rb#88
  def indentation_width; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/else_layout.rb#47
RuboCop::Cop::Lint::ElseLayout::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyBlock < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_block.rb#66
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_block.rb#76
  def allow_comment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_block.rb#83
  def allow_empty_lambdas?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_block.rb#87
  def comment_disables_cop?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_block.rb#92
  def lambda_or_proc?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_block.rb#64
RuboCop::Cop::Lint::EmptyBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyClass < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_class.rb#76
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_class.rb#81
  def on_sclass(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_class.rb#87
  def body_or_allowed_comment_lines?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_class.rb#73
RuboCop::Cop::Lint::EmptyClass::CLASS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_class.rb#74
RuboCop::Cop::Lint::EmptyClass::METACLASS_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyConditionalBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#70
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#142
  def all_branches_body_missing?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#81
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#130
  def branch_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#98
  def correct_other_branches(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#148
  def deletion_range(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#125
  def empty_else_branch?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#117
  def empty_if_branch?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#87
  def remove_comments(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#94
  def remove_empty_branch(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#110
  def require_other_branches_correction?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_conditional_body.rb#68
RuboCop::Cop::Lint::EmptyConditionalBody::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyEnsure < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_ensure.rb#50
  def on_ensure(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_ensure.rb#48
RuboCop::Cop::Lint::EmptyEnsure::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyExpression < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_expression.rb#28
  def on_begin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_expression.rb#36
  def empty_expression?(begin_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_expression.rb#26
RuboCop::Cop::Lint::EmptyExpression::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyFile < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_file.rb#28
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_file.rb#42
  def contains_only_comments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_file.rb#38
  def empty_file?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_file.rb#34
  def offending?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_file.rb#26
RuboCop::Cop::Lint::EmptyFile::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyInPattern < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_in_pattern.rb#53
  def on_case_match(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_in_pattern.rb#49
RuboCop::Cop::Lint::EmptyInPattern::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_interpolation.rb#25
  def on_interpolation(begin_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_interpolation.rb#23
RuboCop::Cop::Lint::EmptyInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyWhen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_when.rb#52
  def on_case(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/empty_when.rb#50
RuboCop::Cop::Lint::EmptyWhen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EnsureReturn < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ensure_return.rb#53
  def on_ensure(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ensure_return.rb#51
RuboCop::Cop::Lint::EnsureReturn::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ErbNewArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#84
  def erb_new_with_non_keyword_arguments(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#89
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#154
  def arguments_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#109
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#124
  def build_kwargs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#120
  def correct_arguments?(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#141
  def override_by_legacy_args(kwargs, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#69
RuboCop::Cop::Lint::ErbNewArguments::MESSAGES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/erb_new_arguments.rb#81
RuboCop::Cop::Lint::ErbNewArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::FlipFlop < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/flip_flop.rb#32
  def on_eflipflop(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/flip_flop.rb#28
  def on_iflipflop(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/flip_flop.rb#26
RuboCop::Cop::Lint::FlipFlop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::FloatComparison < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#40
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#79
  def check_numeric_returning_method(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#63
  def check_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#47
  def float?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#34
RuboCop::Cop::Lint::FloatComparison::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#36
RuboCop::Cop::Lint::FloatComparison::FLOAT_INSTANCE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#35
RuboCop::Cop::Lint::FloatComparison::FLOAT_RETURNING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#32
RuboCop::Cop::Lint::FloatComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/float_comparison.rb#38
RuboCop::Cop::Lint::FloatComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::FloatOutOfRange < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/float_out_of_range.rb#24
  def on_float(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/float_out_of_range.rb#22
RuboCop::Cop::Lint::FloatOutOfRange::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::FormatParameterMismatch < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#96
  def called_on_string?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#49
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#133
  def count_format_matches(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#115
  def count_matches(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#137
  def count_percent_matches(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#125
  def countable_format?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#129
  def countable_percent?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#149
  def expected_fields_count(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#164
  def format?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#142
  def format_method?(name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#64
  def format_string?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#111
  def heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#68
  def invalid_format_string?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#87
  def matched_arguments_count?(expected, passed); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#183
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#101
  def method_with_format_args?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#77
  def offending_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#172
  def percent?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#105
  def splat_args?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#168
  def sprintf?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#44
RuboCop::Cop::Lint::FormatParameterMismatch::KERNEL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#39
RuboCop::Cop::Lint::FormatParameterMismatch::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#41
RuboCop::Cop::Lint::FormatParameterMismatch::MSG_INVALID = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#47
RuboCop::Cop::Lint::FormatParameterMismatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#45
RuboCop::Cop::Lint::FormatParameterMismatch::SHOVEL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/format_parameter_mismatch.rb#46
RuboCop::Cop::Lint::FormatParameterMismatch::STRING_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::HashCompareByIdentity < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/hash_compare_by_identity.rb#37
  def id_as_hash_key?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/hash_compare_by_identity.rb#41
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/hash_compare_by_identity.rb#34
RuboCop::Cop::Lint::HashCompareByIdentity::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/hash_compare_by_identity.rb#32
RuboCop::Cop::Lint::HashCompareByIdentity::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::HeredocMethodCallPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#39
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#39
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#99
  def all_on_same_line?(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#52
  def autocorrect(corrector, node, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#79
  def call_after_heredoc_range(heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#109
  def call_end_pos(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#118
  def call_line_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#124
  def call_range_to_safely_reposition(node, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#88
  def calls_on_multiple_lines?(node, _heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#84
  def correctly_positioned?(node, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#113
  def heredoc_begin_line_range(heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#105
  def heredoc_end_pos(heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#75
  def heredoc_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#61
  def heredoc_node_descendent_receiver(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#69
  def send_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#148
  def trailing_comma?(call_source, call_line_source); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/heredoc_method_call_position.rb#37
RuboCop::Cop::Lint::HeredocMethodCallPosition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::IdentityComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/identity_comparison.rb#25
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/identity_comparison.rb#41
  def compare_between_object_id_by_double_equal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/identity_comparison.rb#45
  def object_id_method?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/identity_comparison.rb#22
RuboCop::Cop::Lint::IdentityComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/identity_comparison.rb#23
RuboCop::Cop::Lint::IdentityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ImplicitStringConcatenation < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#33
  def on_dstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#83
  def display_str(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#50
  def each_bad_cons(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#65
  def ending_delimiter(str); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#91
  def str_content(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#75
  def string_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#79
  def string_literals?(node1, node2); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#28
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_ARRAY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#30
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/implicit_string_concatenation.rb#26
RuboCop::Cop::Lint::ImplicitStringConcatenation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#39
  def io_select(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#44
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#67
  def preferred_method(read, write, timeout); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#61
  def scheduler_compatible?(io1, io2); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#35
RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#36
RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::IneffectiveAccessModifier < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#59
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#59
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#55
  def private_class_methods(param0); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#109
  def access_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#66
  def check_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#113
  def correct_visibility?(node, modifier, ignored_methods); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#78
  def format_message(modifier); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#91
  def ineffective_modifier(node, ignored_methods = T.unsafe(nil), modifier = T.unsafe(nil), &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#74
  def private_class_method_names(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#51
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PRIVATE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#52
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PROTECTED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ineffective_access_modifier.rb#49
RuboCop::Cop::Lint::IneffectiveAccessModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::InheritException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#53
  def class_new_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#59
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#69
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#86
  def exception_class?(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#82
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#90
  def preferred_base_class; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#44
RuboCop::Cop::Lint::InheritException::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#45
RuboCop::Cop::Lint::InheritException::PREFERRED_BASE_CLASS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/inherit_exception.rb#50
RuboCop::Cop::Lint::InheritException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::InterpolationCheck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/interpolation_check.rb#30
  def on_str(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/interpolation_check.rb#41
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/interpolation_check.rb#52
  def heredoc?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/interpolation_check.rb#27
RuboCop::Cop::Lint::InterpolationCheck::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/lambda_without_literal_block.rb#35
  def lambda_with_symbol_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/lambda_without_literal_block.rb#39
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/lambda_without_literal_block.rb#31
RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/lambda_without_literal_block.rb#32
RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::LiteralAsCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#93
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#58
  def on_case(case_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#73
  def on_case_match(case_match_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#40
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#87
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#51
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#51
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#44
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#44
  def on_while_post(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#108
  def basic_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#138
  def check_case(case_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#99
  def check_for_literal(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#120
  def check_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#147
  def condition(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#130
  def handle_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#116
  def primitive_array?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#155
  def when_conditions_range(when_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_as_condition.rb#38
RuboCop::Cop::Lint::LiteralAsCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::LiteralInInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#28
  def on_interpolation(begin_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#62
  def autocorrected_value(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#97
  def autocorrected_value_for_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#82
  def autocorrected_value_for_string(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#90
  def autocorrected_value_for_symbol(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#113
  def ends_heredoc_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#121
  def in_array_percent_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#48
  def offending?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#104
  def prints_as_self?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#109
  def space_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#56
  def special_keyword?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#26
RuboCop::Cop::Lint::LiteralInInterpolation::COMPOSITE = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/literal_in_interpolation.rb#25
RuboCop::Cop::Lint::LiteralInInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::Loop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/loop.rb#59
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/loop.rb#55
  def on_while_post(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/loop.rb#79
  def build_break_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/loop.rb#75
  def keyword_and_condition_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/loop.rb#65
  def register_offense(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/loop.rb#53
RuboCop::Cop::Lint::Loop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::MissingCopEnableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#51
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#89
  def department_enabled?(cop, comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#66
  def each_missing_enable; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#72
  def max_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#76
  def message(cop, comment, type = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#48
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_cop_enable_directive.rb#49
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG_BOUND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::MissingSuper < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#58
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#68
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#80
  def callback_method_def?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#86
  def contains_super?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#90
  def inside_class_with_stateful_parent?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#76
  def offender?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#95
  def stateless_class?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#56
RuboCop::Cop::Lint::MissingSuper::CALLBACKS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#47
RuboCop::Cop::Lint::MissingSuper::CALLBACK_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#51
RuboCop::Cop::Lint::MissingSuper::CLASS_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#46
RuboCop::Cop::Lint::MissingSuper::CONSTRUCTOR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#52
RuboCop::Cop::Lint::MissingSuper::METHOD_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/missing_super.rb#49
RuboCop::Cop::Lint::MissingSuper::STATELESS_CLASSES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#26
  def on_regexp(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#24
RuboCop::Cop::Lint::MixedRegexpCaptureTypes::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::MultipleComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/multiple_comparison.rb#29
  def multiple_compare?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/multiple_comparison.rb#33
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/multiple_comparison.rb#24
RuboCop::Cop::Lint::MultipleComparison::COMPARISON_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/multiple_comparison.rb#23
RuboCop::Cop::Lint::MultipleComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/multiple_comparison.rb#26
RuboCop::Cop::Lint::MultipleComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/multiple_comparison.rb#25
RuboCop::Cop::Lint::MultipleComparison::SET_OPERATION_OPERATORS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::NestedMethodDefinition < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#94
  def class_or_module_or_struct_new_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#84
  def eval_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#89
  def exec_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#60
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#60
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#78
  def scoping_method_call?(child); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_method_definition.rb#58
RuboCop::Cop::Lint::NestedMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NestedPercentLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_percent_literal.rb#44
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_percent_literal.rb#48
  def on_percent_literal(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_percent_literal.rb#54
  def contains_percent_literals?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_percent_literal.rb#35
RuboCop::Cop::Lint::NestedPercentLiteral::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_percent_literal.rb#41
RuboCop::Cop::Lint::NestedPercentLiteral::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/nested_percent_literal.rb#42
RuboCop::Cop::Lint::NestedPercentLiteral::REGEXES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::NextWithoutAccumulator < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#28
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#51
  def on_block_body_of_reduce(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#38
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#56
  def on_numblock_body_of_reduce(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#60
  def parent_block_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#64
  def parent_numblock_node(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/next_without_accumulator.rb#26
RuboCop::Cop::Lint::NextWithoutAccumulator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#46
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#46
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#46
  def on_or_asgn(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#44
RuboCop::Cop::Lint::NoReturnInBeginEndBlocks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NonAtomicFileOperation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#76
  def explicit_not_force?(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#71
  def force?(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#80
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#66
  def receiver_and_method_name(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#61
  def send_exist_node(param0); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#97
  def allowable_use_with_if?(if_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#120
  def autocorrect(corrector, node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#126
  def autocorrect_replace_method(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#143
  def force_method?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#151
  def force_method_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#147
  def force_option?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#91
  def if_node_child?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#111
  def message_change_force_method(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#115
  def message_remove_file_exist_check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#101
  def register_offense(node, exist_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#133
  def replacement_method(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#52
RuboCop::Cop::Lint::NonAtomicFileOperation::MAKE_FORCE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#53
RuboCop::Cop::Lint::NonAtomicFileOperation::MAKE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#51
RuboCop::Cop::Lint::NonAtomicFileOperation::MSG_CHANGE_FORCE_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#49
RuboCop::Cop::Lint::NonAtomicFileOperation::MSG_REMOVE_FILE_EXIST_CHECK = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#54
RuboCop::Cop::Lint::NonAtomicFileOperation::REMOVE_FORCE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#55
RuboCop::Cop::Lint::NonAtomicFileOperation::REMOVE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_atomic_file_operation.rb#57
RuboCop::Cop::Lint::NonAtomicFileOperation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::NonDeterministicRequireOrder < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#174
  def loop_variable(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#157
  def method_require?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#65
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#89
  def on_block_pass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#77
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#147
  def unsorted_dir_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#152
  def unsorted_dir_each?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#168
  def unsorted_dir_each_pass?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#162
  def unsorted_dir_glob_pass?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#179
  def var_is_required?(param0, param1); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#107
  def correct_block(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#117
  def correct_block_pass(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#132
  def last_arg_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#138
  def unsorted_dir_loop?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#142
  def unsorted_dir_pass?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_deterministic_require_order.rb#63
RuboCop::Cop::Lint::NonDeterministicRequireOrder::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NonLocalExitFromIterator < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#77
  def chained_send?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#80
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#46
  def on_return(return_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#72
  def return_value?(return_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#68
  def scoped_node?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#42
RuboCop::Cop::Lint::NonLocalExitFromIterator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NumberConversion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#102
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#92
  def to_method(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#97
  def to_method_symbol(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#155
  def allow_receiver?(receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#167
  def allowed_method_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#177
  def conversion_method?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#141
  def correct_method(node, receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#145
  def correct_sym_method(to_method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#124
  def handle_as_symbol(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#109
  def handle_conversion_method(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#185
  def ignored_class?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#181
  def ignored_classes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#150
  def remove_parentheses(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#171
  def top_receiver(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#88
RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#78
RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHOD_CLASS_MAPPING = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#89
RuboCop::Cop::Lint::NumberConversion::METHODS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/number_conversion.rb#84
RuboCop::Cop::Lint::NumberConversion::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NumberedParameterAssignment < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/numbered_parameter_assignment.rb#35
  def on_lvasgn(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/numbered_parameter_assignment.rb#32
RuboCop::Cop::Lint::NumberedParameterAssignment::LVAR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/numbered_parameter_assignment.rb#33
RuboCop::Cop::Lint::NumberedParameterAssignment::NUMBERED_PARAMETER_RANGE = T.let(T.unsafe(nil), Range)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/numbered_parameter_assignment.rb#31
RuboCop::Cop::Lint::NumberedParameterAssignment::NUM_PARAM_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::OrAssignmentToConstant < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/or_assignment_to_constant.rb#29
  def on_or_asgn(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/or_assignment_to_constant.rb#27
RuboCop::Cop::Lint::OrAssignmentToConstant::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::OrderedMagicComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ordered_magic_comments.rb#36
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ordered_magic_comments.rb#53
  def autocorrect(corrector, encoding_line, frozen_string_literal_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ordered_magic_comments.rb#61
  def magic_comment_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/ordered_magic_comments.rb#77
  def magic_comments; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/ordered_magic_comments.rb#34
RuboCop::Cop::Lint::OrderedMagicComments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::OutOfRangeRegexpRef < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#55
  def after_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#51
  def on_match_with_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#47
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#71
  def on_nth_ref(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#65
  def on_when(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#87
  def check_regexp(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#107
  def nth_ref_receiver?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#98
  def regexp_first_argument?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#103
  def regexp_receiver?(send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#39
RuboCop::Cop::Lint::OutOfRangeRegexpRef::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#42
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_ARGUMENT_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#44
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_CAPTURE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#41
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_RECEIVER_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#45
RuboCop::Cop::Lint::OutOfRangeRegexpRef::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#24
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#24
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#56
  def chained_calls?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#52
  def first_argument_starts_with_left_parenthesis?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#81
  def space_range(expr, space_length); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#65
  def spaces_before_left_parenthesis(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#61
  def ternary_expression?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#39
  def valid_context?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#48
  def valid_first_argument?(first_arg); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#22
RuboCop::Cop::Lint::ParenthesesAsGroupedExpression::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::PercentStringArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#44
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#48
  def on_percent_literal(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#65
  def contains_quotes_or_commas?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#38
RuboCop::Cop::Lint::PercentStringArray::LEADING_QUOTE = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#41
RuboCop::Cop::Lint::PercentStringArray::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#37
RuboCop::Cop::Lint::PercentStringArray::QUOTES_AND_COMMAS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_string_array.rb#39
RuboCop::Cop::Lint::PercentStringArray::TRAILING_QUOTE = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Lint::PercentSymbolArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_symbol_array.rb#30
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_symbol_array.rb#34
  def on_percent_literal(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_symbol_array.rb#42
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_symbol_array.rb#52
  def contains_colons_or_commas?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_symbol_array.rb#62
  def non_alphanumeric_literal?(literal); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/percent_symbol_array.rb#27
RuboCop::Cop::Lint::PercentSymbolArray::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RaiseException < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#41
  def exception?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#46
  def exception_new_with_message?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#51
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#85
  def allow_implicit_namespaces; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#57
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#73
  def implicit_namespace?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#37
RuboCop::Cop::Lint::RaiseException::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/raise_exception.rb#38
RuboCop::Cop::Lint::RaiseException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RandOne < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rand_one.rb#32
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rand_one.rb#28
  def rand_one?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rand_one.rb#40
  def message(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/rand_one.rb#24
RuboCop::Cop::Lint::RandOne::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/rand_one.rb#25
RuboCop::Cop::Lint::RandOne::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RedundantCopDisableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#37
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil), offenses = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#35
  def offenses_to_check; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#35
  def offenses_to_check=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#42
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#283
  def add_department_marker(department); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#206
  def add_offense_for_entire_comment(comment, cops); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#216
  def add_offense_for_some_cops(comment, cops); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#196
  def add_offenses(redundant_cops); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#266
  def all_cop_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#177
  def all_disabled?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#69
  def comment_range_with_surrounding_space(directive_comment_range, line_comment_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#57
  def cop_disabled_line_ranges; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#230
  def cop_range(comment, cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#187
  def department_disabled?(cop, comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#275
  def department_marker?(department); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#253
  def describe(cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#192
  def directive_count(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#92
  def directive_range_in_list(range, ranges); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#61
  def disabled_ranges; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#130
  def each_already_disabled(cop, line_ranges); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#113
  def each_line_range(cop, line_ranges); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#106
  def each_redundant_disable(&block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#270
  def ends_its_line?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#153
  def find_redundant_all(range, next_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#148
  def find_redundant_cop(cop, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#163
  def find_redundant_department(cop, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#169
  def followed_ranges?(range, next_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#181
  def ignore_offense?(line_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#237
  def matching_range(haystack, needle); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#262
  def message(cop_names); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#65
  def previous_line_blank?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#173
  def range_with_offense?(range, offenses = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#279
  def remove_department_marker(department); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#245
  def trailing_range?(ranges, range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#32
RuboCop::Cop::Lint::RedundantCopDisableDirective::COP_NAME = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#33
RuboCop::Cop::Lint::RedundantCopDisableDirective::DEPARTMENT_MARKER = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantCopEnableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#44
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#120
  def all_or_name(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#76
  def comment_start(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#80
  def cop_name_indention(comment, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#124
  def department?(directive, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#71
  def range_of_offense(comment, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#95
  def range_to_remove(begin_pos, end_pos, comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#84
  def range_with_comma(comment, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#114
  def range_with_comma_after(comment, start, begin_pos, end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#108
  def range_with_comma_before(start, begin_pos, end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#53
  def register_offense(comment, cop_names); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#42
RuboCop::Cop::Lint::RedundantCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantDirGlobSort < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#40
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#38
RuboCop::Cop::Lint::RedundantDirGlobSort::GLOB_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#36
RuboCop::Cop::Lint::RedundantDirGlobSort::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#37
RuboCop::Cop::Lint::RedundantDirGlobSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RedundantRequireStatement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_require_statement.rb#40
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_require_statement.rb#35
  def unnecessary_require_statement?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_require_statement.rb#31
RuboCop::Cop::Lint::RedundantRequireStatement::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_require_statement.rb#32
RuboCop::Cop::Lint::RedundantRequireStatement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RedundantSafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_safe_navigation.rb#65
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_safe_navigation.rb#61
  def respond_to_nil_specific_method?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_safe_navigation.rb#75
  def check?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_safe_navigation.rb#85
  def condition?(parent, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_safe_navigation.rb#56
RuboCop::Cop::Lint::RedundantSafeNavigation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_safe_navigation.rb#58
RuboCop::Cop::Lint::RedundantSafeNavigation::NIL_SPECIFIC_METHODS = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Lint::RedundantSplatExpansion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#83
  def array_new?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#91
  def literal_expansion(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#95
  def on_splat(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#203
  def allow_percent_literal_array_argument?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#131
  def array_new_inside_array_literal?(array_new_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#155
  def array_splat?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#112
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#159
  def method_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#163
  def part_of_an_array?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#170
  def redundant_brackets?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#118
  def redundant_splat_expansion(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#178
  def remove_brackets(array); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#138
  def replacement_range_and_content(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#196
  def use_percent_literal_array_argument?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#75
RuboCop::Cop::Lint::RedundantSplatExpansion::ARRAY_PARAM_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#80
RuboCop::Cop::Lint::RedundantSplatExpansion::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#74
RuboCop::Cop::Lint::RedundantSplatExpansion::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#79
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_I = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#77
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_W = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#78
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_I = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_splat_expansion.rb#76
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_W = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantStringCoercion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_string_coercion.rb#30
  def on_interpolation(begin_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_string_coercion.rb#28
  def to_s_without_args?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_string_coercion.rb#24
RuboCop::Cop::Lint::RedundantStringCoercion::MSG_DEFAULT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_string_coercion.rb#25
RuboCop::Cop::Lint::RedundantStringCoercion::MSG_SELF = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantWithIndex < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#36
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#36
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#56
  def redundant_with_index?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#66
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#74
  def with_index_range(send); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#33
RuboCop::Cop::Lint::RedundantWithIndex::MSG_EACH_WITH_INDEX = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_index.rb#34
RuboCop::Cop::Lint::RedundantWithIndex::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantWithObject < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#36
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#36
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#56
  def redundant_with_object?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#65
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#73
  def with_object_range(send); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#33
RuboCop::Cop::Lint::RedundantWithObject::MSG_EACH_WITH_OBJECT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/redundant_with_object.rb#34
RuboCop::Cop::Lint::RedundantWithObject::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RefinementImportMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/refinement_import_methods.rb#42
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/refinement_import_methods.rb#37
RuboCop::Cop::Lint::RefinementImportMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/refinement_import_methods.rb#38
RuboCop::Cop::Lint::RefinementImportMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RegexpAsCondition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/regexp_as_condition.rb#25
  def on_match_current_line(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/regexp_as_condition.rb#22
RuboCop::Cop::Lint::RegexpAsCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RequireParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_parentheses.rb#35
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_parentheses.rb#35
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_parentheses.rb#56
  def check_predicate(predicate, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_parentheses.rb#48
  def check_ternary(ternary, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/require_parentheses.rb#33
RuboCop::Cop::Lint::RequireParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RequireRangeParentheses < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_range_parentheses.rb#43
  def on_erange(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_range_parentheses.rb#43
  def on_irange(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/require_range_parentheses.rb#41
RuboCop::Cop::Lint::RequireRangeParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RequireRelativeSelfPath < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_relative_self_path.rb#28
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_relative_self_path.rb#44
  def remove_ext(file_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/require_relative_self_path.rb#40
  def same_file?(file_path, required_feature); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/require_relative_self_path.rb#25
RuboCop::Cop::Lint::RequireRelativeSelfPath::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/require_relative_self_path.rb#26
RuboCop::Cop::Lint::RequireRelativeSelfPath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RescueException < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_exception.rb#30
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_exception.rb#39
  def targets_exception?(rescue_arg_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_exception.rb#28
RuboCop::Cop::Lint::RescueException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RescueType < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#60
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#44
  def on_resbody(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#71
  def correction(*exceptions); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#82
  def invalid_exceptions(exceptions); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#78
  def valid_exceptions(exceptions); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#42
RuboCop::Cop::Lint::RescueType::INVALID_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/rescue_type.rb#40
RuboCop::Cop::Lint::RescueType::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ReturnInVoidContext < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/return_in_void_context.rb#37
  def on_return(return_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/return_in_void_context.rb#53
  def non_void_context(return_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/return_in_void_context.rb#35
RuboCop::Cop::Lint::ReturnInVoidContext::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SafeNavigationChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_chain.rb#36
  def bad_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_chain.rb#43
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_chain.rb#63
  def add_safe_navigation_operator(offense_range:, send_node:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_chain.rb#81
  def autocorrect(corrector, offense_range:, send_node:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_chain.rb#91
  def method_chain(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_chain.rb#33
RuboCop::Cop::Lint::SafeNavigationChain::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SafeNavigationConsistency < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#42
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#36
  def on_csend(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#61
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#67
  def location(node, unsafe_method_call); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#71
  def top_conditional_ancestor(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#82
  def unsafe_method_calls(method_calls, safe_nav_receiver); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_consistency.rb#34
RuboCop::Cop::Lint::SafeNavigationConsistency::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SafeNavigationWithEmpty < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_with_empty.rb#32
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_with_empty.rb#28
  def safe_navigation_empty_in_conditional?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/safe_navigation_with_empty.rb#25
RuboCop::Cop::Lint::SafeNavigationWithEmpty::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ScriptPermission < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/script_permission.rb#39
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/script_permission.rb#55
  def autocorrect(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/script_permission.rb#59
  def executable?(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/script_permission.rb#66
  def format_message_from(processed_source); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/script_permission.rb#36
RuboCop::Cop::Lint::ScriptPermission::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/script_permission.rb#37
RuboCop::Cop::Lint::ScriptPermission::SHEBANG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SelfAssignment < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#53
  def on_and_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#41
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#29
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#29
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#29
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#29
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#49
  def on_masgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#53
  def on_or_asgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#61
  def multiple_self_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#71
  def rhs_matches_lhs?(rhs, lhs); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#22
RuboCop::Cop::Lint::SelfAssignment::ASSIGNMENT_TYPE_TO_RHS_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/self_assignment.rb#20
RuboCop::Cop::Lint::SelfAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SendWithMixinArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#54
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#47
  def send_with_mixin_argument?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#67
  def bad_location(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#73
  def message(method, module_name, bad_method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#77
  def mixin_method?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#42
RuboCop::Cop::Lint::SendWithMixinArgument::MIXIN_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#41
RuboCop::Cop::Lint::SendWithMixinArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#44
RuboCop::Cop::Lint::SendWithMixinArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/send_with_mixin_argument.rb#43
RuboCop::Cop::Lint::SendWithMixinArgument::SEND_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ShadowedArgument < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#76
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#70
  def uses_var?(param0, param1); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#160
  def argument_references(argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#120
  def assignment_without_argument_usage(argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#82
  def check_argument(argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#170
  def ignore_implicit_references?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#151
  def node_within_block_or_conditional?(node, stop_search_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#143
  def reference_pos(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#95
  def shadowing_assignment(argument); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#72
    def joining_forces; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_argument.rb#67
RuboCop::Cop::Lint::ShadowedArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ShadowedException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#67
  def on_rescue(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#101
  def compare_exceptions(exception, other_exception); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#94
  def contains_multiple_levels_of_exceptions?(group); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#119
  def evaluate_exceptions(group); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#168
  def find_shadowing_rescue(rescues); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#84
  def offense_range(rescues); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#159
  def rescued_exceptions(rescue_group); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#90
  def rescued_groups_for(rescues); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#143
  def sorted?(rescued_groups); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#115
  def system_call_err?(error); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowed_exception.rb#65
RuboCop::Cop::Lint::ShadowedException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#54
  def before_declaring_variable(variable, variable_table); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#89
  def find_conditional_node_from_ascendant(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#46
  def ractor_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#66
  def same_conditions_node_different_branch?(variable, outer_local_variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#79
  def variable_node(variable); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#50
    def joining_forces; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#43
RuboCop::Cop::Lint::ShadowingOuterLocalVariable::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::StructNewOverride < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/struct_new_override.rb#38
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/struct_new_override.rb#33
  def struct_new(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/struct_new_override.rb#25
RuboCop::Cop::Lint::StructNewOverride::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/struct_new_override.rb#27
RuboCop::Cop::Lint::StructNewOverride::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/struct_new_override.rb#30
RuboCop::Cop::Lint::StructNewOverride::STRUCT_MEMBER_NAME_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/struct_new_override.rb#29
RuboCop::Cop::Lint::StructNewOverride::STRUCT_METHOD_NAMES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::SuppressedException < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/suppressed_exception.rb#108
  def on_resbody(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/suppressed_exception.rb#118
  def comment_between_rescue_and_end?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/suppressed_exception.rb#126
  def nil_body?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/suppressed_exception.rb#106
RuboCop::Cop::Lint::SuppressedException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SymbolConversion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#100
  def on_hash(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#76
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#83
  def on_sym(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#142
  def correct_hash_key(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#161
  def correct_inconsistent_hash_keys(keys); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#134
  def in_alias?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#138
  def in_percent_literal_array?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#121
  def properly_quoted?(source, value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#117
  def register_offense(node, correction:, message: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#130
  def requires_quotes?(sym_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#71
RuboCop::Cop::Lint::SymbolConversion::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#72
RuboCop::Cop::Lint::SymbolConversion::MSG_CONSISTENCY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/symbol_conversion.rb#74
RuboCop::Cop::Lint::SymbolConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::Syntax < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/syntax.rb#9
  def on_other_file; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/syntax.rb#19
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/syntax.rb#26
  def add_offense_from_error(error); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/syntax.rb#31
  def beautify_message(message); end
end

class RuboCop::Cop::Lint::ToEnumArguments < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#27
  def enum_conversion_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#32
  def method_name?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#41
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#37
  def passing_keyword_arg?(param0 = T.unsafe(nil), param1); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#68
  def argument_match?(send_arg, def_arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#53
  def arguments_match?(arguments, def_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#22
RuboCop::Cop::Lint::ToEnumArguments::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/to_enum_arguments.rb#24
RuboCop::Cop::Lint::ToEnumArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ToJSON < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/to_json.rb#36
  def on_def(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/to_json.rb#34
RuboCop::Cop::Lint::ToJSON::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::TopLevelReturnWithArgument < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/top_level_return_with_argument.rb#21
  def on_return(return_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/top_level_return_with_argument.rb#27
  def ancestors_valid?(return_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/top_level_return_with_argument.rb#19
RuboCop::Cop::Lint::TopLevelReturnWithArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#36
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#46
  def trailing_comma_range(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#34
RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::TripleQuotes < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/triple_quotes.rb#47
  def on_dstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/triple_quotes.rb#65
  def empty_str_nodes(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/triple_quotes.rb#45
RuboCop::Cop::Lint::TripleQuotes::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#50
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#54
  def check_variable(variable); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#72
  def allowed_keyword_block_argument?(variable); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#46
    def joining_forces; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#44
RuboCop::Cop::Lint::UnderscorePrefixedVariableName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnexpectedBlockArity < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#44
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#44
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#63
  def acceptable?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#75
  def arg_count(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#71
  def expected_arity(method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#67
  def included_method?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#59
  def methods; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unexpected_block_arity.rb#42
RuboCop::Cop::Lint::UnexpectedBlockArity::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnifiedInteger < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unified_integer.rb#26
  def fixnum_or_bignum_const(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unified_integer.rb#30
  def on_const(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unified_integer.rb#23
RuboCop::Cop::Lint::UnifiedInteger::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#78
  def accumulator_index?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#83
  def element_modified?(param0, param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#104
  def expression_values(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#93
  def lvar_used?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#115
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#115
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#70
  def reduce_with_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#190
  def acceptable_return?(return_val, element_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#198
  def allowed_type?(parent_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#158
  def block_arg_name(node, index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#141
  def check_return_values(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#175
  def potential_offense?(return_values, block_body, element_name, accumulator_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#127
  def return_values(block_body_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#166
  def returned_accumulator_index(return_values, accumulator_name, element_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#182
  def returns_accumulator_anywhere?(return_values, accumulator_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#66
RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#67
RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG_INDEX = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnreachableCode < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#55
  def flow_command?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#40
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#40
  def on_kwbegin(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#87
  def check_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#81
  def check_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#65
  def flow_expression?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_code.rb#38
RuboCop::Cop::Lint::UnreachableCode::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnreachableLoop < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#143
  def break_command?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#100
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#104
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_while_post(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#153
  def break_statement?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#119
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#176
  def check_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#170
  def check_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#194
  def conditional_continue_keyword?(break_statement); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#110
  def loop_method?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#184
  def preceded_by_continue_statement?(break_statement); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#130
  def statements(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#90
RuboCop::Cop::Lint::UnreachableLoop::CONTINUE_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/unreachable_loop.rb#89
RuboCop::Cop::Lint::UnreachableLoop::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/unused_argument.rb#10
  def after_leaving_scope(scope, _variable_table); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/unused_argument.rb#16
  def check_argument(variable); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#162
  def allow_unused_keyword_arguments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#81
  def allowed_block?(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#85
  def allowed_keyword_argument?(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#99
  def augment_message(message, variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#65
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#69
  def check_argument(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#149
  def define_method_call?(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#156
  def empty_block?(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#166
  def ignore_empty_blocks?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#89
  def message(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#132
  def message_for_lambda(variable, all_arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#120
  def message_for_normal_block(variable, all_arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#144
  def message_for_underscore_prefix(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#77
  def used_block_local?(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#112
  def variable_type(variable); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_block_argument.rb#59
    def joining_forces; end
  end
end

class RuboCop::Cop::Lint::UnusedMethodArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_method_argument.rb#66
  def not_implemented?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_method_argument.rb#77
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_method_argument.rb#81
  def check_argument(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_method_argument.rb#89
  def ignored_method?(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_method_argument.rb#94
  def message(variable); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/unused_method_argument.rb#71
    def joining_forces; end
  end
end

class RuboCop::Cop::Lint::UriEscapeUnescape < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#57
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#51
  def uri_escape_unescape?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#33
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_ESCAPE = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#38
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_UNESCAPE = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#47
RuboCop::Cop::Lint::UriEscapeUnescape::METHOD_NAMES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#44
RuboCop::Cop::Lint::UriEscapeUnescape::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_escape_unescape.rb#48
RuboCop::Cop::Lint::UriEscapeUnescape::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::UriRegexp < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_regexp.rb#23
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_regexp.rb#19
RuboCop::Cop::Lint::UriRegexp::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_regexp.rb#21
RuboCop::Cop::Lint::UriRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/uri_regexp.rb#20
RuboCop::Cop::Lint::UriRegexp::URI_CONSTANTS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::UselessAccessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#166
  def class_or_instance_eval?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#171
  def class_or_module_or_struct_new_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#161
  def dynamic_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#139
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#133
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#133
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#139
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#133
  def on_sclass(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#156
  def static_method_definition?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#187
  def access_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#277
  def any_context_creating_methods?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#254
  def any_method_definition?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#149
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#200
  def check_child_nodes(node, unused, cur_vis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#227
  def check_new_visibility(node, unused, new_vis, cur_vis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#175
  def check_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#191
  def check_scope(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#216
  def check_send_node(node, cur_vis, unused); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#271
  def eval_call?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#248
  def method_definition?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#267
  def start_of_new_scope?(child); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_access_modifier.rb#131
RuboCop::Cop::Lint::UselessAccessModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessAssignment < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#40
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#44
  def check_for_unused_assignments(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#108
  def collect_variable_like_names(scope); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#62
  def message_for_useless_assignment(assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#68
  def message_specification(assignment, variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#78
  def multiple_assignment_message(variable_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#83
  def operator_assignment_message(scope, assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#98
  def return_value_node_of_scope(scope); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#91
  def similar_name_message(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#117
  def variable_like_method_invocation?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#36
    def joining_forces; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_assignment.rb#34
RuboCop::Cop::Lint::UselessAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessElseWithoutRescue < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_else_without_rescue.rb#34
  def on_new_investigation; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_else_without_rescue.rb#32
RuboCop::Cop::Lint::UselessElseWithoutRescue::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessMethodDefinition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_method_definition.rb#43
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_method_definition.rb#43
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_method_definition.rb#57
  def delegating?(node, def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_method_definition.rb#53
  def optional_args?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_method_definition.rb#41
RuboCop::Cop::Lint::UselessMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessRuby2Keywords < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#72
  def method_definition(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#79
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#108
  def allowed_arguments(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#89
  def inspect_def(node, def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#95
  def inspect_sym(node, sym_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#67
RuboCop::Cop::Lint::UselessRuby2Keywords::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_ruby2_keywords.rb#68
RuboCop::Cop::Lint::UselessRuby2Keywords::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::UselessSetterCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#41
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#41
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#63
  def setter_call_to_local_variable?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#67
  def last_expression(body); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#39
RuboCop::Cop::Lint::UselessSetterCall::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#38
RuboCop::Cop::Lint::UselessSetterCall::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#77
  def initialize(body_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#163
  def constructor?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#82
  def contain_local_object?(variable_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#152
  def process_assignment(asgn_node, rhs_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#100
  def process_assignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#142
  def process_binary_operator_assignment(op_asgn_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#133
  def process_logical_operator_assignment(asgn_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#114
  def process_multiple_assignment(masgn_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_setter_call.rb#92
  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessTimes < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#37
  def block_arg(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#42
  def block_reassigns_arg?(param0, param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#46
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#32
  def times_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#62
  def autocorrect(corrector, count, node, proc_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#84
  def autocorrect_block(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#80
  def autocorrect_block_pass(corrector, node, proc_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#94
  def fix_indentation(source, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#72
  def never_process?(count, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#106
  def own_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#76
  def remove_node(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#28
RuboCop::Cop::Lint::UselessTimes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/useless_times.rb#29
RuboCop::Cop::Lint::UselessTimes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::Void < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#72
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#63
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#72
  def on_kwbegin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#63
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#79
  def check_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#120
  def check_defined(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#85
  def check_expression(expr); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#108
  def check_literal(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#126
  def check_nonmutating(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#114
  def check_self(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#102
  def check_var(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#96
  def check_void_op(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#132
  def in_void_context?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#51
RuboCop::Cop::Lint::Void::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#48
RuboCop::Cop::Lint::Void::DEFINED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#46
RuboCop::Cop::Lint::Void::LIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#55
RuboCop::Cop::Lint::Void::NONMUTATING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#49
RuboCop::Cop::Lint::Void::NONMUTATING_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#53
RuboCop::Cop::Lint::Void::OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#44
RuboCop::Cop::Lint::Void::OP_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#47
RuboCop::Cop::Lint::Void::SELF_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#52
RuboCop::Cop::Lint::Void::UNARY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#45
RuboCop::Cop::Lint::Void::VAR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/lint/void.rb#54
RuboCop::Cop::Lint::Void::VOID_CONTEXT_TYPES = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/match_range.rb#13
  def each_match_range(range, regex); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/match_range.rb#18
  def match_range(range, match); end
end

class RuboCop::Cop::MessageAnnotator
  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#47
  def initialize(config, cop_name, cop_config, options); end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#58
  def annotate(message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#16
  def config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#16
  def cop_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#16
  def cop_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#16
  def options; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#68
  def urls; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#111
  def debug?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#124
  def details; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#115
  def display_cop_names?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#98
  def display_style_guide?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#107
  def extra_details?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#102
  def reference_urls; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#91
  def style_guide_base_url; end

  # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#74
  def style_guide_url; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/message_annotator.rb#21
    def style_guide_urls; end
  end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#37
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#24
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#17
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#17
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#24
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#42
  def check_complexity(node, method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_complexity.rb#61
  def complexity(body); end
end

module RuboCop::Cop::MethodPreference
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_preference.rb#25
  def default_cop_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_preference.rb#9
  def preferred_method(method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/method_preference.rb#13
  def preferred_methods; end
end

module RuboCop::Cop::Metrics; end

class RuboCop::Cop::Metrics::AbcSize < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::MethodComplexity

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/abc_size.rb#47
  def complexity(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/abc_size.rb#42
RuboCop::Cop::Metrics::AbcSize::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::BlockLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_length.rb#46
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_length.rb#46
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_length.rb#75
  def cop_label; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_length.rb#57
  def method_receiver_excluded?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_length.rb#44
RuboCop::Cop::Metrics::BlockLength::LABEL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::BlockNesting < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_nesting.rb#19
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_nesting.rb#28
  def check_nesting_level(node, max, current_level); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_nesting.rb#44
  def consider_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_nesting.rb#54
  def count_blocks?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_nesting.rb#50
  def message(max); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/block_nesting.rb#15
RuboCop::Cop::Metrics::BlockNesting::NESTING_BLOCKS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Metrics::ClassLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/class_length.rb#41
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/class_length.rb#37
  def on_class(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/class_length.rb#59
  def message(length, max_length); end
end

class RuboCop::Cop::Metrics::CyclomaticComplexity < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/cyclomatic_complexity.rb#42
  def complexity_score_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/cyclomatic_complexity.rb#49
  def count_block?(block); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/cyclomatic_complexity.rb#37
RuboCop::Cop::Metrics::CyclomaticComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/cyclomatic_complexity.rb#36
RuboCop::Cop::Metrics::CyclomaticComplexity::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::MethodLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/method_length.rb#51
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/method_length.rb#44
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/method_length.rb#44
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/method_length.rb#51
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/method_length.rb#60
  def cop_label; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/method_length.rb#42
RuboCop::Cop::Metrics::MethodLength::LABEL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::ModuleLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/module_length.rb#46
  def module_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/module_length.rb#39
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/module_length.rb#35
  def on_module(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/module_length.rb#50
  def message(length, max_length); end
end

class RuboCop::Cop::Metrics::ParameterLists < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#94
  def argument_to_lambda_or_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max_optional_parameters=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#80
  def on_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#66
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#66
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#98
  def args_count(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#114
  def count_keyword_args?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#110
  def max_optional_parameters; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#106
  def max_params; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#60
RuboCop::Cop::Metrics::ParameterLists::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/parameter_lists.rb#61
RuboCop::Cop::Metrics::ParameterLists::OPTIONAL_PARAMETERS_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::PerceivedComplexity < ::RuboCop::Cop::Metrics::CyclomaticComplexity
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/perceived_complexity.rb#36
  def complexity_score_for(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/perceived_complexity.rb#32
RuboCop::Cop::Metrics::PerceivedComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/perceived_complexity.rb#30
RuboCop::Cop::Metrics::PerceivedComplexity::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Metrics::Utils; end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#30
  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#45
  def calculate; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#53
  def calculate_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#68
  def else_branch?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#47
  def evaluate_branch_nodes(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#63
  def evaluate_condition_node(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#131
  def argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#89
  def assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#127
  def branch?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#122
  def capturing_variable?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#98
  def compound_assignment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#135
  def condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#111
  def simple_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#74
  def visit_depth_last(node, &block); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#28
    def calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
  end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#16
  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#24
  def calculate; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#172
  def another_args?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#42
  def build_foldable_checks(types); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#80
  def classlike_code_length(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#128
  def classlike_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#63
  def code_length(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#153
  def count_comments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#116
  def each_top_level_descendant(node, types, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#136
  def extract_body(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#132
  def foldable_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#111
  def heredoc_length(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#76
  def heredoc_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#149
  def irrelevant_line?(source_line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#100
  def line_numbers_of_inner_nodes(node, *types); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#96
  def namespace_module?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#58
  def normalize_foldable_types(types); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#157
  def omit_length(descendant); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/code_length_calculator.rb#168
  def parenthesized?(node); end
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/iterating_block.rb#37
  def block_method_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/iterating_block.rb#53
  def iterating_block?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/iterating_block.rb#47
  def iterating_method?(name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/iterating_block.rb#33
RuboCop::Cop::Metrics::Utils::IteratingBlock::KNOWN_ITERATING_METHODS = T.let(T.unsafe(nil), Set)

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#30
  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#61
  def attribute_call?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#53
  def calculate_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#43
  def discount_repeated_attributes?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#47
  def evaluate_branch_nodes(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#92
  def root_node?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#66
  def discount_repeated_attribute?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#103
  def find_attributes(node, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#126
  def setter_to_getter(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#80
  def update_repeated_attribute(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#117
RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount::VAR_SETTER_TO_GETTER = T.let(T.unsafe(nil), Hash)

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#20
  def discount_for_repeated_csend?(csend_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#34
  def reset_on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#16
  def reset_repeated_csend; end
end

module RuboCop::Cop::Migration; end

class RuboCop::Cop::Migration::DepartmentName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#21
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#47
  def check_cop_name(name, comment, offset); end

  # source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#69
  def contain_unexpected_character_for_department_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#43
  def disable_comment_offset; end

  # source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#73
  def qualified_legacy_cop_name(cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#63
  def valid_content_token?(content_token); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#14
RuboCop::Cop::Migration::DepartmentName::DISABLE_COMMENT_FORMAT = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#19
RuboCop::Cop::Migration::DepartmentName::DISABLING_COPS_CONTENT_TOKEN = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/migration/department_name.rb#12
RuboCop::Cop::Migration::DepartmentName::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::MinBodyLength
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/min_body_length.rb#13
  def min_body_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/min_body_length.rb#9
  def min_body_length?(node); end
end

module RuboCop::Cop::Minitest; end

class RuboCop::Cop::Minitest::AssertEmpty < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_empty.rb#23
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertEmpty::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertEmptyLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_empty_literal.rb#24
  def assert_equal_with_empty_literal(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_empty_literal.rb#28
  def on_send(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_empty_literal.rb#21
RuboCop::Cop::Minitest::AssertEmptyLiteral::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_empty_literal.rb#22
RuboCop::Cop::Minitest::AssertEmptyLiteral::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertEqual < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertEqual::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertEqual::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertInDelta < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::InDeltaMixin
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_in_delta.rb#24
  def equal_floats_call(param0 = T.unsafe(nil)); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_in_delta.rb#22
RuboCop::Cop::Minitest::AssertInDelta::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertIncludes < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertIncludes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertIncludes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertInstanceOf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertInstanceOf::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertInstanceOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertKindOf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertKindOf::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertKindOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertMatch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertMatch::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertMatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  include ::RuboCop::Cop::Minitest::NilAssertionHandleable
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_nil.rb#30
  def nil_assertion(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_nil.rb#38
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_nil.rb#46
  def assertion_type; end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_nil.rb#27
RuboCop::Cop::Minitest::AssertNil::ASSERTION_TYPE = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_nil.rb#28
RuboCop::Cop::Minitest::AssertNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertOutput < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinitestExplorationHelpers

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_output.rb#24
  def on_gvasgn(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_output.rb#38
  def find_test_case(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_output.rb#43
  def references_gvar?(assertion, gvar_name); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_output.rb#21
RuboCop::Cop::Minitest::AssertOutput::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_output.rb#22
RuboCop::Cop::Minitest::AssertOutput::OUTPUT_GLOBAL_VARIABLES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertPathExists < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_path_exists.rb#23
  def assert_file_exists(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_path_exists.rb#30
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_path_exists.rb#44
  def build_good_method(path, message); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_path_exists.rb#20
RuboCop::Cop::Minitest::AssertPathExists::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_path_exists.rb#21
RuboCop::Cop::Minitest::AssertPathExists::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertPredicate < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  include ::RuboCop::Cop::Minitest::PredicateAssertionHandleable
  extend ::RuboCop::Cop::AutoCorrector

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_predicate.rb#28
  def assertion_type; end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_predicate.rb#23
RuboCop::Cop::Minitest::AssertPredicate::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_predicate.rb#24
RuboCop::Cop::Minitest::AssertPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertRaisesCompoundBody < ::RuboCop::Cop::Base
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_raises_compound_body.rb#31
  def on_block(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_raises_compound_body.rb#39
  def multi_statement_begin?(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_raises_compound_body.rb#29
RuboCop::Cop::Minitest::AssertRaisesCompoundBody::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertRaisesWithRegexpArgument < ::RuboCop::Cop::Base
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_raises_with_regexp_argument.rb#30
  def on_send(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_raises_with_regexp_argument.rb#27
RuboCop::Cop::Minitest::AssertRaisesWithRegexpArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_raises_with_regexp_argument.rb#28
RuboCop::Cop::Minitest::AssertRaisesWithRegexpArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertRespondTo < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::AssertRespondTo::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::AssertRespondTo::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertSilent < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_silent.rb#21
  def assert_silent_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_silent.rb#29
  def on_block(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_silent.rb#41
  def empty_string?(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_silent.rb#19
RuboCop::Cop::Minitest::AssertSilent::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertTruthy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_truthy.rb#24
  def assert_equal_with_truthy(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_truthy.rb#28
  def on_send(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_truthy.rb#21
RuboCop::Cop::Minitest::AssertTruthy::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_truthy.rb#22
RuboCop::Cop::Minitest::AssertTruthy::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertWithExpectedArgument < ::RuboCop::Cop::Base
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_with_expected_argument.rb#27
  def assert_with_two_arguments?(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_with_expected_argument.rb#31
  def on_send(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_with_expected_argument.rb#24
RuboCop::Cop::Minitest::AssertWithExpectedArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assert_with_expected_argument.rb#25
RuboCop::Cop::Minitest::AssertWithExpectedArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertionInLifecycleHook < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinitestExplorationHelpers

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assertion_in_lifecycle_hook.rb#28
  def on_class(class_node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/assertion_in_lifecycle_hook.rb#26
RuboCop::Cop::Minitest::AssertionInLifecycleHook::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::DuplicateTestRun < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinitestExplorationHelpers

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/duplicate_test_run.rb#53
  def on_class(class_node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/duplicate_test_run.rb#64
  def parent_class_has_test_methods?(class_node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/duplicate_test_run.rb#78
  def test_methods?(class_node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/duplicate_test_run.rb#51
RuboCop::Cop::Minitest::DuplicateTestRun::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::GlobalExpectations < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#118
  def block_receiver?(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#106
  def on_send(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#122
  def value_receiver?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#126
  def method_allowed?(method); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#130
  def preferred_method; end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#134
  def preferred_receiver(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#145
  def register_offense(node, method); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#99
RuboCop::Cop::Minitest::GlobalExpectations::BLOCK_MATCHERS = T.let(T.unsafe(nil), Array)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#104
RuboCop::Cop::Minitest::GlobalExpectations::DSL_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#88
RuboCop::Cop::Minitest::GlobalExpectations::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#101
RuboCop::Cop::Minitest::GlobalExpectations::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/global_expectations.rb#90
RuboCop::Cop::Minitest::GlobalExpectations::VALUE_MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::LiteralAsActualArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/literal_as_actual_argument.rb#39
  def autocorrect(corrector, node, expected, actual, message); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/literal_as_actual_argument.rb#27
  def on_send(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/literal_as_actual_argument.rb#24
RuboCop::Cop::Minitest::LiteralAsActualArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/literal_as_actual_argument.rb#25
RuboCop::Cop::Minitest::LiteralAsActualArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::MultipleAssertions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::MinitestExplorationHelpers

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/multiple_assertions.rb#35
  def on_class(class_node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/multiple_assertions.rb#52
  def assertions_count(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/multiple_assertions.rb#57
  def max_assertions; end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/multiple_assertions.rb#33
RuboCop::Cop::Minitest::MultipleAssertions::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Minitest::NilAssertionHandleable
  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/nil_assertion_handleable.rb#35
  def autocorrect(corrector, node, actual); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/nil_assertion_handleable.rb#21
  def build_message(node, actual, message); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/nil_assertion_handleable.rb#45
  def comparison_or_predicate_assertion_method?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/nil_assertion_handleable.rb#13
  def register_offense(node, actual, message); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/nil_assertion_handleable.rb#9
RuboCop::Cop::Minitest::NilAssertionHandleable::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::NoAssertions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinitestExplorationHelpers

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/no_assertions.rb#27
  def on_class(class_node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/no_assertions.rb#41
  def assertions_count(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/no_assertions.rb#25
RuboCop::Cop::Minitest::NoAssertions::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Minitest::PredicateAssertionHandleable
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#26
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#11
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#61
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#54
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#46
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#36
  def peel_redundant_parentheses_from(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#42
  def predicate_method?(first_argument); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/predicate_assertion_handleable.rb#9
RuboCop::Cop::Minitest::PredicateAssertionHandleable::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteEmpty < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_empty.rb#23
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::RefuteEmpty::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::RefuteEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteEqual < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#24
  def assert_not_equal(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#28
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#50
  def original_usage(first_part, custom_message); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#46
  def preferred_usage(first_arg, second_arg, custom_message = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#54
  def process_not_equal(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#21
RuboCop::Cop::Minitest::RefuteEqual::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_equal.rb#22
RuboCop::Cop::Minitest::RefuteEqual::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteFalse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#28
  def assert_equal_with_false(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#32
  def assert_with_bang_argument(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#53
  def autocorrect(corrector, node, actual); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#25
RuboCop::Cop::Minitest::RefuteFalse::MSG_FOR_ASSERT = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#24
RuboCop::Cop::Minitest::RefuteFalse::MSG_FOR_ASSERT_EQUAL = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_false.rb#26
RuboCop::Cop::Minitest::RefuteFalse::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteInDelta < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::InDeltaMixin
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_in_delta.rb#24
  def equal_floats_call(param0 = T.unsafe(nil)); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_in_delta.rb#22
RuboCop::Cop::Minitest::RefuteInDelta::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteIncludes < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::RefuteIncludes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::RefuteIncludes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteInstanceOf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::RefuteInstanceOf::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::RefuteInstanceOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteKindOf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::RefuteKindOf::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::RefuteKindOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteMatch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::RefuteMatch::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::RefuteMatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  include ::RuboCop::Cop::Minitest::NilAssertionHandleable
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_nil.rb#30
  def nil_refutation(param0 = T.unsafe(nil)); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_nil.rb#38
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_nil.rb#46
  def assertion_type; end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_nil.rb#27
RuboCop::Cop::Minitest::RefuteNil::ASSERTION_TYPE = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_nil.rb#28
RuboCop::Cop::Minitest::RefuteNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefutePathExists < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_path_exists.rb#30
  def on_send(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_path_exists.rb#23
  def refute_file_exists(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_path_exists.rb#44
  def build_good_method(path, message); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_path_exists.rb#20
RuboCop::Cop::Minitest::RefutePathExists::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_path_exists.rb#21
RuboCop::Cop::Minitest::RefutePathExists::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefutePredicate < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  include ::RuboCop::Cop::Minitest::PredicateAssertionHandleable
  extend ::RuboCop::Cop::AutoCorrector

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_predicate.rb#28
  def assertion_type; end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_predicate.rb#23
RuboCop::Cop::Minitest::RefutePredicate::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/refute_predicate.rb#24
RuboCop::Cop::Minitest::RefutePredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::RefuteRespondTo < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ArgumentRangeHelper
  extend ::RuboCop::Cop::MinitestCopRule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#47
  def autocorrect(corrector, node, arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#36
  def on_send(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#99
  def correct_receiver(receiver); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#95
  def enclosed_in_redundant_parentheses?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#81
  def new_arguments(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#67
  def offense_message(arguments); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#61
  def peel_redundant_parentheses_from(arguments); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#33
RuboCop::Cop::Minitest::RefuteRespondTo::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#34
RuboCop::Cop::Minitest::RefuteRespondTo::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::SkipEnsure < ::RuboCop::Cop::Base
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/skip_ensure.rb#67
  def on_ensure(node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/skip_ensure.rb#77
  def find_skip(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/skip_ensure.rb#81
  def use_skip_in_rescue?(skip_method); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/skip_ensure.rb#85
  def valid_conditional_skip?(skip_method, ensure_node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/skip_ensure.rb#65
RuboCop::Cop::Minitest::SkipEnsure::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::TestMethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinitestExplorationHelpers
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::DefNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/test_method_name.rb#37
  def on_class(class_node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/test_method_name.rb#53
  def class_elements(class_node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/test_method_name.rb#64
  def offense?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/test_method_name.rb#70
  def public?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/test_method_name.rb#74
  def test_method_name?(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/test_method_name.rb#35
RuboCop::Cop::Minitest::TestMethodName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::UnreachableAssertion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinitestExplorationHelpers

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/unreachable_assertion.rb#28
  def on_block(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/unreachable_assertion.rb#26
RuboCop::Cop::Minitest::UnreachableAssertion::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::UnspecifiedException < ::RuboCop::Cop::Base
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/unspecified_exception.rb#20
  def on_block(block_node); end

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/unspecified_exception.rb#29
  def unspecified_exception?(node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/minitest/unspecified_exception.rb#18
RuboCop::Cop::Minitest::UnspecifiedException::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::MinitestCopRule
  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_cop_rule.rb#26
  def define_rule(assertion_method, target_method:, preferred_method: T.unsafe(nil), inverse: T.unsafe(nil)); end
end

module RuboCop::Cop::MinitestExplorationHelpers
  extend ::RuboCop::AST::NodePattern::Macros

  private

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#80
  def assertion_method?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#66
  def assertions(def_node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#51
  def class_def_nodes(class_node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#91
  def lifecycle_hook_method?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#46
  def lifecycle_hooks(class_node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#29
  def test_case?(node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#62
  def test_case_name?(name); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#36
  def test_cases(class_node); end

  # source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#25
  def test_class?(class_node); end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#12
RuboCop::Cop::MinitestExplorationHelpers::ASSERTION_PREFIXES = T.let(T.unsafe(nil), Array)

# source://rubocop-minitest/0.22.2/lib/rubocop/cop/mixin/minitest_exploration_helpers.rb#14
RuboCop::Cop::MinitestExplorationHelpers::LIFECYCLE_HOOK_METHODS = T.let(T.unsafe(nil), Set)

module RuboCop::Cop::MultilineElementIndentation
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#42
  def check_expected_style(styles); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#26
  def check_first(first, left_brace, left_parenthesis, offset); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#80
  def detected_styles(actual_column, offset, left_parenthesis, left_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#85
  def detected_styles_for_column(column, left_parenthesis, left_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#10
  def each_argument_node(node, type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#66
  def hash_pair_where_value_beginning_with(left_brace, first); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#98
  def incorrect_style_detected(styles, first, base_column_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#50
  def indent_base(left_brace, first, left_parenthesis); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#72
  def key_and_value_begin_on_same_line?(pair); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_indentation.rb#76
  def right_sibling_begins_on_subsequent_line?(pair); end
end

module RuboCop::Cop::MultilineElementLineBreaks
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#26
  def all_on_same_line?(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#13
  def check_line_breaks(_node, children); end
end

module RuboCop::Cop::MultilineExpressionIndentation
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#14
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#131
  def argument_in_method_call(node, kind); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#187
  def assignment_rhs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#64
  def check(range, node, lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#54
  def correct_indentation(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#159
  def disqualified_rhs?(candidate, ancestor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#203
  def grouped_expression?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#72
  def incorrect_style_detected(range, node, lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#84
  def indentation(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#121
  def indented_keyword_expression(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#207
  def inside_arg_list_parentheses?(node, ancestor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#98
  def keyword_message_tail(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#106
  def kw_node_with_special_indentation(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#31
  def left_hand_side(lhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#197
  def not_for_this_cop?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#88
  def operation_description(node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#145
  def part_of_assignment_rhs(node, candidate); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#183
  def part_of_block_body?(candidate, block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#216
  def postfix_conditional?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#175
  def valid_method_rhs_candidate?(candidate, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#164
  def valid_rhs?(candidate, ancestor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#179
  def valid_rhs_candidate?(candidate, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#220
  def within_node?(inner, outer); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#11
RuboCop::Cop::MultilineExpressionIndentation::ASSIGNMENT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#10
RuboCop::Cop::MultilineExpressionIndentation::DEFAULT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#8
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#12
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_expression_indentation.rb#9
RuboCop::Cop::MultilineExpressionIndentation::UNALIGNED_RHS_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#15
  def initialize(corrector, node, processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#21
  def call; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#52
  def content_if_comment_present(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#43
  def correct_next_line_brace(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#39
  def correct_same_line_brace(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#37
  def corrector; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#78
  def last_element_range_with_trailing_comma(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#87
  def last_element_trailing_comma_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#37
  def node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#37
  def processed_source; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#74
  def remove_trailing_content_of_comment(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#64
  def select_content_to_be_inserted_after_last_element(corrector, node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#11
    def correct(corrector, node, processed_source); end
  end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#34
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#12
  def check_brace_layout(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#42
  def check_new_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#50
  def check_same_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#58
  def check_symmetrical(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#86
  def children(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#98
  def closing_brace_on_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#74
  def empty_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#82
  def ignored_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#78
  def implicit_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#126
  def last_line_heredoc?(node, parent = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#26
  def new_line_needed_before_closing_brace?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#92
  def opening_brace_on_same_line?(node); end
end

module RuboCop::Cop::Naming; end

class RuboCop::Cop::Naming::AccessorMethodName < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#42
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#42
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#61
  def bad_reader_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#65
  def bad_writer_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#53
  def message(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#39
RuboCop::Cop::Naming::AccessorMethodName::MSG_READER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/accessor_method_name.rb#40
RuboCop::Cop::Naming::AccessorMethodName::MSG_WRITER = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::AsciiIdentifiers < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/ascii_identifiers.rb#59
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/ascii_identifiers.rb#84
  def first_non_ascii_chars(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/ascii_identifiers.rb#74
  def first_offense_range(identifier); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/ascii_identifiers.rb#70
  def should_check?(token); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/ascii_identifiers.rb#57
RuboCop::Cop::Naming::AsciiIdentifiers::CONSTANT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/ascii_identifiers.rb#56
RuboCop::Cop::Naming::AsciiIdentifiers::IDENTIFIER_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::BinaryOperatorParameterName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/binary_operator_parameter_name.rb#29
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/binary_operator_parameter_name.rb#25
  def op_method_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/binary_operator_parameter_name.rb#45
  def op_method?(name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/binary_operator_parameter_name.rb#22
RuboCop::Cop::Naming::BinaryOperatorParameterName::EXCLUDED = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/binary_operator_parameter_name.rb#19
RuboCop::Cop::Naming::BinaryOperatorParameterName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/binary_operator_parameter_name.rb#21
RuboCop::Cop::Naming::BinaryOperatorParameterName::OP_LIKE_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Naming::BlockForwarding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#50
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#50
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#83
  def anonymous_block_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#115
  def block_forwarding_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#69
  def expected_block_forwarding_style?(node, last_argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#87
  def explicit_block_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#91
  def register_offense(block_argument, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#107
  def use_block_argument_as_local_variable?(node, last_argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#79
  def use_kwarg_in_method_definition?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/block_forwarding.rb#48
RuboCop::Cop::Naming::BlockForwarding::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::BlockParameterName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::UncommunicativeName

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/block_parameter_name.rb#41
  def on_block(node); end
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/naming/class_and_module_camel_case.rb#32
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/class_and_module_camel_case.rb#32
  def on_module(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/class_and_module_camel_case.rb#30
RuboCop::Cop::Naming::ClassAndModuleCamelCase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::ConstantName < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#27
  def class_or_struct_return_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#69
  def literal_receiver?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#33
  def on_casgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#56
  def allowed_assignment?(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#74
  def allowed_conditional_expression_on_rhs?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#63
  def allowed_method_call_on_rhs?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#78
  def contains_constant?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#21
RuboCop::Cop::Naming::ConstantName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/constant_name.rb#24
RuboCop::Cop::Naming::ConstantName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Naming::FileName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#56
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#49
  def struct_definition(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#134
  def allowed_acronyms; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#96
  def bad_filename_allowed?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#122
  def check_definition_path_hierarchy?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#169
  def defined_struct(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#126
  def definition_path_hierarchy_roots; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#118
  def expect_matching_definition?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#138
  def filename_good?(basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#147
  def find_class_or_module(node, namespace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#165
  def find_definition(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#65
  def for_bad_filename(file_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#114
  def ignore_executable_scripts?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#202
  def match?(expected); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#206
  def match_acronym?(expected, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#174
  def match_namespace(node, namespace, expected); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#92
  def matching_class?(file_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#88
  def matching_definition?(file_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#100
  def no_definition_message(basename, file_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#106
  def other_message(basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#188
  def partial_matcher!(expected); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#77
  def perform_class_and_module_naming_checks(file_path, basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#130
  def regex; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#240
  def to_module_name(basename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#213
  def to_namespace(path); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#43
RuboCop::Cop::Naming::FileName::MSG_NO_DEFINITION = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#44
RuboCop::Cop::Naming::FileName::MSG_REGEX = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#42
RuboCop::Cop::Naming::FileName::MSG_SNAKE_CASE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/file_name.rb#46
RuboCop::Cop::Naming::FileName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Naming::HeredocDelimiterCase < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_case.rb#37
  def on_heredoc(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_case.rb#54
  def correct_case_delimiters?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_case.rb#58
  def correct_delimiters(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_case.rb#50
  def message(_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_case.rb#35
RuboCop::Cop::Naming::HeredocDelimiterCase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::HeredocDelimiterNaming < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#31
  def on_heredoc(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#49
  def forbidden_delimiters; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#39
  def meaningful_delimiters?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#29
RuboCop::Cop::Naming::HeredocDelimiterNaming::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::InclusiveLanguage < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#78
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#87
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#105
  def add_offenses_for_token(token, word_locations); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#154
  def add_to_flagged_term_hash(regex_string, term, term_definition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#180
  def array_to_ignorecase_regex(strings); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#113
  def check_token?(type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#228
  def create_message(word, message = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#205
  def create_multiple_word_message_for_file(words); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#201
  def create_single_word_message_for_file(word); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#176
  def ensure_regex_string(regex); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#147
  def extract_regexp(term, term_definition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#236
  def find_flagged_term(word); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#250
  def format_suggestions(suggestions); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#184
  def investigate_filepath; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#94
  def investigate_tokens; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#216
  def mask_input(str); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#117
  def preprocess_check_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#131
  def preprocess_flagged_terms; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#243
  def preprocess_suggestions(suggestions); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#166
  def process_allowed_regex(allowed); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#209
  def scan_for_words(input); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#161
  def set_regexes(flagged_term_strings, allowed_strings); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#72
RuboCop::Cop::Naming::InclusiveLanguage::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#73
RuboCop::Cop::Naming::InclusiveLanguage::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/inclusive_language.rb#74
RuboCop::Cop::Naming::InclusiveLanguage::MSG_FOR_FILE_PATH = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation < ::Struct
  def position; end
  def position=(_); end
  def word; end
  def word=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#189
  def defined_memoized?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#157
  def method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#197
  def on_defined?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#166
  def on_or_asgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#227
  def find_definition(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#238
  def matches?(method_name, ivar_assign); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#248
  def message(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#223
  def style_parameter_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#256
  def suggested_var(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#262
  def variable_name_candidates(method_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#154
RuboCop::Cop::Naming::MemoizedInstanceVariableName::DYNAMIC_DEFINE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#150
RuboCop::Cop::Naming::MemoizedInstanceVariableName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/naming/memoized_instance_variable_name.rb#152
RuboCop::Cop::Naming::MemoizedInstanceVariableName::UNDERSCORE_REQUIRED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::MethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#55
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#55
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#44
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#42
  def str_name(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#39
  def sym_name(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#64
  def attr_name(name_item); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#75
  def message(style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#68
  def range_position(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/method_name.rb#36
RuboCop::Cop::Naming::MethodName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::MethodParameterName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::UncommunicativeName

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_parameter_name.rb#49
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/method_parameter_name.rb#49
  def on_defs(node); end
end

class RuboCop::Cop::Naming::PredicateName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#63
  def dynamic_method_define(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#82
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#82
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#69
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#98
  def allowed_method_name?(method_name, prefix); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#106
  def expected_name(method_name, prefix); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#120
  def forbidden_prefixes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#116
  def message(method_name, new_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#128
  def method_definition_macros(macro_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/predicate_name.rb#124
  def predicate_prefixes; end
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#66
  def on_resbody(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#108
  def correct_node(corrector, node, offending_name, preferred_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#126
  def correct_reassignment(corrector, node, offending_name, preferred_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#151
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#93
  def offense_range(resbody); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#135
  def preferred_name(variable_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#157
  def shadowed_variable_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#144
  def variable_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#98
  def variable_name_matches?(node, name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#64
RuboCop::Cop::Naming::RescuedExceptionsVariableName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::VariableName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_arg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_blockarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_kwarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_kwoptarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_kwrestarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_lvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_optarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#37
  def on_restarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#33
  def valid_name?(node, name, given_style = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#57
  def message(style); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_name.rb#31
RuboCop::Cop::Naming::VariableName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::VariableNumber < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#114
  def on_arg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#114
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#126
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#126
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#114
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#114
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#114
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#134
  def on_sym(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#110
  def valid_name?(node, name, given_style = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#143
  def message(style); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/naming/variable_number.rb#108
RuboCop::Cop::Naming::VariableNumber::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/negative_conditional.rb#18
  def empty_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/negative_conditional.rb#15
  def single_negative?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/negative_conditional.rb#20
  def check_negative_conditional(node, message:, &block); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/negative_conditional.rb#10
RuboCop::Cop::NegativeConditional::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/nil_methods.rb#14
  def nil_methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/nil_methods.rb#18
  def other_stdlib_methods; end
end

class RuboCop::Cop::Offense
  include ::Comparable

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#84
  def initialize(severity, location, message, cop_name, status = T.unsafe(nil), corrector = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#230
  def <=>(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#211
  def ==(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#160
  def column; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#170
  def column_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#194
  def column_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#51
  def cop_name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#102
  def correctable?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#113
  def corrected?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#123
  def corrected_with_todo?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#62
  def corrector; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#134
  def disabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#211
  def eql?(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#179
  def first_line; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#219
  def hash; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#142
  def highlighted_area; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#189
  def last_column; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#184
  def last_line; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#155
  def line; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#28
  def location; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#39
  def message; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#203
  def real_column; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#17
  def severity; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#165
  def source_line; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#54
  def status; end

  # source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#148
  def to_s; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#10
RuboCop::Cop::Offense::COMPARISON_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/offense.rb#81
RuboCop::Cop::Offense::NO_LOCATION = T.let(T.unsafe(nil), RuboCop::Cop::Offense::PseudoSourceRange)

module RuboCop::Cop::OnNormalIfUnless
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/on_normal_if_unless.rb#7
  def on_if(node); end
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/ordered_gem_corrector.rb#11
    def comments_as_separators; end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/ordered_gem_corrector.rb#13
    def correct(processed_source, node, previous_declaration, comments_as_separators); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/ordered_gem_corrector.rb#11
    def processed_source; end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/ordered_gem_corrector.rb#26
    def declaration_with_comment(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/ordered_gem_corrector.rb#36
    def swap_range(corrector, range1, range2); end
  end
end

module RuboCop::Cop::OrderedGemNode
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#23
  def case_insensitive_out_of_order?(string_a, string_b); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#27
  def consecutive_lines(previous, current); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#55
  def find_gem_name(gem_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#18
  def gem_canonical_name(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#49
  def gem_name(declaration_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#10
  def get_source_range(node, comments_as_separators); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#32
  def register_offense(previous, current); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/ordered_gem_node.rb#61
  def treat_comments_as_separators; end
end

module RuboCop::Cop::Packaging; end

class RuboCop::Cop::Packaging::BundlerSetupInTests < ::RuboCop::Cop::Base
  include ::RuboCop::Packaging::LibHelperModule
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#57
  def autocorrect(corrector, node); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#29
  def bundler_setup?(param0 = T.unsafe(nil)); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#66
  def bundler_setup_in_test_dir?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#71
  def falls_in_test_dir?; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#39
  def on_new_investigation; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#47
  def on_send(node); end
end

# source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/bundler_setup_in_tests.rb#27
RuboCop::Cop::Packaging::BundlerSetupInTests::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Packaging::GemspecGit < ::RuboCop::Cop::Base
  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/gemspec_git.rb#70
  def on_new_investigation; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/gemspec_git.rb#83
  def starts_with_git?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/gemspec_git.rb#56
  def xstr(param0); end
end

# source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/gemspec_git.rb#51
RuboCop::Cop::Packaging::GemspecGit::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Packaging::RequireHardcodingLib < ::RuboCop::Cop::Base
  include ::RuboCop::Packaging::LibHelperModule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#85
  def falls_in_lib?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#93
  def falls_in_lib_using_file?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#100
  def falls_in_lib_with_file_dirname_plus_str?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#77
  def good_require_call; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#59
  def on_new_investigation; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#67
  def on_send(node); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#46
  def require?(param0 = T.unsafe(nil)); end
end

# source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_hardcoding_lib.rb#43
RuboCop::Cop::Packaging::RequireHardcodingLib::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Packaging::RequireRelativeHardcodingLib < ::RuboCop::Cop::Base
  include ::RuboCop::Packaging::LibHelperModule
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_relative_hardcoding_lib.rb#75
  def falls_in_lib?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_relative_hardcoding_lib.rb#67
  def good_require_call; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_relative_hardcoding_lib.rb#49
  def on_new_investigation; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_relative_hardcoding_lib.rb#57
  def on_send(node); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_relative_hardcoding_lib.rb#39
  def require_relative(param0 = T.unsafe(nil)); end
end

# source://rubocop-packaging/0.5.2/lib/rubocop/cop/packaging/require_relative_hardcoding_lib.rb#36
RuboCop::Cop::Packaging::RequireRelativeHardcodingLib::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Parentheses
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/parentheses.rb#9
  def parens_required?(node); end
end

class RuboCop::Cop::ParenthesesCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#12
    def correct(corrector, node); end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#74
    def add_heredoc_comma(corrector, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#64
    def extend_range_for_heredoc(node, range); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#41
    def handle_orphaned_comma(corrector, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#80
    def heredoc?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#28
    def next_char_is_question_mark?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#32
    def only_closing_paren_before_comma?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#51
    def parens_range(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/parentheses_corrector.rb#24
    def ternary_condition?(node); end
  end
end

module RuboCop::Cop::PercentArray
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#26
  def allowed_bracket_array?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#83
  def build_bracketed_array_with_appropriate_whitespace(elements:, node:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#56
  def build_message_for_bracketed_array(preferred_array_code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#67
  def check_bracketed_array(node, literal_prefix); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#36
  def check_percent_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#31
  def comments_in_array?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#22
  def invalid_percent_array_contents?(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#14
  def invalid_percent_array_context?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#98
  def whitespace_between(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#113
  def whitespace_leading(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_array.rb#122
  def whitespace_trailing(node); end
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_literal.rb#23
  def begin_source(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_literal.rb#11
  def percent_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_literal.rb#17
  def process(node, *types); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/percent_literal.rb#27
  def type(node); end
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#11
  def initialize(config, preferred_delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#9
  def config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#16
  def correct(corrector, node, char); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#9
  def preferred_delimiters; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#46
  def autocorrect_multiline_words(node, escape, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#52
  def autocorrect_words(node, escape, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#34
  def delimiters_for(type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#100
  def end_content(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#30
  def escape_words?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#78
  def first_line?(node, previous_line_num); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#89
  def fix_escaped_content(word_node, escape, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#69
  def line_breaks(node, source, previous_line_num, base_line_num, node_indx); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#38
  def new_contents(node, escape, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#82
  def process_lines(node, previous_line_num, base_line_num, source_in_lines); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#58
  def process_multiline_words(node, escape, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#96
  def substitute_escaped_delimiters(content, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/correctors/percent_literal_corrector.rb#26
  def wrap_contents(corrector, node, contents, char, delimiters); end
end

module RuboCop::Cop::PrecedingFollowingAlignment
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#95
  def aligned_assignment?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#91
  def aligned_char?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#70
  def aligned_comment_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#107
  def aligned_identical?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#83
  def aligned_operator?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#77
  def aligned_token?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#34
  def aligned_with_adjacent_line?(range, predicate); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#52
  def aligned_with_any_line?(line_ranges, range, indent = T.unsafe(nil), &predicate); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#42
  def aligned_with_any_line_range?(line_ranges, range, &predicate); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#100
  def aligned_with_append_operator?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#111
  def aligned_with_assignment(token, line_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#56
  def aligned_with_line?(line_nos, range, indent = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#18
  def aligned_with_operator?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#22
  def aligned_with_preceding_assignment(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#14
  def aligned_with_something?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#28
  def aligned_with_subsequent_assignment(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#87
  def aligned_words?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#10
  def allow_for_alignment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#129
  def assignment_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#133
  def assignment_tokens; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#149
  def relevant_assignment_lines(line_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preceding_following_alignment.rb#176
  def remove_optarg_equals(asgn_tokens, processed_source); end
end

class RuboCop::Cop::PreferredDelimiters
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#11
  def initialize(type, config, preferred_delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#7
  def config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#17
  def delimiters; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#7
  def type; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#23
  def ensure_valid_preferred_delimiters; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#30
  def preferred_delimiters; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#45
  def preferred_delimiters_config; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/preferred_delimiters.rb#9
RuboCop::Cop::PreferredDelimiters::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::PunctuationCorrector
  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/punctuation_corrector.rb#12
    def add_space(corrector, token); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/punctuation_corrector.rb#8
    def remove_space(corrector, space_before); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/punctuation_corrector.rb#16
    def swap_comma(corrector, range); end
  end
end

module RuboCop::Cop::RangeHelp
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#82
  def column_offset_between(base_range, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#32
  def contents_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#100
  def directions(side); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#92
  def effective_column(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#109
  def final_pos(src, pos, increment, continuations, newlines, whitespace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#117
  def move_pos(src, pos, step, condition, regexp); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#123
  def move_pos_str(src, pos, step, condition, needle); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#36
  def range_between(start_pos, end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#73
  def range_by_whole_lines(range, include_final_newline: T.unsafe(nil), buffer: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#40
  def range_with_surrounding_comma(range, side = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#55
  def range_with_surrounding_space(range_positional = T.unsafe(nil), range: T.unsafe(nil), side: T.unsafe(nil), newlines: T.unsafe(nil), whitespace: T.unsafe(nil), continuations: T.unsafe(nil), buffer: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#11
  def source_range(source_buffer, line_number, column, length = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/range_help.rb#9
RuboCop::Cop::RangeHelp::BYTE_ORDER_MARK = T.let(T.unsafe(nil), Integer)

module RuboCop::Cop::RangeHelp::NOT_GIVEN; end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/rational_literal.rb#12
  def rational_literal?(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Registry
  include ::Enumerable

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#24
  def initialize(cops = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#183
  def ==(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#67
  def contains_cop_matching?(names); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#142
  def cops; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#63
  def department?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#117
  def department_missing?(badge, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#42
  def departments; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#37
  def dismiss(cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#198
  def each(&block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#152
  def enabled(config, only = T.unsafe(nil), only_safe: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#156
  def enabled?(cop, config, only_safe); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#168
  def enabled_pending_cop?(cop_cfg, config); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#33
  def enlist(cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#204
  def find_by_cop_name(cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#208
  def freeze; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#147
  def length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#175
  def names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#179
  def names_for_department(department); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#22
  def options; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#121
  def print_warning(name, path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#103
  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#194
  def select(&block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#187
  def sort!; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#137
  def to_h; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#129
  def unqualified_cop_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#48
  def with_department(department); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#54
  def without_department(department); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#248
  def clear_enrollment_queue; end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#244
  def initialize_copy(reg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#264
  def qualify_badge(badge); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#281
  def registered?(badge); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#271
  def resolve_badge(given_badge, real_badge, source_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#260
  def with(cops); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#220
    def all; end

    # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#217
    def global; end

    # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#224
    def qualified_cop_name(name, origin); end

    # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#238
    def reset!; end

    # source://rubocop/1.36.0/lib/rubocop/cop/registry.rb#230
    def with_temporary_global(temp_global = T.unsafe(nil)); end
  end
end

module RuboCop::Cop::RequireLibrary
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/require_library.rb#10
  def ensure_required(corrector, node, library_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/require_library.rb#31
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/require_library.rb#22
  def remove_subsequent_requires(corrector, node, library_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/require_library.rb#49
  def require_any_library?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/require_library.rb#54
  def require_library_name?(param0 = T.unsafe(nil), param1); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/require_library.rb#42
  def on_new_investigation; end
end

class RuboCop::Cop::RequireLibraryCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/require_library_corrector.rb#11
    def correct(corrector, node, library_name); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/require_library_corrector.rb#17
    def require_statement(library_name); end
  end
end

module RuboCop::Cop::RescueNode
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/rescue_node.rb#7
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/rescue_node.rb#13
  def rescue_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/rescue_node.rb#18
  def rescued_exceptions(resbody); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/safe_assignment.rb#14
  def empty_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/safe_assignment.rb#20
  def safe_assignment?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/safe_assignment.rb#17
  def setter_method?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/safe_assignment.rb#22
  def safe_assignment_allowed?; end
end

module RuboCop::Cop::Security; end

class RuboCop::Cop::Security::CompoundHash < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#57
  def bad_hash_combinator?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#74
  def contained_in_hash_method?(node, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#41
  def dynamic_hash_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#36
  def hash_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#62
  def monuple_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#86
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#86
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#80
  def outer_bad_hash_combinator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#67
  def redundant_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#50
  def static_hash_method_definition?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#30
RuboCop::Cop::Security::CompoundHash::COMBINATOR_IN_HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#31
RuboCop::Cop::Security::CompoundHash::MONUPLE_HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/compound_hash.rb#33
RuboCop::Cop::Security::CompoundHash::REDUNDANT_HASH_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Security::Eval < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/security/eval.rb#19
  def eval?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/eval.rb#23
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/eval.rb#15
RuboCop::Cop::Security::Eval::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/eval.rb#16
RuboCop::Cop::Security::Eval::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::IoMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/security/io_methods.rb#36
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/io_methods.rb#33
RuboCop::Cop::Security::IoMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/io_methods.rb#34
RuboCop::Cop::Security::IoMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::JSONLoad < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/security/json_load.rb#33
  def json_load(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/json_load.rb#37
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/json_load.rb#29
RuboCop::Cop::Security::JSONLoad::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/json_load.rb#30
RuboCop::Cop::Security::JSONLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::MarshalLoad < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/security/marshal_load.rb#26
  def marshal_load(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/marshal_load.rb#31
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/marshal_load.rb#22
RuboCop::Cop::Security::MarshalLoad::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/marshal_load.rb#23
RuboCop::Cop::Security::MarshalLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::Open < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#46
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#42
  def open?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#75
  def composite_string?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#83
  def concatenated_string?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#79
  def interpolated_string?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#57
  def safe?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#67
  def safe_argument?(argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#71
  def simple_string?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#38
RuboCop::Cop::Security::Open::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/open.rb#39
RuboCop::Cop::Security::Open::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::YAMLLoad < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/security/yaml_load.rb#37
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/security/yaml_load.rb#33
  def yaml_load(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/security/yaml_load.rb#29
RuboCop::Cop::Security::YAMLLoad::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/security/yaml_load.rb#30
RuboCop::Cop::Security::YAMLLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Severity
  include ::Comparable

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#30
  def initialize(name_or_code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#62
  def <=>(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#50
  def ==(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#42
  def code; end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#58
  def hash; end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#46
  def level; end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#22
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#38
  def to_s; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#24
    def name_from_code(code); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#12
RuboCop::Cop::Severity::CODE_TABLE = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/severity.rb#9
RuboCop::Cop::Severity::NAMES = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::Sorbet; end

# This cop disallows using `.override(allow_incompatible: true)`.
# Using `allow_incompatible` suggests a violation of the Liskov
# Substitution Principle, meaning that a subclass is not a valid
# subtype of it's superclass. This Cop prevents these design smells
# from occurring.
#
# @example
#
#   # bad
#   sig.override(allow_incompatible: true)
#
#   # good
#   sig.override
class RuboCop::Cop::Sorbet::AllowIncompatibleOverride < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/allow_incompatible_override.rb#35
  def allow_incompatible?(param0); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/allow_incompatible_override.rb#39
  def allow_incompatible_override?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/allow_incompatible_override.rb#31
  def not_nil?(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/allow_incompatible_override.rb#48
  def on_send(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/allow_incompatible_override.rb#22
  def sig?(param0); end
end

# This cop disallows binding the return value of `T.any`, `T.all`, `T.enum`
# to a constant directly. To bind the value, one must use `T.type_alias`.
#
# @example
#
#   # bad
#   FooOrBar = T.any(Foo, Bar)
#
#   # good
#   FooOrBar = T.type_alias { T.any(Foo, Bar) }
class RuboCop::Cop::Sorbet::BindingConstantWithoutTypeAlias < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#116
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#19
  def binding_unaliased_type?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#51
  def dynamic_type_creation_with_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#66
  def generic_parameter_decl_block_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#60
  def generic_parameter_decl_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#72
  def method_needing_aliasing_on_t?(param0); end

  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#85
  def not_dynamic_type_creation_with_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#89
  def not_generic_parameter_decl?(node); end

  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#93
  def not_nil?(node); end

  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#81
  def not_t_let?(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#97
  def on_casgn(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#41
  def t_let?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#32
  def using_deprecated_type_alias_syntax?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/binding_constants_without_type_alias.rb#23
  def using_type_alias?(param0 = T.unsafe(nil)); end
end

# This cop ensures that callback conditionals are bound to the right type
# so that they are type checked properly.
#
# Auto-correction is unsafe because other libraries define similar style callbacks as Rails, but don't always need
# binding to the attached class. Auto-correcting those usages can lead to false positives and auto-correction
# introduces new typing errors.
#
# @example
#
#   # bad
#   class Post < ApplicationRecord
#   before_create :do_it, if: -> { should_do_it? }
#
#   def should_do_it?
#   true
#   end
#   end
#
#   # good
#   class Post < ApplicationRecord
#   before_create :do_it, if: -> {
#   T.bind(self, Post)
#   should_do_it?
#   }
#
#   def should_do_it?
#   true
#   end
#   end
class RuboCop::Cop::Sorbet::CallbackConditionalsBinding < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/callback_conditionals_binding.rb#47
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/callback_conditionals_binding.rb#99
  def on_send(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/callback_conditionals_binding.rb#36
RuboCop::Cop::Sorbet::CallbackConditionalsBinding::CALLBACKS = T.let(T.unsafe(nil), Array)

# This cop disallows the usage of `checked(true)`. This usage could cause
# confusion; it could lead some people to believe that a method would be checked
# even if runtime checks have not been enabled on the class or globally.
# Additionally, in the event where checks are enabled, `checked(true)` would
# be redundant; only `checked(false)` or `soft` would change the behaviour.
#
# @example
#
#   # bad
#   sig { void.checked(true) }
#
#   # good
#   sig { void }
class RuboCop::Cop::Sorbet::CheckedTrueInSignature < ::RuboCop::Cop::Sorbet::SignatureCop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/checked_true_in_signature.rb#25
  def offending_node(param0); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/checked_true_in_signature.rb#36
  def on_signature(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/checked_true_in_signature.rb#29
RuboCop::Cop::Sorbet::CheckedTrueInSignature::MESSAGE = T.let(T.unsafe(nil), String)

# This cop disallows the calls that are used to get constants fom Strings
# such as +constantize+, +const_get+, and +constants+.
#
# The goal of this cop is to make the code easier to statically analyze,
# more IDE-friendly, and more predictable. It leads to code that clearly
# expresses which values the constant can have.
#
# @example
#
#   # bad
#   class_name.constantize
#
#   # bad
#   constants.detect { |c| c.name == "User" }
#
#   # bad
#   const_get(class_name)
#
#   # good
#   case class_name
#   when "User"
#   User
#   else
#   raise ArgumentError
#   end
#
#   # good
#   { "User" => User }.fetch(class_name)
class RuboCop::Cop::Sorbet::ConstantsFromStrings < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/constants_from_strings.rb#37
  def constant_from_string?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/constants_from_strings.rb#41
  def on_send(node); end
end

# This cop checks that the Sorbet sigil comes as the first magic comment in the file.
#
# The expected order for magic comments is: typed, (en)?coding, warn_indent then frozen_string_literal.
#
# For example, the following bad ordering:
#
# ```ruby
# class Foo; end
# ```
#
# Will be corrected as:
#
# ```ruby
# class Foo; end
# ```
#
# Only `typed`, `(en)?coding`, `warn_indent` and `frozen_string_literal` magic comments are considered,
# other comments or magic comments are left in the same place.
class RuboCop::Cop::Sorbet::EnforceSigilOrder < ::RuboCop::Cop::Sorbet::ValidSigil
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#42
  def autocorrect(_node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#33
  def investigate(processed_source); end

  protected

  # checks
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#91
  def check_magic_comments_order(tokens); end

  # Get all the tokens in `processed_source` that match `MAGIC_REGEX`
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#83
  def extract_magic_comments(processed_source); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#67
RuboCop::Cop::Sorbet::EnforceSigilOrder::CODING_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#69
RuboCop::Cop::Sorbet::EnforceSigilOrder::FROZEN_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#68
RuboCop::Cop::Sorbet::EnforceSigilOrder::INDENT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#78
RuboCop::Cop::Sorbet::EnforceSigilOrder::MAGIC_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_sigil_order.rb#71
RuboCop::Cop::Sorbet::EnforceSigilOrder::PREFERRED_ORDER = T.let(T.unsafe(nil), Hash)

# This cop checks that every method definition and attribute accessor has a Sorbet signature.
#
# It also suggest an autocorrect with placeholders so the following code:
#
# ```
# def foo(a, b, c); end
# ```
#
# Will be corrected as:
#
# ```
# sig { params(a: T.untyped, b: T.untyped, c: T.untyped).returns(T.untyped)
# def foo(a, b, c); end
# ```
#
# You can configure the placeholders used by changing the following options:
#
# * `ParameterTypePlaceholder`: placeholders used for parameter types (default: 'T.untyped')
# * `ReturnTypePlaceholder`: placeholders used for return types (default: 'T.untyped')
class RuboCop::Cop::Sorbet::EnforceSignatures < ::RuboCop::Cop::Sorbet::SignatureCop
  # @return [EnforceSignatures] a new instance of EnforceSignatures
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#30
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#35
  def accessor?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#55
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#39
  def on_def(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#43
  def on_defs(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#47
  def on_send(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#51
  def on_signature(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#74
  def scope(node); end

  private

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#82
  def check_node(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#93
  def param_type_placeholder; end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#97
  def return_type_placeholder; end
end

class RuboCop::Cop::Sorbet::EnforceSignatures::SigSuggestion
  # @return [SigSuggestion] a new instance of SigSuggestion
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#104
  def initialize(indent, param_placeholder, return_placeholder); end

  # Returns the value of attribute params.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#102
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#102
  def params=(_arg0); end

  # Returns the value of attribute returns.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#102
  def returns; end

  # Sets the attribute returns
  #
  # @param value the value to set the attribute returns to.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#102
  def returns=(_arg0); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#112
  def to_autocorrect; end

  private

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#124
  def generate_params; end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/enforce_signatures.rb#135
  def generate_return; end
end

# This cop checks that there is only one Sorbet sigil in a given file
#
# For example, the following class with two sigils
#
# ```ruby
# class Foo; end
# ```
#
# Will be corrected as:
#
# ```ruby
# class Foo; end
# ```
#
# Other comments or magic comments are left in place.
class RuboCop::Cop::Sorbet::EnforceSingleSigil < ::RuboCop::Cop::Sorbet::ValidSigil
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_single_sigil.rb#39
  def autocorrect(_node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_single_sigil.rb#29
  def investigate(processed_source); end

  protected

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/enforce_single_sigil.rb#55
  def extract_all_sigils(processed_source); end
end

# This cop makes the Sorbet `false` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::FalseSigil < ::RuboCop::Cop::Sorbet::HasSigil
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/false_sigil.rb#11
  def minimum_strictness; end
end

# This cop ensures RBI shims do not include a call to extend T::Sig
# or to extend T::Helpers
#
# @example
#
#   # bad
#   module SomeModule
#   extend T::Sig
#   extend T::Helpers
#
#   sig { returns(String) }
#   def foo; end
#   end
#
#   # good
#   module SomeModule
#   sig { returns(String) }
#   def foo; end
#   end
class RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_extend_t_sig_helpers_in_shims.rb#39
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_extend_t_sig_helpers_in_shims.rb#35
  def extend_t_helpers?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_extend_t_sig_helpers_in_shims.rb#31
  def extend_t_sig?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_extend_t_sig_helpers_in_shims.rb#47
  def on_send(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_extend_t_sig_helpers_in_shims.rb#28
RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_extend_t_sig_helpers_in_shims.rb#29
RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral < ::RuboCop::Cop::Cop
  # @return [ForbidIncludeConstLiteral] a new instance of ForbidIncludeConstLiteral
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#40
  def initialize(*_arg0); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#56
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#34
  def not_lit_const_include?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#45
  def on_send(node); end

  # Returns the value of attribute used_names.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#32
  def used_names; end

  # Sets the attribute used_names
  #
  # @param value the value to set the attribute used_names to.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#32
  def used_names=(_arg0); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_include_const_literal.rb#30
RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral::MSG = T.let(T.unsafe(nil), String)

# This cop makes sure that RBI files are always located under the defined allowed paths.
#
# Options:
#
# * `AllowedPaths`: A list of the paths where RBI files are allowed (default: ["sorbet/rbi/**"])
#
# @example
#   # bad
#   # lib/some_file.rbi
#   # other_file.rbi
#
#   # good
#   # sorbet/rbi/some_file.rbi
#   # sorbet/rbi/any/path/for/file.rbi
class RuboCop::Cop::Sorbet::ForbidRBIOutsideOfAllowedPaths < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_rbi_outside_of_allowed_paths.rb#25
  def investigate(processed_source); end

  private

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/forbid_rbi_outside_of_allowed_paths.rb#57
  def allowed_paths; end
end

class RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_superclass_const_literal.rb#30
  def not_lit_const_superclass?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_superclass_const_literal.rb#38
  def on_class(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_superclass_const_literal.rb#28
RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral::MSG = T.let(T.unsafe(nil), String)

# This cop disallows using `T.unsafe` anywhere.
#
# @example
#
#   # bad
#   T.unsafe(foo)
#
#   # good
#   foo
class RuboCop::Cop::Sorbet::ForbidTUnsafe < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_t_unsafe.rb#20
  def on_send(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_t_unsafe.rb#18
  def t_unsafe?(param0 = T.unsafe(nil)); end
end

# This cop disallows using `T.untyped` anywhere.
#
# @example
#
#   # bad
#   sig { params(my_argument: T.untyped).void }
#   def foo(my_argument); end
#
#   # good
#   sig { params(my_argument: String).void }
#   def foo(my_argument); end
class RuboCop::Cop::Sorbet::ForbidTUntyped < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_t_untyped.rb#23
  def on_send(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_t_untyped.rb#21
  def t_untyped?(param0 = T.unsafe(nil)); end
end

# This cop disallows use of `T.untyped` or `T.nilable(T.untyped)`
# as a prop type for `T::Struct`.
#
# @example
#
#   # bad
#   class SomeClass
#   const :foo, T.untyped
#   prop :bar, T.nilable(T.untyped)
#   end
#
#   # good
#   class SomeClass
#   const :foo, Integer
#   prop :bar, T.nilable(String)
#   end
class RuboCop::Cop::Sorbet::ForbidUntypedStructProps < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#48
  def on_class(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#40
  def subclass_of_t_struct?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#36
  def t_nilable_untyped(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#28
  def t_struct(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#32
  def t_untyped(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#44
  def untyped_props(param0); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/forbid_untyped_struct_props.rb#26
RuboCop::Cop::Sorbet::ForbidUntypedStructProps::MSG = T.let(T.unsafe(nil), String)

# This cop makes the Sorbet typed sigil mandatory in all files.
#
# Options:
#
# * `SuggestedStrictness`: Sorbet strictness level suggested in offense messages (default: 'false')
# * `MinimumStrictness`: If set, make offense if the strictness level in the file is below this one
#
# If a `MinimumStrictness` level is specified, it will be used in offense messages and autocorrect.
class RuboCop::Cop::Sorbet::HasSigil < ::RuboCop::Cop::Sorbet::ValidSigil
  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/has_sigil.rb#20
  def require_sigil_on_all_files?; end
end

# This cop makes the Sorbet `ignore` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::IgnoreSigil < ::RuboCop::Cop::Sorbet::HasSigil
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/ignore_sigil.rb#11
  def minimum_strictness; end
end

# This cop checks for the ordering of keyword arguments required by
# sorbet-runtime. The ordering requires that all keyword arguments
# are at the end of the parameters list, and all keyword arguments
# with a default value must be after those without default values.
#
# @example
#
#   # bad
#   sig { params(a: Integer, b: String).void }
#   def foo(a: 1, b:); end
#
#   # good
#   sig { params(b: String, a: Integer).void }
#   def foo(b:, a: 1); end
class RuboCop::Cop::Sorbet::KeywordArgumentOrdering < ::RuboCop::Cop::Sorbet::SignatureCop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/keyword_argument_ordering.rb#24
  def on_signature(node); end

  private

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/keyword_argument_ordering.rb#34
  def check_order_for_kwoptargs(parameters); end
end

module RuboCop::Cop::Sorbet::MutableConstantSorbetAwareBehaviour
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/mutable_constant_sorbet_aware_behaviour.rb#15
  def on_assignment(value); end

  class << self
    # source://rubocop-sorbet//lib/rubocop/cop/sorbet/mutable_constant_sorbet_aware_behaviour.rb#9
    def prepended(base); end
  end
end

# This cop ensures one ancestor per requires_ancestor line
# rather than chaining them as a comma-separated list.
#
# @example
#
#   # bad
#   module SomeModule
#   requires_ancestor Kernel, Minitest::Assertions
#   end
#
#   # good
#   module SomeModule
#   requires_ancestor Kernel
#   requires_ancestor Minitest::Assertions
#   end
class RuboCop::Cop::Sorbet::OneAncestorPerLine < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#35
  def abstract?(param0); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#51
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#31
  def more_than_one_ancestor(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#45
  def on_class(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#39
  def on_module(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#27
  def requires_ancestors(param0); end

  private

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#67
  def new_ra_line(indent_count); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#61
  def process_node(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/one_ancestor_per_line.rb#25
RuboCop::Cop::Sorbet::OneAncestorPerLine::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Sorbet::SignatureBuildOrder < ::RuboCop::Cop::Sorbet::SignatureCop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#54
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#34
  def on_signature(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#30
  def root_call(param0); end

  private

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#96
  def call_chain(sig_child_node); end

  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#92
  def can_autocorrect?; end

  # This method exists to reparse the current node with modern features enabled.
  # Modern features include "index send" emitting, which is necessary to unparse
  # "index sends" (i.e. `[]` calls) back to index accessors (i.e. as `foo[bar]``).
  # Otherwise, we would get the unparsed node as `foo.[](bar)`.
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#83
  def node_reparsed_with_modern_features(node); end
end

# Create a subclass of AST Builder that has modern features turned on
class RuboCop::Cop::Sorbet::SignatureBuildOrder::ModernBuilder < ::RuboCop::AST::Builder; end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_build_order.rb#16
RuboCop::Cop::Sorbet::SignatureBuildOrder::ORDER = T.let(T.unsafe(nil), Hash)

# Abstract cop specific to Sorbet signatures
#
# You can subclass it to use the `on_signature` trigger and the `signature?` node matcher.
class RuboCop::Cop::Sorbet::SignatureCop < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_cop.rb#26
  def allowed_recv(recv); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_cop.rb#33
  def on_block(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_cop.rb#37
  def on_signature(_); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_cop.rb#14
  def signature?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_cop.rb#18
  def with_runtime?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/signatures/signature_cop.rb#22
  def without_runtime?(param0 = T.unsafe(nil)); end
end

# This cop ensures empty class/module definitions in RBI files are
# done on a single line rather than being split across multiple lines.
#
# @example
#
#   # bad
#   module SomeModule
#   end
#
#   # good
#   module SomeModule; end
class RuboCop::Cop::Sorbet::SingleLineRbiClassModuleDefinitions < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/single_line_rbi_class_module_definitions.rb#28
  def autocorrect(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/single_line_rbi_class_module_definitions.rb#24
  def on_class(node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/single_line_rbi_class_module_definitions.rb#20
  def on_module(node); end

  protected

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/single_line_rbi_class_module_definitions.rb#34
  def convert_newlines(source); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/single_line_rbi_class_module_definitions.rb#38
  def process_node(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/rbi/single_line_rbi_class_module_definitions.rb#18
RuboCop::Cop::Sorbet::SingleLineRbiClassModuleDefinitions::MSG = T.let(T.unsafe(nil), String)

# This cop makes the Sorbet `strict` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::StrictSigil < ::RuboCop::Cop::Sorbet::HasSigil
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/strict_sigil.rb#11
  def minimum_strictness; end
end

# This cop makes the Sorbet `strong` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::StrongSigil < ::RuboCop::Cop::Sorbet::HasSigil
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/strong_sigil.rb#11
  def minimum_strictness; end
end

# This cop makes the Sorbet `true` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::TrueSigil < ::RuboCop::Cop::Sorbet::HasSigil
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/true_sigil.rb#11
  def minimum_strictness; end
end

# This cop ensures all constants used as `T.type_alias` are using CamelCase.
#
# @example
#
#   # bad
#   FOO_OR_BAR = T.type_alias { T.any(Foo, Bar) }
#
#   # good
#   FooOrBar = T.type_alias { T.any(Foo, Bar) }
class RuboCop::Cop::Sorbet::TypeAliasName < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/type_alias_name.rb#20
  def casgn_type_alias?(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/type_alias_name.rb#32
  def on_casgn(node); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/type_alias_name.rb#18
RuboCop::Cop::Sorbet::TypeAliasName::MSG = T.let(T.unsafe(nil), String)

# This cop checks that every Ruby file contains a valid Sorbet sigil.
# Adapted from: https://gist.github.com/clarkdave/85aca4e16f33fd52aceb6a0a29936e52
#
# Options:
#
# * `RequireSigilOnAllFiles`: make offense if the Sorbet typed is not found in the file (default: false)
# * `SuggestedStrictness`: Sorbet strictness level suggested in offense messages (default: 'false')
# * `MinimumStrictness`: If set, make offense if the strictness level in the file is below this one
#
# If a `MinimumStrictness` level is specified, it will be used in offense messages and autocorrect.
class RuboCop::Cop::Sorbet::ValidSigil < ::RuboCop::Cop::Cop
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#33
  def autocorrect(_node); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#21
  def investigate(processed_source); end

  protected

  # checks
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#68
  def check_sigil_present(sigil); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#125
  def check_strictness_level(sigil, strictness); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#103
  def check_strictness_not_empty(sigil, strictness); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#114
  def check_strictness_valid(sigil, strictness); end

  # extraction
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#56
  def extract_sigil(processed_source); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#62
  def extract_strictness(sigil); end

  # Default is `nil`
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#155
  def minimum_strictness; end

  # Default is `false`
  #
  # @return [Boolean]
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#144
  def require_sigil_on_all_files?; end

  # Default is `'false'`
  #
  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#149
  def suggested_strictness; end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#84
  def suggested_strictness_level(minimum_strictness, suggested_strictness); end
end

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#52
RuboCop::Cop::Sorbet::ValidSigil::SIGIL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-sorbet//lib/rubocop/cop/sorbet/sigils/valid_sigil.rb#51
RuboCop::Cop::Sorbet::ValidSigil::STRICTNESS_LEVELS = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::SpaceAfterPunctuation
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#10
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#38
  def allowed_type?(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#20
  def each_missing_space(tokens); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#49
  def offset; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#42
  def space_forbidden_before_rcurly?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#30
  def space_missing?(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#34
  def space_required_before?(token); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_after_punctuation.rb#8
RuboCop::Cop::SpaceAfterPunctuation::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_before_punctuation.rb#12
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_before_punctuation.rb#22
  def each_missing_space(tokens); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_before_punctuation.rb#34
  def space_missing?(token1, token2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_before_punctuation.rb#38
  def space_required_after?(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_before_punctuation.rb#42
  def space_required_after_lcurly?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/space_before_punctuation.rb#10
RuboCop::Cop::SpaceBeforePunctuation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::SurroundingSpace

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/space_corrector.rb#36
    def add_space(processed_source, corrector, left_token, right_token); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/space_corrector.rb#12
    def empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/space_corrector.rb#10
    def processed_source; end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/space_corrector.rb#24
    def remove_space(processed_source, corrector, left_token, right_token); end
  end
end

module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#64
  def code_after(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#88
  def comment_disables_cop?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#56
  def first_line_comment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#43
  def length_in_modifier_form(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#82
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#37
  def modifier_fits_on_single_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#26
  def non_eligible_body?(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#33
  def non_eligible_condition?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#19
  def non_eligible_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#70
  def parenthesize?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#11
  def single_line_as_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/statement_modifier.rb#50
  def to_modifier_form(node); end
end

module RuboCop::Cop::StringHelp
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/string_help.rb#26
  def on_regexp(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/string_help.rb#10
  def on_str(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/string_help.rb#32
  def inside_interpolation?(node); end
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/string_literal_corrector.rb#10
    def correct(corrector, node, style); end
  end
end

module RuboCop::Cop::StringLiteralsHelp
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/string_literals_help.rb#9
  def wrong_quotes?(src_or_node); end
end

module RuboCop::Cop::Style; end

class RuboCop::Cop::Style::AccessModifierDeclarations < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#89
  def access_modifier_with_symbol?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#93
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#144
  def access_modifier_is_inlined?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#148
  def access_modifier_is_not_inlined?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#127
  def allow_modifiers_on_symbols?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#110
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#173
  def find_argument_less_modifier_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#162
  def find_corresponding_def_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#136
  def group_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#140
  def inline_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#185
  def insert_def(corrector, node, source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#197
  def insert_inline_modifier(corrector, node, modifier_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#152
  def message(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#131
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#201
  def remove_node(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#179
  def select_grouped_def_nodes(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#76
RuboCop::Cop::Style::AccessModifierDeclarations::GROUP_STYLE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#81
RuboCop::Cop::Style::AccessModifierDeclarations::INLINE_STYLE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/access_modifier_declarations.rb#86
RuboCop::Cop::Style::AccessModifierDeclarations::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AccessorGrouping < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#48
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#48
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#48
  def on_sclass(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#96
  def accessor?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#71
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#60
  def check(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#84
  def class_send_elements(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#131
  def group_accessors(node, accessors); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#100
  def grouped_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#117
  def message(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#122
  def preferred_accessors(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#80
  def previous_line_comment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#137
  def separate_accessors(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#104
  def separated_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#108
  def sibling_accessors(send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#46
RuboCop::Cop::Style::AccessorGrouping::ACCESSOR_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#43
RuboCop::Cop::Style::AccessorGrouping::GROUPED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/accessor_grouping.rb#44
RuboCop::Cop::Style::AccessorGrouping::SEPARATED_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Alias < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#142
  def identifier(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#45
  def on_alias(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#35
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#77
  def add_offense_for_args(node, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#69
  def alias_keyword_possible?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#73
  def alias_method_possible?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#59
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#116
  def bareword?(sym_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#120
  def correct_alias_method_to_alias(corrector, send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#127
  def correct_alias_to_alias_method(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#136
  def correct_alias_with_symbol_args(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#105
  def lexical_scope_type(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#88
  def scope_type(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#29
RuboCop::Cop::Style::Alias::MSG_ALIAS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#30
RuboCop::Cop::Style::Alias::MSG_ALIAS_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#31
RuboCop::Cop::Style::Alias::MSG_SYMBOL_ARGS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/alias.rb#33
RuboCop::Cop::Style::Alias::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AndOr < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#51
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#56
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#51
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#56
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#56
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#56
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#56
  def on_while_post(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#117
  def correct_not(node, receiver, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#129
  def correct_other(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#95
  def correct_send(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#108
  def correct_setter(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#143
  def correctable_send?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#135
  def keep_operator_precedence(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#91
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#85
  def on_conditionals(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#66
  def process_logical_operator(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#147
  def whitespace_before_arg(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/and_or.rb#49
RuboCop::Cop::Style::AndOr::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ArgumentsForwarding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#72
  def forwarding_method_arguments?(param0 = T.unsafe(nil), param1, param2, param3); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#84
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#84
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#64
  def only_rest_arguments?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#59
  def use_rest_arguments?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#115
  def all_lvars_as_forwarding_method_arguments?(def_node, forwarding_method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#148
  def allow_only_rest_arguments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#142
  def arguments_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#102
  def extract_argument_names_from(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#109
  def forwarding_method?(node, rest_arg, kwargs, block_arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#124
  def register_offense_to_forwarding_method_arguments(forwarding_method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#133
  def register_offense_to_method_definition_arguments(method_definition); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/arguments_forwarding.rb#56
RuboCop::Cop::Style::ArgumentsForwarding::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ArrayCoercion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/array_coercion.rb#48
  def array_splat?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/array_coercion.rb#63
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/array_coercion.rb#74
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/array_coercion.rb#53
  def unless_array?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/array_coercion.rb#45
RuboCop::Cop::Style::ArrayCoercion::CHECK_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/array_coercion.rb#44
RuboCop::Cop::Style::ArrayCoercion::SPLAT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ArrayJoin < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/array_join.rb#27
  def join_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/array_join.rb#29
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/array_join.rb#23
RuboCop::Cop::Style::ArrayJoin::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/array_join.rb#24
RuboCop::Cop::Style::ArrayJoin::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AsciiComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ascii_comments.rb#21
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ascii_comments.rb#51
  def allowed_non_ascii_chars; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ascii_comments.rb#42
  def first_non_ascii_chars(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ascii_comments.rb#32
  def first_offense_range(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ascii_comments.rb#46
  def only_allowed_non_ascii_chars?(string); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/ascii_comments.rb#19
RuboCop::Cop::Style::AsciiComments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Attr < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#64
  def class_eval?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#24
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#37
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#49
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#53
  def replacement_method(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#21
RuboCop::Cop::Style::Attr::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/attr.rb#22
RuboCop::Cop::Style::Attr::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AutoResourceCleanup < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/auto_resource_cleanup.rb#26
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/auto_resource_cleanup.rb#41
  def cleanup?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/auto_resource_cleanup.rb#20
RuboCop::Cop::Style::AutoResourceCleanup::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/auto_resource_cleanup.rb#24
RuboCop::Cop::Style::AutoResourceCleanup::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/auto_resource_cleanup.rb#22
RuboCop::Cop::Style::AutoResourceCleanup::TARGET_METHODS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::BarePercentLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#32
  def on_dstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#36
  def on_str(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#63
  def add_offense_for_wrong_style(node, good, bad); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#42
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#59
  def requires_bare_percent?(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#55
  def requires_percent_q?(source); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/bare_percent_literals.rb#30
RuboCop::Cop::Style::BarePercentLiterals::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BeginBlock < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/begin_block.rb#16
  def on_preexe(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/begin_block.rb#14
RuboCop::Cop::Style::BeginBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BisectedAttrAccessor < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#55
  def after_class(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#55
  def after_module(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#55
  def after_sclass(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#33
  def on_class(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#33
  def on_module(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#29
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#33
  def on_sclass(class_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#102
  def correct_reader(corrector, macro, node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#114
  def correct_writer(corrector, macro, node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#91
  def find_bisection(macros); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#74
  def find_macros(class_def); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#98
  def register_offense(attr); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor.rb#27
RuboCop::Cop::Style::BisectedAttrAccessor::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  include ::RuboCop::Cop::VisibilityHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#19
  def initialize(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#49
  def all_bisected?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#29
  def attr_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13
  def attrs; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#25
  def bisect(*names); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#33
  def bisected_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13
  def bisection; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13
  def node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#41
  def reader?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#53
  def rest; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#37
  def visibility; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#45
  def writer?; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#15
    def macro?(node); end
  end
end

class RuboCop::Cop::Style::BlockComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_comments.rb#27
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_comments.rb#56
  def eq_end_part(comment, expr); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_comments.rb#48
  def parts(comment); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/block_comments.rb#24
RuboCop::Cop::Style::BlockComments::BEGIN_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/style/block_comments.rb#25
RuboCop::Cop::Style::BlockComments::END_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/style/block_comments.rb#23
RuboCop::Cop::Style::BlockComments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BlockDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#194
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#194
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#179
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#443
  def array_or_range?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#208
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#447
  def begin_required?(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#236
  def braces_for_chaining_message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#384
  def braces_for_chaining_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#248
  def braces_required_message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#361
  def braces_required_method?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#365
  def braces_required_methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#394
  def braces_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#439
  def conditional?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#398
  def correction_would_break_code?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#309
  def end_of_chain(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#408
  def functional_block?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#404
  def functional_method?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#320
  def get_blocks(node, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#369
  def line_count_based_block_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#218
  def line_count_based_message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#252
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#300
  def move_comment_before_block(corrector, comment, block_node, closing_brace); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#416
  def procedural_method?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#412
  def procedural_oneliners_may_have_braces?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#338
  def proper_block_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#263
  def replace_braces_with_do_end(corrector, loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#279
  def replace_do_end_with_braces(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#432
  def return_value_of_scope?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#420
  def return_value_used?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#373
  def semantic_block_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#226
  def semantic_message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#349
  def special_method?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#355
  def special_method_proper_block_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#296
  def whitespace_after?(range, length = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#292
  def whitespace_before?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#316
  def with_block?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#175
RuboCop::Cop::Style::BlockDelimiters::ALWAYS_BRACES_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/block_delimiters.rb#177
RuboCop::Cop::Style::BlockDelimiters::BRACES_REQUIRED_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#614
    def correct(corrector, cop, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#624
    def move_assignment_inside_condition(corrector, node); end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#644
    def extract_branches(case_node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#638
    def extract_tail_branches(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#654
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

class RuboCop::Cop::Style::CaseEquality < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#47
  def case_equality?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#52
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#50
  def self_class?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#90
  def begin_replacement(lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#96
  def const_replacement(lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#65
  def offending_receiver?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#72
  def replacement(lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#100
  def send_replacement(lhs, rhs); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#43
RuboCop::Cop::Style::CaseEquality::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/case_equality.rb#44
RuboCop::Cop::Style::CaseEquality::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::CaseLikeIf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#40
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#64
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#214
  def branch_conditions(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#232
  def class_reference?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#149
  def collect_conditions(node, target, conditions); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#203
  def condition_from_binary_op(lhs, rhs, target); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#185
  def condition_from_equality_node(node, target); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#196
  def condition_from_include_or_cover_node(node, target); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#191
  def condition_from_match_node(node, target); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#168
  def condition_from_send_node(node, target); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#223
  def const_reference?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#241
  def correction_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#236
  def deparenthesize(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#85
  def find_target(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#119
  def find_target_in_equality_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#131
  def find_target_in_include_or_cover_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#137
  def find_target_in_match_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#104
  def find_target_in_send_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#257
  def regexp_with_named_captures?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#246
  def regexp_with_working_captures?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#79
  def should_check?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/case_like_if.rb#38
RuboCop::Cop::Style::CaseLikeIf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CharacterLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/character_literal.rb#35
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/character_literal.rb#53
  def correct_style_detected; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/character_literal.rb#30
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/character_literal.rb#49
  def opposite_style_detected; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/character_literal.rb#28
RuboCop::Cop::Style::CharacterLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassAndModuleChildren < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#41
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#47
  def on_module(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#88
  def add_trailing_end(corrector, node, padding); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#177
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#166
  def check_compact_style(node, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#158
  def check_nested_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#148
  def check_style(node, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#93
  def compact_definition(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#114
  def compact_identifier_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#99
  def compact_node(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#187
  def compact_node_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#104
  def compact_replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#127
  def configured_indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#144
  def indent_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#140
  def leading_spaces(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#183
  def needs_compacting?(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#61
  def nest_definition(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#53
  def nest_or_compact(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#119
  def remove_end(corrector, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#70
  def replace_namespace_keyword(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#79
  def split_on_double_colon(corrector, node, padding); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#131
  def unindent(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#39
RuboCop::Cop::Style::ClassAndModuleChildren::COMPACT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_and_module_children.rb#38
RuboCop::Cop::Style::ClassAndModuleChildren::NESTED_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassCheck < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_check.rb#44
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_check.rb#33
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_check.rb#30
RuboCop::Cop::Style::ClassCheck::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_check.rb#31
RuboCop::Cop::Style::ClassCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ClassEqualityComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_equality_comparison.rb#72
  def class_comparison_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_equality_comparison.rb#78
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_equality_comparison.rb#96
  def class_name(class_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_equality_comparison.rb#108
  def offense_range(receiver_node, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_equality_comparison.rb#67
RuboCop::Cop::Style::ClassEqualityComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_equality_comparison.rb#69
RuboCop::Cop::Style::ClassEqualityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ClassMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods.rb#28
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods.rb#28
  def on_module(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods.rb#41
  def check_defs(name, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods.rb#26
RuboCop::Cop::Style::ClassMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassMethodsDefinitions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#81
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#71
  def on_sclass(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#95
  def all_methods_public?(sclass_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#115
  def autocorrect_sclass(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#102
  def def_nodes(sclass_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#91
  def def_self_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#141
  def extract_def_from_sclass(def_node, sclass_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#152
  def indentation_diff(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#137
  def sclass_only_has_methods?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#68
RuboCop::Cop::Style::ClassMethodsDefinitions::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_methods_definitions.rb#69
RuboCop::Cop::Style::ClassMethodsDefinitions::MSG_SCLASS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassVars < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_vars.rb#52
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/class_vars.rb#56
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_vars.rb#49
RuboCop::Cop::Style::ClassVars::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/class_vars.rb#50
RuboCop::Cop::Style::ClassVars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::CollectionCompact < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#70
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#50
  def reject_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#43
  def reject_method_with_block_pass?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#60
  def select_method?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#97
  def good_method_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#81
  def offense_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#105
  def range(begin_pos_node, end_pos_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#38
RuboCop::Cop::Style::CollectionCompact::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/collection_compact.rb#40
RuboCop::Cop::Style::CollectionCompact::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::CollectionMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#47
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#47
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#53
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#61
  def check_method_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#70
  def implicit_block?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#78
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#84
  def methods_accepting_symbol; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/collection_methods.rb#45
RuboCop::Cop::Style::CollectionMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ColonMethodCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/colon_method_call.rb#26
  def java_type_node?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/colon_method_call.rb#35
  def on_send(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/colon_method_call.rb#31
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/colon_method_call.rb#23
RuboCop::Cop::Style::ColonMethodCall::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ColonMethodDefinition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/colon_method_definition.rb#27
  def on_defs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/colon_method_definition.rb#25
RuboCop::Cop::Style::ColonMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CombinableLoops < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/combinable_loops.rb#62
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/combinable_loops.rb#71
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/combinable_loops.rb#62
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/combinable_loops.rb#80
  def collection_looping_method?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/combinable_loops.rb#86
  def same_collection_looping?(node, sibling); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/combinable_loops.rb#60
RuboCop::Cop::Style::CombinableLoops::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CommandLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#85
  def on_xstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#146
  def allow_inner_backticks?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#122
  def allowed_backtick_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#131
  def allowed_percent_x_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#109
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#159
  def backtick_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#97
  def check_backtick_literal(node, message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#103
  def check_percent_x_literal(node, message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#167
  def command_delimiter; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#150
  def contains_backtick?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#142
  def contains_disallowed_backtick?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#171
  def default_delimiter; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#154
  def node_body(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#163
  def preferred_delimiter; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#175
  def preferred_delimiters_config; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#82
RuboCop::Cop::Style::CommandLiteral::MSG_USE_BACKTICKS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/command_literal.rb#83
RuboCop::Cop::Style::CommandLiteral::MSG_USE_PERCENT_X = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CommentAnnotation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#73
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#110
  def annotation_range(annotation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#114
  def correct_offense(corrector, range, keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#102
  def first_comment_line?(comments, index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#106
  def inline_comment?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#124
  def keywords; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#87
  def register_offense(annotation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#120
  def requires_colon?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#71
RuboCop::Cop::Style::CommentAnnotation::MISSING_NOTE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#65
RuboCop::Cop::Style::CommentAnnotation::MSG_COLON_STYLE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/comment_annotation.rb#68
RuboCop::Cop::Style::CommentAnnotation::MSG_SPACE_STYLE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CommentedKeyword < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#57
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#80
  def offensive?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#67
  def register_offense(comment, matched_keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#86
  def source_line(comment); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#52
RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#53
RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENT_REGEXES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#49
RuboCop::Cop::Style::CommentedKeyword::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#50
RuboCop::Cop::Style::CommentedKeyword::KEYWORD_REGEXES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#47
RuboCop::Cop::Style::CommentedKeyword::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/commented_keyword.rb#55
RuboCop::Cop::Style::CommentedKeyword::REGEXP = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::ConditionalAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#230
  def assignment_type?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#311
  def candidate_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_and_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#266
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#276
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#252
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_masgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#238
  def on_or_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#246
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#317
  def allowed_single_line?(branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#388
  def allowed_statements?(branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#313
  def allowed_ternary?(assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#321
  def assignment_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#365
  def assignment_types_match?(*nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#380
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#306
  def candidate_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#288
  def check_assignment_to_condition(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#371
  def check_node(node, branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#404
  def correction_exceeds_line_limit?(node, branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#439
  def include_ternary?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#431
  def indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#358
  def lhs_all_match?(branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#423
  def line_length_cop_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#416
  def longest_line(node, assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#412
  def longest_line_exceeds_line_limit?(node, assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#427
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#342
  def move_assignment_inside_condition(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#332
  def move_assignment_outside_condition(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#435
  def single_line_conditions_only?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#354
  def ternary_condition?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#219
RuboCop::Cop::Style::ConditionalAssignment::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#217
RuboCop::Cop::Style::ConditionalAssignment::ASSIGN_TO_CONDITION_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#222
RuboCop::Cop::Style::ConditionalAssignment::ENABLED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#221
RuboCop::Cop::Style::ConditionalAssignment::INDENTATION_WIDTH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#220
RuboCop::Cop::Style::ConditionalAssignment::LINE_LENGTH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#223
RuboCop::Cop::Style::ConditionalAssignment::MAX = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#216
RuboCop::Cop::Style::ConditionalAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#224
RuboCop::Cop::Style::ConditionalAssignment::SINGLE_LINE_CONDITIONS_ONLY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#218
RuboCop::Cop::Style::ConditionalAssignment::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#225
RuboCop::Cop::Style::ConditionalAssignment::WIDTH = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#64
  def end_with_eq?(sym); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#20
  def expand_elses(branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#28
  def expand_when_branches(when_branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#55
  def indent(cop, source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#37
  def lhs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#32
  def tail(branch); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#109
  def assignment_rhs_exist?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#70
  def expand_elsif(node, elsif_branches = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#96
  def lhs_for_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#83
  def lhs_for_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#105
  def setter_method?(method_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#13
RuboCop::Cop::Style::ConditionalAssignmentHelper::ALIGN_WITH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#12
RuboCop::Cop::Style::ConditionalAssignmentHelper::END_ALIGNMENT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#11
RuboCop::Cop::Style::ConditionalAssignmentHelper::EQUAL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#14
RuboCop::Cop::Style::ConditionalAssignmentHelper::KEYWORD = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#465
  def assignment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#495
  def correct_branches(corrector, branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#472
  def correct_if_branches(corrector, cop, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#447
  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#482
  def replace_branch_assignment(corrector, branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#458
  def white_space_range(node, column); end
end

class RuboCop::Cop::Style::ConstantVisibility < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#51
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#96
  def visibility_declaration_for?(param0 = T.unsafe(nil), param1); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#76
  def class_or_module_scope?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#62
  def ignore_modules?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#100
  def match_name?(name, constant_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#70
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#66
  def module?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#87
  def visibility_declaration?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/constant_visibility.rb#48
RuboCop::Cop::Style::ConstantVisibility::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Copyright < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#25
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#44
  def autocorrect_notice; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#75
  def encoding_token?(processed_source, token_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#61
  def insert_notice_before(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#40
  def notice; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#82
  def notice_found?(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#48
  def offense_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#68
  def shebang_token?(processed_source, token_index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#52
  def verify_autocorrect_notice!; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#23
RuboCop::Cop::Style::Copyright::AUTOCORRECT_EMPTY_WARNING = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/copyright.rb#22
RuboCop::Cop::Style::Copyright::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DateTime < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#56
  def date_time?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#61
  def historic_date?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#70
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#66
  def to_datetime?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#85
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#81
  def disallow_coercion?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#52
RuboCop::Cop::Style::DateTime::CLASS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/date_time.rb#53
RuboCop::Cop::Style::DateTime::COERCION_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DefWithParentheses < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/def_with_parentheses.rb#47
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/def_with_parentheses.rb#47
  def on_defs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/def_with_parentheses.rb#45
RuboCop::Cop::Style::DefWithParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Dir < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/dir.rb#29
  def dir_replacement?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/dir.rb#34
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/dir.rb#44
  def file_keyword?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/dir.rb#25
RuboCop::Cop::Style::Dir::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/dir.rb#26
RuboCop::Cop::Style::Dir::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#40
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#77
  def allowed_cops; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#81
  def any_cops_allowed?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#72
  def directive_cops(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#53
  def register_offense(comment, directive_cops, disallowed_cops); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#37
RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#38
RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG_FOR_COPS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#84
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#107
  def comment_block_docs?(arg_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#147
  def comment_regexp(arg_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#126
  def heredoc_comment_blocks(heredoc_body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#100
  def inline_comment_docs?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#96
  def interpolated?(arg_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#136
  def merge_adjacent_comments(line, index, hash); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#117
  def preceding_comment_blocks(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#156
  def source_to_regexp(source); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#78
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::BLOCK_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#79
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#80
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/document_dynamic_eval_definition.rb#82
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Documentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#79
  def constant_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#85
  def constant_visibility_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#89
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#95
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#82
  def outer_module(param0); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#168
  def allowed_constants; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#101
  def check(node, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#141
  def compact_namespace?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#137
  def constant_allowed?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#133
  def constant_declaration?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#172
  def identifier(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#118
  def macro_only?(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#123
  def namespace?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#164
  def nodoc(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#160
  def nodoc?(comment, require_all: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#150
  def nodoc_comment?(node, require_all: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#113
  def nodoc_self_or_outer_module?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#178
  def qualify_const(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/documentation.rb#76
RuboCop::Cop::Style::Documentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DocumentationMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::DefNode

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation_method.rb#101
  def module_function_node?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation_method.rb#105
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation_method.rb#105
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation_method.rb#113
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/documentation_method.rb#120
  def require_for_non_public_methods?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/documentation_method.rb#98
RuboCop::Cop::Style::DocumentationMethod::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DoubleCopDisableDirective < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_cop_disable_directive.rb#34
  def on_new_investigation; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/double_cop_disable_directive.rb#32
RuboCop::Cop::Style::DoubleCopDisableDirective::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DoubleNegation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#69
  def double_negative?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#71
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#84
  def allowed_in_returns?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#111
  def define_mehod?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#138
  def double_negative_condition_return_value?(node, last_child, conditional_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#88
  def end_of_method_definition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#120
  def find_conditional_node_from_ascendant(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#103
  def find_def_node_from_ascendant(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#127
  def find_last_child(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#147
  def find_parent_not_enumerable(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#65
RuboCop::Cop::Style::DoubleNegation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/double_negation.rb#66
RuboCop::Cop::Style::DoubleNegation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::EachForSimpleLoop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_for_simple_loop.rb#53
  def each_range(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_for_simple_loop.rb#65
  def each_range_with_zero_origin?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_for_simple_loop.rb#77
  def each_range_without_block_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_for_simple_loop.rb#30
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_for_simple_loop.rb#48
  def offending?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/each_for_simple_loop.rb#28
RuboCop::Cop::Style::EachForSimpleLoop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EachWithObject < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#60
  def each_with_object_block_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#65
  def each_with_object_numblock_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#26
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#43
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#102
  def accumulator_param_assigned_to?(body, args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#69
  def autocorrect_block(corrector, node, return_value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#84
  def autocorrect_numblock(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#121
  def first_argument_returned?(args, return_value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#114
  def return_value(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#129
  def return_value_occupies_whole_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#96
  def simple_method_arg?(method_arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#133
  def whole_line_expression(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#24
RuboCop::Cop::Style::EachWithObject::METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/each_with_object.rb#23
RuboCop::Cop::Style::EachWithObject::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyBlockParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_block_parameter.rb#31
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_block_parameter.rb#38
  def autocorrect(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_block_parameter.rb#29
RuboCop::Cop::Style::EmptyBlockParameter::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyCaseCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#44
  def on_case(case_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#58
  def autocorrect(corrector, case_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#65
  def correct_case_when(corrector, case_node, when_nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#77
  def correct_when_conditions(corrector, when_nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#92
  def keep_first_when_comment(case_range, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#102
  def replace_then_with_line_break(corrector, conditions, when_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_case_condition.rb#42
RuboCop::Cop::Style::EmptyCaseCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#139
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#135
  def on_normal_if_unless(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#172
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#193
  def autocorrect_forbidden?(type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#186
  def base_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#145
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#180
  def comment_in_else?(loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#160
  def empty_check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#156
  def empty_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#197
  def missing_else_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#166
  def nil_check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#152
  def nil_style?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_else.rb#133
RuboCop::Cop::Style::EmptyElse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyHeredoc < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_heredoc.rb#43
  def on_heredoc(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_heredoc.rb#63
  def enforce_double_quotes?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_heredoc.rb#59
  def preferred_string_literal; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_heredoc.rb#67
  def string_literals_config; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_heredoc.rb#41
RuboCop::Cop::Style::EmptyHeredoc::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyLambdaParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_lambda_parameter.rb#26
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_lambda_parameter.rb#35
  def autocorrect(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_lambda_parameter.rb#24
RuboCop::Cop::Style::EmptyLambdaParameter::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#31
  def array_node(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#40
  def array_with_block(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#34
  def hash_node(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#43
  def hash_with_block(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#50
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#37
  def str_node(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#111
  def correction(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#74
  def enforce_double_quotes?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#82
  def first_argument_unparenthesized?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#129
  def frozen_strings?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#102
  def offense_array_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#106
  def offense_hash_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#60
  def offense_message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#70
  def preferred_string_literal; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#89
  def replacement_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#78
  def string_literals_config; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#24
RuboCop::Cop::Style::EmptyLiteral::ARR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#25
RuboCop::Cop::Style::EmptyLiteral::HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#28
RuboCop::Cop::Style::EmptyLiteral::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_literal.rb#26
RuboCop::Cop::Style::EmptyLiteral::STR_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#54
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#54
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#95
  def compact?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#103
  def compact_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#73
  def correct_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#77
  def corrected(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#99
  def expanded?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#107
  def expanded_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#89
  def joint(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#111
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#69
  def message(_range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#51
RuboCop::Cop::Style::EmptyMethod::MSG_COMPACT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/empty_method.rb#52
RuboCop::Cop::Style::EmptyMethod::MSG_EXPANDED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Encoding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#20
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#32
  def comments; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#43
  def offense?(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#47
  def register_offense(line_number, comment); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#17
RuboCop::Cop::Style::Encoding::ENCODING_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#16
RuboCop::Cop::Style::Encoding::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/encoding.rb#18
RuboCop::Cop::Style::Encoding::SHEBANG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EndBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/end_block.rb#20
  def on_postexe(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/end_block.rb#18
RuboCop::Cop::Style::EndBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EndlessMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#60
  def on_def(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#95
  def arguments(node, missing = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#85
  def correct_to_multiline(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#70
  def handle_allow_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#79
  def handle_disallow_style(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#56
RuboCop::Cop::Style::EndlessMethod::CORRECTION_STYLES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#57
RuboCop::Cop::Style::EndlessMethod::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/endless_method.rb#58
RuboCop::Cop::Style::EndlessMethod::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EnvHome < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/env_home.rb#38
  def env_home?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/env_home.rb#45
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/env_home.rb#34
RuboCop::Cop::Style::EnvHome::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/env_home.rb#35
RuboCop::Cop::Style::EnvHome::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::EvalWithLocation < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#74
  def line_with_offset?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#81
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#69
  def valid_eval_receiver?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#195
  def add_offense_for_different_line(node, line_node, line_diff); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#142
  def add_offense_for_incorrect_line(method_name, line_node, sign, line_diff); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#210
  def add_offense_for_missing_line(node, code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#217
  def add_offense_for_missing_location(node, code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#189
  def add_offense_for_same_line(node, line_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#154
  def check_file(node, file_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#167
  def check_line(node, code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#95
  def check_location(node, code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#202
  def expected_line(sign, line_diff); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#122
  def file_and_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#177
  def line_difference(line_node, code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#229
  def missing_line(node, code); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#109
  def register_offense(node, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#114
  def special_file_keyword?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#118
  def special_line_keyword?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#181
  def string_first_line(str_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#127
  def with_binding?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#133
  def with_lineno?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#59
RuboCop::Cop::Style::EvalWithLocation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#60
RuboCop::Cop::Style::EvalWithLocation::MSG_EVAL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#61
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_FILE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#63
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_LINE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/eval_with_location.rb#66
RuboCop::Cop::Style::EvalWithLocation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::EvenOdd < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/even_odd.rb#25
  def even_odd_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/even_odd.rb#33
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/even_odd.rb#45
  def replacement_method(arg, method); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/even_odd.rb#21
RuboCop::Cop::Style::EvenOdd::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/even_odd.rb#22
RuboCop::Cop::Style::EvenOdd::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ExpandPathArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#58
  def file_expand_path(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#82
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#74
  def pathname_new_parent_expand_path(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#66
  def pathname_parent_expand_path(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#189
  def arguments_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#100
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#135
  def autocorrect_expand_path(corrector, current_path, default_dir); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#162
  def depth(current_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#113
  def inspect_offense_for_expand_path(node, current_path, default_dir); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#168
  def parent_path(current_path); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#182
  def remove_parent_method(corrector, default_dir); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#155
  def strip_surrounded_quotes!(path_string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#109
  def unrecommended_argument?(default_dir); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#47
RuboCop::Cop::Style::ExpandPathArguments::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#49
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#51
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_NEW_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/expand_path_arguments.rb#55
RuboCop::Cop::Style::ExpandPathArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ExplicitBlockArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#53
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#58
  def on_yield(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#49
  def yielding_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#104
  def add_block_argument(node, corrector, block_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#143
  def block_body_range(block_node, send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#121
  def call_like?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#133
  def correct_call_node(node, corrector, block_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#116
  def empty_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#83
  def extract_block_name(def_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#125
  def insert_argument(node, corrector, block_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#91
  def yielding_arguments?(block_args, yield_args); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/explicit_block_argument.rb#45
RuboCop::Cop::Style::ExplicitBlockArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ExponentialNotation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#68
  def on_float(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#79
  def engineering?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#90
  def integral(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#110
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#95
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#74
  def scientific?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/exponential_notation.rb#62
RuboCop::Cop::Style::ExponentialNotation::MESSAGES = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::FetchEnvVar < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#31
  def env_with_bracket?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#35
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#105
  def allowable_use?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#48
  def allowed_var?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#113
  def assigned?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#89
  def message_chained_with_dot?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#126
  def new_code(name_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#84
  def offensive?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#120
  def or_lhs?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#80
  def partial_matched?(node, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#53
  def used_as_flag?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#60
  def used_if_condition_in_body(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#69
  def used_in_condition?(node, condition); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/fetch_env_var.rb#28
RuboCop::Cop::Style::FetchEnvVar::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::FileRead < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#65
  def block_read?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#49
  def file_open?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#69
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#60
  def send_read?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#84
  def evidence(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#100
  def file_open_read?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#106
  def read_method(mode); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#92
  def read_node?(node, block_pass); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#42
RuboCop::Cop::Style::FileRead::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#46
RuboCop::Cop::Style::FileRead::READ_FILE_START_TO_FINISH_MODES = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/style/file_read.rb#44
RuboCop::Cop::Style::FileRead::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::FileWrite < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#68
  def block_write?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#85
  def evidence(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#52
  def file_open?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#72
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#63
  def send_write?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#95
  def file_open_write?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#123
  def heredoc?(write_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#128
  def heredoc_range(first_argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#108
  def replacement(mode, filename, content, write_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#104
  def write_method(mode); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#45
RuboCop::Cop::Style::FileWrite::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#47
RuboCop::Cop::Style::FileWrite::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/style/file_write.rb#49
RuboCop::Cop::Style::FileWrite::TRUNCATING_WRITE_MODES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::FloatDivision < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#79
  def any_coerce?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#75
  def both_coerce?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#71
  def left_coerce?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#83
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#67
  def right_coerce?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#121
  def add_to_f_method(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#130
  def correct_from_slash_to_fdiv(corrector, node, receiver, argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#141
  def extract_receiver_source(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#117
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#102
  def offense_condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#125
  def remove_to_f_method(corrector, send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#57
RuboCop::Cop::Style::FloatDivision::MESSAGES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/float_division.rb#64
RuboCop::Cop::Style::FloatDivision::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::For < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#65
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#54
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#65
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#82
  def suspect_enumerable?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#50
RuboCop::Cop::Style::For::EACH_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#51
RuboCop::Cop::Style::For::PREFER_EACH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/for.rb#52
RuboCop::Cop::Style::For::PREFER_FOR = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::FormatString < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#46
  def formatter(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#59
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#55
  def variable_argument?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#81
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#97
  def autocorrect_from_percent(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#111
  def autocorrect_to_percent(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#124
  def format_single_parameter(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#73
  def message(detected_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#77
  def method_name(style_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#42
RuboCop::Cop::Style::FormatString::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/format_string.rb#43
RuboCop::Cop::Style::FormatString::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::FormatStringToken < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#106
  def format_string_in_typical_context?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#91
  def on_str(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#213
  def allowed_unannotated?(detections); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#139
  def autocorrect_sequence(corrector, detected_sequence, token_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#124
  def check_sequence(detected_sequence, token_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#203
  def collect_detections(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#135
  def correctable_sequence?(detected_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#113
  def format_string_token?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#222
  def max_unannotated_placeholders_allowed; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#160
  def message(detected_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#165
  def message_text(style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#180
  def str_contents(source_map); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#190
  def token_ranges(contents); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#174
  def tokens(str_node, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#156
  def unannotated_format?(node, detected_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/format_string_token.rb#117
  def use_allowed_method?(node); end
end

class RuboCop::Cop::Style::FrozenStringLiteralComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#99
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#176
  def disabled_offense(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#188
  def enable_comment(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#120
  def ensure_comment(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#126
  def ensure_enabled_comment(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#114
  def ensure_no_comment(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#212
  def following_comment; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#150
  def frozen_string_literal_comment(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#194
  def insert_comment(corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#137
  def last_special_comment(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#204
  def line_range(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#156
  def missing_offense(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#162
  def missing_true_offense(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#208
  def preceding_comment; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#184
  def remove_comment(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#168
  def unnecessary_comment_offense(processed_source); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#96
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_DISABLED = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#94
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#93
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING_TRUE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#95
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/frozen_string_literal_comment.rb#97
RuboCop::Cop::Style::FrozenStringLiteralComment::SHEBANG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::GlobalStdStream < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_std_stream.rb#42
  def const_to_gvar_assignment?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_std_stream.rb#46
  def on_const(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_std_stream.rb#64
  def gvar_name(const_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_std_stream.rb#60
  def message(const_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/global_std_stream.rb#37
RuboCop::Cop::Style::GlobalStdStream::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/global_std_stream.rb#39
RuboCop::Cop::Style::GlobalStdStream::STD_STREAMS = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::GlobalVars < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#60
  def allowed_var?(global_var); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#72
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#64
  def on_gvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#68
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#56
  def user_vars; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#27
RuboCop::Cop::Style::GlobalVars::BUILT_IN_VARS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/global_vars.rb#23
RuboCop::Cop::Style::GlobalVars::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::GuardClause < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#99
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#99
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#113
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#175
  def accepted_form?(node, ending: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#183
  def accepted_if?(node, ending); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#193
  def allowed_consecutive_conditionals?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#132
  def check_ending_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#140
  def consecutive_conditionals?(parent, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#160
  def guard_clause_source(guard_clause); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#148
  def register_offense(node, scope_exiting_keyword, conditional_keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#170
  def too_long_for_single_line?(node, example); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#179
  def trivial?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/guard_clause.rb#96
RuboCop::Cop::Style::GuardClause::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashAsLastArrayItem < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#36
  def on_hash(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#84
  def braces_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#65
  def check_braces(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#73
  def check_no_braces(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#49
  def containing_array(hash_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#60
  def explicit_array?(array); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#54
  def last_array_item?(array, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_as_last_array_item.rb#88
  def remove_last_element_trailing_comma(corrector, node); end
end

class RuboCop::Cop::Style::HashConversion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#44
  def hash_from_array?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#46
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#128
  def allowed_splat_argument?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#121
  def args_to_hash(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#108
  def multi_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#84
  def register_offense_for_hash(node, hash_argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#93
  def register_offense_for_zip_method(node, zip_method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#103
  def requires_parens?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#61
  def single_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#78
  def use_zip_method_without_argument?(first_argument); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#39
RuboCop::Cop::Style::HashConversion::MSG_LITERAL_HASH_ARG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#38
RuboCop::Cop::Style::HashConversion::MSG_LITERAL_MULTI_ARG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#40
RuboCop::Cop::Style::HashConversion::MSG_SPLAT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#37
RuboCop::Cop::Style::HashConversion::MSG_TO_H = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_conversion.rb#41
RuboCop::Cop::Style::HashConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::HashEachMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#37
  def kv_each(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#41
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#41
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#98
  def allowed_receiver?(receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#104
  def allowed_receivers; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#63
  def check_argument(variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#87
  def correct_args(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#73
  def correct_implicit(node, corrector, method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#78
  def correct_key_value_each(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#94
  def kv_range(outer_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#49
  def register_kv_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#69
  def used?(arg); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_each_methods.rb#34
RuboCop::Cop::Style::HashEachMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashExcept < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#56
  def bad_method_with_active_support?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#40
  def bad_method_with_poro?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#71
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#88
  def bad_method?(block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#150
  def decorate_source(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#158
  def except_key(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#137
  def except_key_source(key); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#131
  def extract_body_if_nagated(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#112
  def included?(negated, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#116
  def not_included?(negated, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#167
  def offense_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#120
  def safe_to_register_offense?(block, except_key); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#96
  def semantically_except_method?(send, block); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#36
RuboCop::Cop::Style::HashExcept::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_except.rb#37
RuboCop::Cop::Style::HashExcept::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::HashLikeCase < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_like_case.rb#43
  def hash_like_case?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_like_case.rb#51
  def on_case(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_like_case.rb#67
  def min_branches_count; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_like_case.rb#63
  def nodes_of_same_type?(nodes); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_like_case.rb#40
RuboCop::Cop::Style::HashLikeCase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashSyntax < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::HashShorthandSyntax
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#161
  def alternative_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#139
  def hash_rockets_check(pairs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#153
  def no_mixed_keys_check(pairs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#117
  def on_hash(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#135
  def ruby19_check(pairs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#143
  def ruby19_no_mixed_keys_check(pairs); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#192
  def acceptable_19_syntax_symbol?(sym_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#246
  def argument_without_space?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#172
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#250
  def autocorrect_hash_rockets(corrector, pair_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#258
  def autocorrect_no_mixed_keys(corrector, pair_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#225
  def autocorrect_ruby19(corrector, pair_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#210
  def check(pairs, delim, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#266
  def force_hash_rockets?(pairs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#238
  def range_for_autocorrect_ruby19(pair_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#182
  def sym_indices?(pairs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#186
  def word_symbol_pair?(pair); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#113
RuboCop::Cop::Style::HashSyntax::MSG_19 = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#115
RuboCop::Cop::Style::HashSyntax::MSG_HASH_ROCKETS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/hash_syntax.rb#114
RuboCop::Cop::Style::HashSyntax::MSG_NO_MIXED_KEYS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashTransformKeys < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_keys.rb#36
  def on_bad_each_with_object(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_keys.rb#48
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_keys.rb#61
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_keys.rb#73
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_keys.rb#84
  def extract_captures(match); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_keys.rb#89
  def new_method_name; end
end

class RuboCop::Cop::Style::HashTransformValues < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_values.rb#34
  def on_bad_each_with_object(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_values.rb#46
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_values.rb#59
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_values.rb#71
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_values.rb#82
  def extract_captures(match); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/hash_transform_values.rb#87
  def new_method_name; end
end

class RuboCop::Cop::Style::IdenticalConditionalBranches < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#123
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#130
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#116
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#139
  def check_branches(node, branches); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#162
  def check_expressions(node, expressions, insert_position); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#151
  def duplicated_expressions?(node, expressions); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#189
  def expand_elses(branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#204
  def head(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#183
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#200
  def tail(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/identical_conditional_branches.rb#114
RuboCop::Cop::Style::IdenticalConditionalBranches::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#569
    def correct(corrector, cop, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#573
    def move_assignment_inside_condition(corrector, node); end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#587
    def extract_tail_branches(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#594
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

class RuboCop::Cop::Style::IfInsideElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#67
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#144
  def allow_if_modifier?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#140
  def allow_if_modifier_in_else_branch?(else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#82
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#111
  def correct_to_elsif_from_if_inside_else_form(corrector, node, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#103
  def correct_to_elsif_from_modifier_form(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#129
  def find_end_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#136
  def if_condition_range(node, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#125
  def then?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_inside_else.rb#65
RuboCop::Cop::Style::IfInsideElse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfUnlessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#53
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#90
  def allowed_patterns; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#150
  def another_statement_on_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#68
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#184
  def extract_heredoc_from(last_argument); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#134
  def line_length_enabled_at_line?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#138
  def named_capture_in_condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#142
  def non_eligible_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#146
  def non_simple_if_unless?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#191
  def remove_heredoc(corrector, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#164
  def to_normal_form(node, indentation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#172
  def to_normal_form_with_heredoc(node, indentation, heredoc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#85
  def too_long_due_to_modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#125
  def too_long_line_based_on_allow_uri?(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#108
  def too_long_line_based_on_config?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#117
  def too_long_line_based_on_ignore_cop_directives?(range, line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#95
  def too_long_single_line?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#49
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#44
RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_MODIFIER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier.rb#47
RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_NORMAL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#31
  def on_if(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#29
RuboCop::Cop::Style::IfUnlessModifierOfIfUnless::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#57
  def double_negative?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#53
  def if_with_boolean_literal_branches?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#59
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#109
  def assume_boolean_value?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#91
  def message(node, keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#79
  def offense_range_with_keyword(node, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#126
  def opposite_condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#116
  def replacement_condition(node, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#131
  def require_parentheses?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#97
  def return_boolean_value?(condition); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#49
RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#50
RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG_FOR_ELSIF = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfWithSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_semicolon.rb#23
  def on_normal_if_unless(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_semicolon.rb#39
  def autocorrect(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_semicolon.rb#56
  def build_else_branch(second_condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_semicolon.rb#47
  def correct_elsif(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_semicolon.rb#20
RuboCop::Cop::Style::IfWithSemicolon::MSG_IF_ELSE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/if_with_semicolon.rb#21
RuboCop::Cop::Style::IfWithSemicolon::MSG_TERNARY = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ImplicitRuntimeError < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/implicit_runtime_error.rb#23
  def implicit_runtime_error_raise_or_fail(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/implicit_runtime_error.rb#26
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/implicit_runtime_error.rb#18
RuboCop::Cop::Style::ImplicitRuntimeError::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/implicit_runtime_error.rb#20
RuboCop::Cop::Style::ImplicitRuntimeError::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::InPatternThen < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/in_pattern_then.rb#29
  def on_in_pattern(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/in_pattern_then.rb#46
  def alternative_pattern_source(pattern); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/in_pattern_then.rb#27
RuboCop::Cop::Style::InPatternThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::InfiniteLoop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#34
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#43
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#43
  def on_until_post(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#39
  def on_while(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#39
  def on_while_post(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#83
  def assigned_before_loop?(var, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#79
  def assigned_inside_loop?(var, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#69
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#124
  def configured_indent; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#102
  def modifier_replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#113
  def non_modifier_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#88
  def referenced_after_loop?(var, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#93
  def replace_begin_end_with_modifier(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#98
  def replace_source(corrector, range, replacement); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#52
  def while_or_until(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#30
    def joining_forces; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#26
RuboCop::Cop::Style::InfiniteLoop::LEADING_SPACE = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/infinite_loop.rb#28
RuboCop::Cop::Style::InfiniteLoop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::InlineComment < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/inline_comment.rb#23
  def on_new_investigation; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/inline_comment.rb#21
RuboCop::Cop::Style::InlineComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::InverseMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#68
  def inverse_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#59
  def inverse_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#89
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#89
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#76
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#174
  def camel_case_constant?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#118
  def correct_inverse_block(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#109
  def correct_inverse_method(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#125
  def correct_inverse_selector(block, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#178
  def dot_range(loc); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#161
  def end_parentheses(node, method_call); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#147
  def inverse_blocks; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#142
  def inverse_methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#188
  def message(method, inverse); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#151
  def negated?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#155
  def not_to_receiver(node, method_call); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#169
  def possible_class_hierarchy_check?(lhs, rhs, method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#182
  def remove_end_parenthesis(corrector, node, method, method_call); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#54
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#52
RuboCop::Cop::Style::InverseMethods::CAMEL_CASE = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#49
RuboCop::Cop::Style::InverseMethods::CLASS_COMPARISON_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#50
RuboCop::Cop::Style::InverseMethods::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#48
RuboCop::Cop::Style::InverseMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/inverse_methods.rb#51
RuboCop::Cop::Style::InverseMethods::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::IpAddresses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::StringHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#46
  def correct_style_detected; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#27
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#42
  def opposite_style_detected; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#50
  def allowed_addresses; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#55
  def could_be_ip?(str); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#68
  def starts_with_hex_or_colon?(str); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#64
  def too_long?(str); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#24
RuboCop::Cop::Style::IpAddresses::IPV6_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/style/ip_addresses.rb#25
RuboCop::Cop::Style::IpAddresses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::KeywordParametersOrder < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/keyword_parameters_order.rb#40
  def on_kwoptarg(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/keyword_parameters_order.rb#58
  def append_newline_to_last_kwoptarg(arguments, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/keyword_parameters_order.rb#66
  def remove_kwargs(kwarg_nodes, corrector); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/keyword_parameters_order.rb#38
RuboCop::Cop::Style::KeywordParametersOrder::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Lambda < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#64
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#64
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#115
  def arguments_with_whitespace(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#104
  def autocorrect_method_to_literal(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#119
  def lambda_arg_string(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#89
  def message(node, selector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#95
  def message_line_modifier(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#83
  def offending_selector?(node, selector); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#53
RuboCop::Cop::Style::Lambda::LITERAL_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#54
RuboCop::Cop::Style::Lambda::METHOD_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/lambda.rb#56
RuboCop::Cop::Style::Lambda::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::LambdaCall < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#28
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#62
  def explicit_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#58
  def implicit_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#46
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#50
  def prefer(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#25
RuboCop::Cop::Style::LambdaCall::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/lambda_call.rb#26
RuboCop::Cop::Style::LambdaCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::LineEndConcatenation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#51
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#71
  def autocorrect(corrector, operator_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#57
  def check_token_set(index); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#98
  def eligible_next_successor?(next_successor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#94
  def eligible_operator?(operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#102
  def eligible_predecessor?(predecessor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#90
  def eligible_successor?(successor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#84
  def eligible_token_set?(predecessor, operator, successor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#121
  def standard_string_literal?(token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#106
  def token_after_last_string(successor, base_index); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#47
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#42
RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_BEGIN_TOKEN = T.let(T.unsafe(nil), Symbol)

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#43
RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_END_TOKEN = T.let(T.unsafe(nil), Symbol)

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#40
RuboCop::Cop::Style::LineEndConcatenation::CONCAT_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#44
RuboCop::Cop::Style::LineEndConcatenation::HIGH_PRECEDENCE_OP_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#39
RuboCop::Cop::Style::LineEndConcatenation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#45
RuboCop::Cop::Style::LineEndConcatenation::QUOTE_DELIMITERS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/line_end_concatenation.rb#41
RuboCop::Cop::Style::LineEndConcatenation::SIMPLE_STRING_TOKEN_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::Style::MagicCommentFormat < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#156
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#241
  def correct_separator; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#279
  def directive_capitalization; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#197
  def directive_offends?(directive); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#233
  def expected_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#183
  def find_issues(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#207
  def fix_directives(issues); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#221
  def fix_values(issues); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#245
  def incorrect_separator?(text); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#173
  def leading_comment_lines; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#275
  def line_range(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#167
  def magic_comments; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#202
  def register_offenses(issues); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#264
  def replace_capitalization(text, style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#260
  def replace_separator(text); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#301
  def supported_capitalizations; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#295
  def valid_capitalization?(style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#287
  def value_capitalization; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#249
  def wrong_capitalization?(text, expected_case); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#237
  def wrong_separator; end
end

class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  extend ::Forwardable

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#119
  def initialize(comment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#117
  def comment; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#125
  def directives; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def loc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def text(*args, **_arg1, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#141
  def values; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#110
RuboCop::Cop::Style::MagicCommentFormat::CommentRange::DIRECTIVE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#114
RuboCop::Cop::Style::MagicCommentFormat::CommentRange::VALUE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#102
RuboCop::Cop::Style::MagicCommentFormat::KEBAB_SEPARATOR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#103
RuboCop::Cop::Style::MagicCommentFormat::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#104
RuboCop::Cop::Style::MagicCommentFormat::MSG_VALUE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/magic_comment_format.rb#101
RuboCop::Cop::Style::MagicCommentFormat::SNAKE_SEPARATOR = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MapCompactWithConditionalBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#46
  def map_and_compact?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#72
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#125
  def range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#91
  def returns_block_argument?(block_argument_node, return_value_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#95
  def truthy_branch?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#115
  def truthy_branch_for_guard?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#105
  def truthy_branch_for_if?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/map_compact_with_conditional_block.rb#43
RuboCop::Cop::Style::MapCompactWithConditionalBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MapToHash < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_to_hash.rb#41
  def map_to_h?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_to_hash.rb#45
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/map_to_hash.rb#59
  def autocorrect(corrector, to_h, map); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/map_to_hash.rb#37
RuboCop::Cop::Style::MapToHash::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/map_to_hash.rb#38
RuboCop::Cop::Style::MapToHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::MethodCallWithArgsParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#210
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#210
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#210
  def on_super(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#210
  def on_yield(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#219
  def args_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#228
  def args_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#232
  def args_parenthesized?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses.rb#206
    def autocorrect_incompatible_with; end
  end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#76
  def allowed_camel_case_method_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#160
  def allowed_chained_call_with_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#156
  def allowed_multiline_call_with_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#81
  def allowed_string_interpolation_method_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#169
  def ambiguous_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#198
  def assigned_before?(node, target); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#33
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#143
  def call_as_argument_or_chain?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#103
  def call_in_literals?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#112
  def call_in_logical_operators?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#120
  def call_in_optional_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#124
  def call_in_single_line_inheritance?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#128
  def call_with_ambiguous_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#138
  def call_with_braced_block?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#64
  def exist_next_line_expression?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#185
  def hash_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#149
  def hash_literal_in_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#46
  def inside_endless_method_def?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#202
  def inside_string_interpolation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#93
  def legitimate_call_with_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#181
  def logical_operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#58
  def modifier_form?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#42
  def offense_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#17
  def omit_parentheses(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#86
  def parentheses_at_the_end_of_multiline_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#189
  def regexp_slash_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#51
  def require_parentheses_for_hash_value_omission?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#173
  def splat?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#72
  def super_call_without_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#68
  def syntax_like_method_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#177
  def ternary_if?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#193
  def unary_literal?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#10
RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::TRAILING_WHITESPACE_REGEX = T.let(T.unsafe(nil), Regexp)

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#27
  def allowed_method_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#31
  def eligible_for_parentheses_omission?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#39
  def ignored_macro?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#35
  def included_macros_list; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#14
  def require_parentheses(node); end
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#33
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#60
  def allowed_method_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#72
  def any_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#56
  def default_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#52
  def ineligible_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#95
  def offense_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#45
  def register_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#64
  def same_name_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#88
  def variable_in_mass_assignment?(variable_name, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/method_call_without_args_parentheses.rb#31
RuboCop::Cop::Style::MethodCallWithoutArgsParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_called_on_do_end_block.rb#29
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_called_on_do_end_block.rb#40
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_called_on_do_end_block.rb#29
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_called_on_do_end_block.rb#40
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/method_called_on_do_end_block.rb#27
RuboCop::Cop::Style::MethodCalledOnDoEndBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MethodDefParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#103
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#103
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#165
  def anonymous_block_arg?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#143
  def arguments_without_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#124
  def correct_arguments(arg_node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#129
  def forced_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#147
  def missing_parentheses(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#138
  def require_parentheses?(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#157
  def unwanted_parentheses(args); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#101
RuboCop::Cop::Style::MethodDefParentheses::MSG_MISSING = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/method_def_parentheses.rb#100
RuboCop::Cop::Style::MethodDefParentheses::MSG_PRESENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MinMax < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#38
  def min_max_candidate(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#22
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#22
  def on_return(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#55
  def argument_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#42
  def message(offender, receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#46
  def offending_range(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/min_max.rb#20
RuboCop::Cop::Style::MinMax::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MissingElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#114
  def on_case(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#120
  def on_case_match(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#107
  def on_normal_if_unless(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#147
  def case_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#126
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#169
  def empty_else_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#159
  def empty_else_cop_enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#163
  def empty_else_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#143
  def if_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#132
  def message_template; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#155
  def unless_else_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#151
  def unless_else_cop_enabled?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#103
RuboCop::Cop::Style::MissingElse::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#105
RuboCop::Cop::Style::MissingElse::MSG_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/missing_else.rb#104
RuboCop::Cop::Style::MissingElse::MSG_NIL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MissingRespondToMissing < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_respond_to_missing.rb#27
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_respond_to_missing.rb#27
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/missing_respond_to_missing.rb#37
  def implements_respond_to_missing?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/missing_respond_to_missing.rb#25
RuboCop::Cop::Style::MissingRespondToMissing::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MixinGrouping < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#40
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#40
  def on_module(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#64
  def check(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#72
  def check_grouped_style(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#91
  def check_separated_style(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#127
  def group_mixins(node, mixins); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#110
  def grouped_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#53
  def range_to_remove_for_subsequent_mixin(mixins, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#118
  def separate_mixins(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#114
  def separated_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#104
  def sibling_mixins(send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#37
RuboCop::Cop::Style::MixinGrouping::MIXIN_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_grouping.rb#38
RuboCop::Cop::Style::MixinGrouping::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MixinUsage < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_usage.rb#54
  def in_top_level_scope?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_usage.rb#48
  def include_statement(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_usage.rb#62
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_usage.rb#44
RuboCop::Cop::Style::MixinUsage::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/mixin_usage.rb#45
RuboCop::Cop::Style::MixinUsage::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ModuleFunction < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#85
  def extend_self_node?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#82
  def module_function_node?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#90
  def on_module(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#88
  def private_directive?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#127
  def check_extend_self(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#133
  def check_forbidden(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#119
  def check_module_function(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#108
  def each_wrong_style(nodes, &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#140
  def message(_range); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#78
RuboCop::Cop::Style::ModuleFunction::EXTEND_SELF_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#79
RuboCop::Cop::Style::ModuleFunction::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/module_function.rb#77
RuboCop::Cop::Style::ModuleFunction::MODULE_FUNCTION_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineBlockChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_block_chain.rb#30
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_block_chain.rb#30
  def on_numblock(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_block_chain.rb#28
RuboCop::Cop::Style::MultilineBlockChain::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineIfModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_modifier.rb#25
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_modifier.rb#43
  def configured_indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_modifier.rb#47
  def indented_body(body, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_modifier.rb#35
  def to_normal_if(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_modifier.rb#22
RuboCop::Cop::Style::MultilineIfModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineIfThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_then.rb#28
  def on_normal_if_unless(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_then.rb#38
  def non_modifier_then?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_then.rb#26
RuboCop::Cop::Style::MultilineIfThen::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_if_then.rb#24
RuboCop::Cop::Style::MultilineIfThen::NON_MODIFIER_THEN = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::MultilineInPatternThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_in_pattern_then.rb#39
  def on_in_pattern(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_in_pattern_then.rb#51
  def require_then?(in_pattern_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_in_pattern_then.rb#37
RuboCop::Cop::Style::MultilineInPatternThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineMemoization < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#55
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#40
  def on_or_asgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#61
  def bad_rhs?(rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#71
  def keyword_autocorrect(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#77
  def keyword_begin_str(node, node_buf); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#86
  def keyword_end_str(node, node_buf); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#38
RuboCop::Cop::Style::MultilineMemoization::BRACES_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_memoization.rb#37
RuboCop::Cop::Style::MultilineMemoization::KEYWORD_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineMethodSignature < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#27
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#27
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#57
  def arguments_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#38
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#69
  def closing_line(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#73
  def correction_exceeds_max_line_length?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#81
  def definition_width(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#77
  def indentation_width(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#53
  def last_line_source_of_arguments(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#85
  def max_line_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#65
  def opening_line(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_method_signature.rb#25
RuboCop::Cop::Style::MultilineMethodSignature::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineTernaryOperator < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#43
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#75
  def enforce_single_line_ternary_operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#57
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#61
  def replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#79
  def use_assignment_method?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#39
RuboCop::Cop::Style::MultilineTernaryOperator::MSG_IF = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#40
RuboCop::Cop::Style::MultilineTernaryOperator::MSG_SINGLE_LINE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_ternary_operator.rb#41
RuboCop::Cop::Style::MultilineTernaryOperator::SINGLE_LINE_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::MultilineWhenThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_when_then.rb#37
  def on_when(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_when_then.rb#58
  def accept_node_type?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_when_then.rb#49
  def require_then?(when_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiline_when_then.rb#35
RuboCop::Cop::Style::MultilineWhenThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultipleComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#49
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#53
  def on_or(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#78
  def simple_comparison_lhs?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#83
  def simple_comparison_rhs?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#75
  def simple_double_comparison?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#151
  def allow_method_comparison?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#126
  def comparison?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#118
  def nested_comparison?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#87
  def nested_variable_comparison?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#146
  def reset_comparison; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#130
  def root_of_or_node(or_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#140
  def switch_comparison?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#114
  def variable_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#93
  def variables_in_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#101
  def variables_in_simple_node(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/multiple_comparison.rb#46
RuboCop::Cop::Style::MultipleComparison::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MutableConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Sorbet::MutableConstantSorbetAwareBehaviour
  include ::RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/mutable_constant_sorbet_aware_behaviour.rb#15
  def on_assignment(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#127
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#224
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#241
  def range_enclosed_in_parentheses?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#217
  def splat_value(param0 = T.unsafe(nil)); end

  # source://rubocop-sorbet//lib/rubocop/cop/sorbet/mutable_constant_sorbet_aware_behaviour.rb#10
  def t_let(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#169
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#158
  def check(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#208
  def correct_splat_expansion(corrector, expr, splat_value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#200
  def frozen_regexp_or_range_literals?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#190
  def immutable_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#184
  def mutable_literal?(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#204
  def requires_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#194
  def shareable_constant_value?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#149
  def strict_check(value); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#125
RuboCop::Cop::Style::MutableConstant::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#102
  def magic_comment_in_scope(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#110
  def processed_source_till_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#91
  def recent_shareable_value?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#114
  def shareable_constant_value_enabled?(value); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#102
    def magic_comment_in_scope(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/mutable_constant.rb#91
    def recent_shareable_value?(node); end
  end
end

class RuboCop::Cop::Style::NegatedIf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if.rb#76
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if.rb#92
  def correct_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if.rb#88
  def message(node); end
end

class RuboCop::Cop::Style::NegatedIfElseCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#39
  def double_negation?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#49
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#45
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#83
  def correct_negated_condition(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#79
  def corrected_ancestor?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#118
  def else_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#69
  def if_else?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#109
  def if_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#74
  def negated_condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#96
  def swap_branches(corrector, node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#41
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#34
RuboCop::Cop::Style::NegatedIfElseCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/negated_if_else_condition.rb#36
RuboCop::Cop::Style::NegatedIfElseCondition::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NegatedUnless < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_unless.rb#66
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_unless.rb#82
  def correct_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_unless.rb#78
  def message(node); end
end

class RuboCop::Cop::Style::NegatedWhile < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_while.rb#29
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/negated_while.rb#29
  def on_while(node); end
end

class RuboCop::Cop::Style::NestedFileDirname < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_file_dirname.rb#28
  def file_dirname?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_file_dirname.rb#33
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_file_dirname.rb#60
  def offense_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_file_dirname.rb#49
  def path_with_dir_level(node, level); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/nested_file_dirname.rb#22
RuboCop::Cop::Style::NestedFileDirname::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/nested_file_dirname.rb#23
RuboCop::Cop::Style::NestedFileDirname::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NestedModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#22
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#22
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#22
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#85
  def add_parentheses_to_method_arguments(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#42
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#30
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#65
  def left_hand_operand(node, operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#38
  def modifier?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#51
  def new_expression(inner_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#61
  def replacement_operator(keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#94
  def requires_parens?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#71
  def right_hand_operand(node, left_hand_keyword); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/nested_modifier.rb#20
RuboCop::Cop::Style::NestedModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NestedParenthesizedCalls < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#35
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#35
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#71
  def allowed?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#65
  def allowed_omission?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#51
  def autocorrect(corrector, nested); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#31
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/nested_parenthesized_calls.rb#29
RuboCop::Cop::Style::NestedParenthesizedCalls::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NestedTernaryOperator < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_ternary_operator.rb#25
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_ternary_operator.rb#48
  def autocorrect(corrector, if_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_ternary_operator.rb#41
  def if_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_ternary_operator.rb#55
  def remove_parentheses(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nested_ternary_operator.rb#61
  def replace_loc_and_whitespace(corrector, range, replacement); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/nested_ternary_operator.rb#23
RuboCop::Cop::Style::NestedTernaryOperator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Next < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#68
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#76
  def on_for(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#62
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#68
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#76
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#76
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#213
  def actual_indent(lines, buffer); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#112
  def allowed_modifier_if?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#155
  def autocorrect_block(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#145
  def autocorrect_modifier(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#84
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#170
  def cond_range(node, cond); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#189
  def end_followed_by_whitespace_only?(source_buffer, end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#180
  def end_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#98
  def ends_with_condition?(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#128
  def exit_body_type?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#217
  def heredoc_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#120
  def if_else_children?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#124
  def if_without_else?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#140
  def offense_location(offense_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#134
  def offense_node(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#204
  def reindent(lines, node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#224
  def reindent_line(corrector, lineno, delta, buffer); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#193
  def reindentable_lines(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#104
  def simple_if_without_break?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#58
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#56
RuboCop::Cop::Style::Next::EXIT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/next.rb#55
RuboCop::Cop::Style::Next::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NilComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#44
  def nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#41
  def nil_comparison?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#46
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#65
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#77
  def prefer_comparison?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#69
  def style_check?(node, &block); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#36
RuboCop::Cop::Style::NilComparison::EXPLICIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#35
RuboCop::Cop::Style::NilComparison::PREDICATE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/nil_comparison.rb#38
RuboCop::Cop::Style::NilComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NilLambda < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_lambda.rb#42
  def nil_return?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_lambda.rb#46
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/nil_lambda.rb#58
  def autocorrect(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/nil_lambda.rb#39
RuboCop::Cop::Style::NilLambda::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NonNilCheck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#59
  def nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#62
  def not_and_nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#53
  def not_equal_to_nil?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#73
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#73
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#64
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#56
  def unless_check?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#93
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#123
  def autocorrect_comparison(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#137
  def autocorrect_non_nil(corrector, node, inner_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#145
  def autocorrect_unless_nil(corrector, node, receiver); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#119
  def include_semantic_changes?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#110
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#150
  def nil_comparison_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#88
  def register_offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#104
  def unless_and_nil_check?(send_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#48
RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REDUNDANCY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#47
RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REPLACEMENT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/non_nil_check.rb#50
RuboCop::Cop::Style::NonNilCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Not < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#32
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#60
  def correct_opposite_method(corrector, range, child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#65
  def correct_with_parens(corrector, range, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#70
  def correct_without_parens(corrector, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#50
  def opposite_method?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#54
  def requires_parens?(child); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#20
RuboCop::Cop::Style::Not::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#23
RuboCop::Cop::Style::Not::OPPOSITE_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/not.rb#21
RuboCop::Cop::Style::Not::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NumberedParameters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters.rb#36
  def on_numblock(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters.rb#31
RuboCop::Cop::Style::NumberedParameters::MSG_DISALLOW = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters.rb#32
RuboCop::Cop::Style::NumberedParameters::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NumberedParametersLimit < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters_limit.rb#30
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters_limit.rb#41
  def max_count; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters_limit.rb#23
RuboCop::Cop::Style::NumberedParametersLimit::DEFAULT_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numbered_parameters_limit.rb#28
RuboCop::Cop::Style::NumberedParametersLimit::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NumericLiteralPrefix < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IntegerNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#52
  def on_int(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#109
  def format_binary(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#113
  def format_decimal(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#105
  def format_hex(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#97
  def format_octal(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#101
  def format_octal_zero_only(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#82
  def hex_bin_dec_literal_type(literal); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#68
  def literal_type(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#64
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#74
  def octal_literal_type(literal); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#93
  def octal_zero_only?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#49
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#43
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#50
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#44
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#48
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#42
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#47
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#41
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#46
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literal_prefix.rb#40
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::NumericLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IntegerNode
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#11
  def min_digits=(value); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#60
  def on_float(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#56
  def on_int(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#118
  def allowed_numbers; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#122
  def allowed_patterns; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#66
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#107
  def format_int_part(int_part); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#93
  def format_number(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#114
  def min_digits; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#82
  def register_offense(node, &_block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#89
  def short_group_regex; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#49
RuboCop::Cop::Style::NumericLiterals::DELIMITER_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_literals.rb#48
RuboCop::Cop::Style::NumericLiterals::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NumericPredicate < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#166
  def comparison(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#171
  def inverted_comparison(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#90
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#161
  def predicate(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#107
  def allowed_method_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#111
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#152
  def invert; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#132
  def parenthesized_source(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#124
  def replacement(numeric, operation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#144
  def replacement_supported?(operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#140
  def require_parentheses?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#84
RuboCop::Cop::Style::NumericPredicate::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#86
RuboCop::Cop::Style::NumericPredicate::REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/numeric_predicate.rb#88
RuboCop::Cop::Style::NumericPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ObjectThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#31
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#31
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#37
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#45
  def check_method_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#65
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#54
  def preferred_method(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/object_then.rb#29
RuboCop::Cop::Style::ObjectThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OneLineConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#41
  def on_normal_if_unless(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#76
  def always_multiline?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#58
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#80
  def cannot_replace_to_ternary?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#92
  def expr_replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#120
  def indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#113
  def keyword_with_changed_precedence?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#54
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#106
  def method_call_with_changed_precedence?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#98
  def requires_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#66
  def ternary_correction(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#84
  def ternary_replacement(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/one_line_conditional.rb#38
RuboCop::Cop::Style::OneLineConditional::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OpenStructUse < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/open_struct_use.rb#52
  def on_const(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/open_struct_use.rb#48
  def uses_open_struct?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/open_struct_use.rb#61
  def custom_class_or_module_definition?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/open_struct_use.rb#45
RuboCop::Cop::Style::OpenStructUse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OptionHash < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/option_hash.rb#30
  def on_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/option_hash.rb#26
  def option_hash(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/option_hash.rb#39
  def allowlist; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/option_hash.rb#48
  def super_used?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/option_hash.rb#43
  def suspicious_name?(arg_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/option_hash.rb#23
RuboCop::Cop::Style::OptionHash::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OptionalArguments < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/optional_arguments.rb#27
  def on_def(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/optional_arguments.rb#45
  def argument_positions(arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/optional_arguments.rb#33
  def each_misplaced_optional_arg(arguments); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/optional_arguments.rb#25
RuboCop::Cop::Style::OptionalArguments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OptionalBooleanParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  # source://rubocop/1.36.0/lib/rubocop/cop/style/optional_boolean_parameter.rb#43
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/optional_boolean_parameter.rb#43
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/optional_boolean_parameter.rb#56
  def format_message(argument); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/optional_boolean_parameter.rb#40
RuboCop::Cop::Style::OptionalBooleanParameter::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OrAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#57
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#57
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#51
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#57
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#57
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#35
  def ternary_assignment?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#44
  def unless_assignment?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#70
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#80
  def take_variable_and_default_from_ternary(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#85
  def take_variable_and_default_from_unless(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/or_assignment.rb#32
RuboCop::Cop::Style::OrAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ParallelAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#115
  def implicit_self_getter?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#31
  def on_masgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#108
  def add_self_to_getters(right_elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#60
  def allowed_lhs?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#54
  def allowed_masign?(lhs_elements, rhs_elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#68
  def allowed_rhs?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#80
  def assignment_corrector(node, order); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#44
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#91
  def find_valid_order(left_elements, right_elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#174
  def modifier_statement?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#76
  def return_of_method_call?(node); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#132
  def initialize(assignments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#161
  def accesses?(rhs, lhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#154
  def dependency?(lhs, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#130
  def matching_calls(param0, param1, param2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#140
  def tsort_each_child(assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#136
  def tsort_each_node(&block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#127
  def uses_var?(param0, param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#124
  def var_name(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#184
  def initialize(node, config, new_elements); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#182
  def config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#190
  def correction; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#194
  def correction_range; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#182
  def node; end

  protected

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#200
  def assignment; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#220
  def cop_config; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#216
  def extract_sources(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#206
  def source(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#29
RuboCop::Cop::Style::ParallelAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#266
  def correction; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#275
  def correction_range; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#281
  def modifier_range(node); end
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#228
  def correction; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#242
  def correction_range; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#253
  def begin_correction(rescue_result); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parallel_assignment.rb#248
  def def_correction(rescue_result); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#76
  def control_op_condition(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#62
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#68
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#68
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#122
  def allow_multiline_conditions?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#110
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#103
  def modifier_op?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#116
  def parens_allowed?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#80
  def process_control_op(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/parentheses_around_condition.rb#95
  def semicolon_separated_expressions?(first_exp, rest_exps); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#30
  def on_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#38
  def on_dstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#34
  def on_regexp(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#38
  def on_str(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#43
  def on_sym(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#47
  def on_xstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#93
  def contains_delimiter?(node, delimiters); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#82
  def contains_preferred_delimiter?(node, type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#86
  def include_same_character_as_used_for_delimiter?(node, type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#108
  def matchpairs(begin_delimiter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#67
  def message(type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#53
  def on_percent_literal(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#74
  def preferred_delimiters_for(type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#100
  def string_source(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_literal_delimiters.rb#78
  def uses_preferred_delimiter?(node, type); end
end

class RuboCop::Cop::Style::PercentQLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#36
  def on_str(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#55
  def correct_literal_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#64
  def corrected(src); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#60
  def message(_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#42
  def on_percent_literal(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#33
RuboCop::Cop::Style::PercentQLiterals::LOWER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/percent_q_literals.rb#34
RuboCop::Cop::Style::PercentQLiterals::UPPER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::PerlBackrefs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#21
  def on_back_ref(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#25
  def on_gvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#29
  def on_nth_ref(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#99
  def constant_prefix(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#38
  def derived_from_braceless_interpolation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#46
  def format_message(node:, preferred_expression:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#109
  def on_back_ref_or_gvar_or_nth_ref(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#58
  def original_expression_of(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#70
  def preferred_expression_to(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#89
  def preferred_expression_to_node_with_constant_prefix(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/perl_backrefs.rb#19
RuboCop::Cop::Style::PerlBackrefs::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::PreferredHashMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#43
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#43
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#56
  def message(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#68
  def offending_selector?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#60
  def proper_method_name(method_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#37
RuboCop::Cop::Style::PreferredHashMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#39
RuboCop::Cop::Style::PreferredHashMethods::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/preferred_hash_methods.rb#41
RuboCop::Cop::Style::PreferredHashMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Proc < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/proc.rb#25
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/proc.rb#25
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/proc.rb#22
  def proc_new?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/proc.rb#19
RuboCop::Cop::Style::Proc::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::QuotedSymbols < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  include ::RuboCop::Cop::StringLiteralsHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#44
  def on_sym(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#108
  def alternative_style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#71
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#88
  def correct_quotes(str); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#83
  def hash_colon_key?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#61
  def invalid_double_quotes?(source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#112
  def quoted?(sym_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#99
  def style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#116
  def wrong_quotes?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#41
RuboCop::Cop::Style::QuotedSymbols::MSG_DOUBLE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/quoted_symbols.rb#39
RuboCop::Cop::Style::QuotedSymbols::MSG_SINGLE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RaiseArgs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#53
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#129
  def acceptable_exploded_args?(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#143
  def allowed_non_exploded_type?(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#92
  def check_compact(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#108
  def check_exploded(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#66
  def correction_compact_to_exploded(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#78
  def correction_exploded_to_compact(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#149
  def requires_parens?(parent); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#125
  def use_new_method?(first_arg); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#49
RuboCop::Cop::Style::RaiseArgs::COMPACT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#48
RuboCop::Cop::Style::RaiseArgs::EXPLODED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/raise_args.rb#51
RuboCop::Cop::Style::RaiseArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RandomWithOffset < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#33
  def integer_op_rand?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#63
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#54
  def rand_modified?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#43
  def rand_op_integer?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#73
  def random_call(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#147
  def to_int(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#78
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#135
  def boundaries_from_random_node(random_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#88
  def corrected_integer_op_rand(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#118
  def corrected_rand_modified(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#103
  def corrected_rand_op_integer(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#131
  def prefix_from_prefix_node(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#29
RuboCop::Cop::Style::RandomWithOffset::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/random_with_offset.rb#30
RuboCop::Cop::Style::RandomWithOffset::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_argument.rb#56
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_argument.rb#85
  def argument_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_argument.rb#78
  def redundant_arg_for_method(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_argument.rb#71
  def redundant_argument?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_argument.rb#54
RuboCop::Cop::Style::RedundantArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#50
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#50
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#46
  def redundant_assignment?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#91
  def check_begin_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#57
  def check_branch(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#71
  def check_case_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#87
  def check_ensure_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#76
  def check_if_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#83
  def check_rescue_node(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_assignment.rb#43
RuboCop::Cop::Style::RedundantAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantBegin < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#72
  def offensive_kwbegins(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#83
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#76
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#76
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#94
  def on_kwbegin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#83
  def on_numblock(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#102
  def allowable_kwbegin?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#168
  def begin_block_has_multiline_statements?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#160
  def condition_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#172
  def contain_rescue_or_ensure?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#153
  def correct_modifier_form_after_multiline_begin_block(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#164
  def empty_begin?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#109
  def register_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#126
  def replace_begin_with_statement(corrector, offense_range, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#140
  def restore_removed_comments(corrector, offense_range, node, first_child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#147
  def use_modifier_form_after_multiline_begin_block?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#185
  def valid_begin_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#178
  def valid_context_using_only_begin?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_begin.rb#69
RuboCop::Cop::Style::RedundantBegin::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantCapitalW < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_capital_w.rb#23
  def on_array(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_capital_w.rb#29
  def on_percent_literal(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_capital_w.rb#38
  def requires_interpolation?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_capital_w.rb#21
RuboCop::Cop::Style::RedundantCapitalW::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#40
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#139
  def asgn_type?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#129
  def branches_have_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#143
  def branches_have_method?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#222
  def correct_ternary(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#169
  def else_source(else_branch, arithmetic_operation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#195
  def else_source_if_has_assignment(else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#185
  def else_source_if_has_method(else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#157
  def if_source(if_branch, arithmetic_operation); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#205
  def make_ternary_form(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#61
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#76
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#69
  def range_of_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#85
  def redundant_condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#237
  def require_braces?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#230
  def require_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#153
  def same_method?(if_branch, else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#101
  def synonymous_condition_and_branch?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#241
  def use_arithmetic_operation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#97
  def use_hash_key_access?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#93
  def use_hash_key_assignment?(else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#89
  def use_if_branch?(else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#245
  def without_argument_parentheses_method?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#37
RuboCop::Cop::Style::RedundantCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_condition.rb#38
RuboCop::Cop::Style::RedundantCondition::REDUNDANT_CONDITION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#36
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#56
  def redundant_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#61
  def redundant_condition_inverted?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#90
  def configured_indentation_width; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#86
  def indented_else_node(expression, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#78
  def invert_expression?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#48
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#65
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#71
  def replacement_condition(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#32
RuboCop::Cop::Style::RedundantConditional::COMPARISON_OPERATOR_MATCHER = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_conditional.rb#34
RuboCop::Cop::Style::RedundantConditional::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantException < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#59
  def compact?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#54
  def exploded?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#45
  def fix_compact(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#33
  def fix_exploded(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#29
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#22
RuboCop::Cop::Style::RedundantException::MSG_1 = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#23
RuboCop::Cop::Style::RedundantException::MSG_2 = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_exception.rb#25
RuboCop::Cop::Style::RedundantException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantFetchBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#53
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#87
  def rails_cache?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#46
  def redundant_fetch_block_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#72
  def basic_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#102
  def build_bad_method(send, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#95
  def build_good_method(send, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#109
  def check_for_constant?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#113
  def check_for_string?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#76
  def const_type?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#91
  def fetch_range(send, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#80
  def should_not_check?(send, body); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_fetch_block.rb#43
RuboCop::Cop::Style::RedundantFetchBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantFileExtensionInRequire < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_file_extension_in_require.rb#39
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_file_extension_in_require.rb#35
  def require_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_file_extension_in_require.rb#53
  def extension_range(name_node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_file_extension_in_require.rb#31
RuboCop::Cop::Style::RedundantFileExtensionInRequire::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_file_extension_in_require.rb#32
RuboCop::Cop::Style::RedundantFileExtensionInRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantFreeze < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_freeze.rb#26
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_freeze.rb#57
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_freeze.rb#39
  def immutable_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_freeze.rb#48
  def strip_parenthesis(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_freeze.rb#23
RuboCop::Cop::Style::RedundantFreeze::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_freeze.rb#24
RuboCop::Cop::Style::RedundantFreeze::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantInitialize < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#106
  def initialize_forwards?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#110
  def on_def(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#134
  def acceptable?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#142
  def allow_comments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#138
  def forwards?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#128
  def register_offense(node, message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#146
  def same_args?(super_node, args); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#102
RuboCop::Cop::Style::RedundantInitialize::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_initialize.rb#103
RuboCop::Cop::Style::RedundantInitialize::MSG_EMPTY = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#49
  def on_dstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#122
  def autocorrect_other(corrector, embedded_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#105
  def autocorrect_single_variable_interpolation(corrector, embedded_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#99
  def autocorrect_variable_interpolation(corrector, embedded_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#95
  def embedded_in_percent_array?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#91
  def implicit_concatenation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#83
  def interpolation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#132
  def require_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#67
  def single_interpolation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#74
  def single_variable_interpolation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#87
  def variable_interpolation?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#45
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_interpolation.rb#43
RuboCop::Cop::Style::RedundantInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Parentheses
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#33
  def allowed_pin_operator?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#36
  def arg_in_call_with_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#220
  def first_send_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#225
  def first_super_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#230
  def first_yield_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#138
  def interpolation?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#27
  def method_node_and_args(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#38
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#24
  def range_end?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#30
  def rescue?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#21
  def square_brackets?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#68
  def allowed_ancestor?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#61
  def allowed_expression?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#73
  def allowed_method_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#78
  def allowed_multiple_expression?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#87
  def allowed_ternary?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#234
  def call_chain_starts_with_int?(begin_node, send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#125
  def check(begin_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#140
  def check_send(begin_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#149
  def check_unary(begin_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#173
  def disallowed_literal?(begin_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#105
  def empty_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#110
  def first_arg_begins_with_hash_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#215
  def first_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#54
  def ignore_syntax?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#169
  def keyword_ancestor?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#188
  def keyword_with_redundant_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#100
  def like_method_argument_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#201
  def method_call_with_redundant_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#117
  def method_chain_begins_with_hash_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#159
  def offense(node, msg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#211
  def only_begin_arg?(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#46
  def parens_allowed?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#177
  def raised_to_power_negative_numeric?(begin_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#165
  def suspect_unary?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_parentheses.rb#93
  def ternary_parentheses_required?; end
end

class RuboCop::Cop::Style::RedundantPercentQ < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#34
  def on_dstr(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#40
  def on_str(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#99
  def acceptable_capital_q?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#91
  def acceptable_q?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#67
  def allowed_percent_q?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#51
  def check(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#63
  def interpolated_quotes?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#72
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#87
  def start_with_percent_q_variant?(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#82
  def string_literal?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#25
RuboCop::Cop::Style::RedundantPercentQ::DYNAMIC_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#28
RuboCop::Cop::Style::RedundantPercentQ::EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#32
RuboCop::Cop::Style::RedundantPercentQ::ESCAPED_NON_BACKSLASH = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#23
RuboCop::Cop::Style::RedundantPercentQ::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#30
RuboCop::Cop::Style::RedundantPercentQ::PERCENT_CAPITAL_Q = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#29
RuboCop::Cop::Style::RedundantPercentQ::PERCENT_Q = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#27
RuboCop::Cop::Style::RedundantPercentQ::QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#26
RuboCop::Cop::Style::RedundantPercentQ::SINGLE_QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_percent_q.rb#31
RuboCop::Cop::Style::RedundantPercentQ::STRING_INTERPOLATION_REGEXP = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::RedundantRegexpCharacterClass < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#37
  def on_regexp(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#101
  def backslash_b?(elem); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#53
  def each_redundant_character_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#61
  def each_single_element_character_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#83
  def multiple_codepoins?(expression); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#72
  def redundant_single_element_character_class?(node, char_class); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#107
  def requires_escape_outside_char_class?(elem); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#95
  def whitespace_in_free_space_mode?(node, elem); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#87
  def without_character_class(loc); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#34
RuboCop::Cop::Style::RedundantRegexpCharacterClass::MSG_REDUNDANT_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_character_class.rb#33
RuboCop::Cop::Style::RedundantRegexpCharacterClass::REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantRegexpEscape < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#45
  def on_regexp(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#59
  def allowed_escape?(node, char, within_character_class); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#74
  def delimiter?(node, char); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#81
  def each_escape(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#108
  def escape_range_at_index(node, index); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#41
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_ALWAYS_ESCAPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#43
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#42
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_regexp_escape.rb#39
RuboCop::Cop::Style::RedundantRegexpEscape::MSG_REDUNDANT_ESCAPE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantReturn < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#57
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#57
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#92
  def add_braces(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#87
  def add_brackets(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#157
  def allow_multiple_return_values?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#152
  def check_begin_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#98
  def check_branch(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#126
  def check_case_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#147
  def check_ensure_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#131
  def check_if_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#143
  def check_resbody_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#138
  def check_rescue_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#114
  def check_return_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#68
  def correct_with_arguments(return_node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#64
  def correct_without_arguments(return_node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#83
  def hash_without_braces?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#161
  def message(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#54
RuboCop::Cop::Style::RedundantReturn::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_return.rb#55
RuboCop::Cop::Style::RedundantReturn::MULTI_RETURN_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSelf < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#59
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#67
  def on_and_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#85
  def on_args(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#119
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#89
  def on_blockarg(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#80
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#80
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#125
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#103
  def on_in_pattern(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#98
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#93
  def on_masgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#119
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#73
  def on_op_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#67
  def on_or_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#107
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#125
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#125
  def on_while(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#181
  def add_lhs_to_local_variables_scopes(rhs, lhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#189
  def add_masgn_lhs_variables(rhs, lhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#195
  def add_match_var_scopes(in_pattern_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#143
  def add_scope(node, local_variables = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#175
  def allow_self(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#149
  def allowed_send_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#166
  def on_argument(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#158
  def regular_method_call?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#55
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#48
RuboCop::Cop::Style::RedundantSelf::KERNEL_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#49
RuboCop::Cop::Style::RedundantSelf::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self.rb#47
RuboCop::Cop::Style::RedundantSelf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSelfAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_lvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#69
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#96
  def redundant_nonself_assignment?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#86
  def redundant_self_assignment?(param0 = T.unsafe(nil), param1); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#112
  def correction_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#81
  def method_returning_self?(method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#105
  def redundant_assignment?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#45
RuboCop::Cop::Style::RedundantSelfAssignment::ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#38
RuboCop::Cop::Style::RedundantSelfAssignment::METHODS_RETURNING_SELF = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment.rb#35
RuboCop::Cop::Style::RedundantSelfAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#32
  def bad_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#36
  def on_lvasgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#59
  def inconvertible_to_modifier?(if_branch, else_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#64
  def multiple_statements?(branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#72
  def register_offense(if_node, offense_branch, opposite_branch, keyword); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#68
  def self_assign?(variable, branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#53
  def use_if_and_else_branch?(expression); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_self_assignment_branch.rb#29
RuboCop::Cop::Style::RedundantSelfAssignmentBranch::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSort < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#104
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#88
  def redundant_sort?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#192
  def accessor_start(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#182
  def arg_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#186
  def arg_value(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#147
  def autocorrect(corrector, node, sort_node, sorter, accessor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#165
  def base(accessor, arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#114
  def find_redundant_sort(*nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#135
  def message(node, sorter, accessor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#131
  def offense_range(sort_node, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#124
  def register_offense(node, sort_node, sorter, accessor); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#156
  def replace_with_logical_operator(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#173
  def suffix(sorter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#161
  def suggestion(sorter, accessor, arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#200
  def with_logical_operator?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#83
RuboCop::Cop::Style::RedundantSort::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort.rb#85
RuboCop::Cop::Style::RedundantSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantSortBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#25
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#35
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#48
  def redundant_sort_by_block(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#53
  def redundant_sort_by_numblock(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#57
  def sort_by_range(send, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#22
RuboCop::Cop::Style::RedundantSortBy::MSG_BLOCK = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/redundant_sort_by.rb#23
RuboCop::Cop::Style::RedundantSortBy::MSG_NUMBLOCK = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RegexpLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#92
  def on_regexp(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#135
  def allow_inner_slashes?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#123
  def allowed_mixed_percent_r?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#113
  def allowed_mixed_slash?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#152
  def allowed_omit_parentheses_with_percent_r_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#117
  def allowed_percent_r_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#109
  def allowed_slash_literal?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#212
  def calculate_replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#127
  def contains_disallowed_slash?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#131
  def contains_slash?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#161
  def correct_delimiters(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#167
  def correct_inner_slashes(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#200
  def inner_slash_after_correction(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#196
  def inner_slash_before_correction(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#204
  def inner_slash_for(opening_delimiter); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#183
  def inner_slash_indices(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#139
  def node_body(node, include_begin_nodes: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#148
  def preferred_delimiters; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#144
  def slash_literal?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#90
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_PERCENT_R = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/regexp_literal.rb#89
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_SLASHES = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RescueModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RescueNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_modifier.rb#54
  def on_resbody(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_modifier.rb#72
  def correct_rescue_block(corrector, node, parenthesized); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_modifier.rb#88
  def indentation_and_offset(node, parenthesized); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_modifier.rb#68
  def parenthesized?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_modifier.rb#50
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_modifier.rb#48
RuboCop::Cop::Style::RescueModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RescueStandardError < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#92
  def on_resbody(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#88
  def rescue_standard_error?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#83
  def rescue_without_error_class?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#118
  def offense_for_explicit_enforced_style(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#107
  def offense_for_implicit_enforced_style(node, error); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#80
RuboCop::Cop::Style::RescueStandardError::MSG_EXPLICIT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/rescue_standard_error.rb#79
RuboCop::Cop::Style::RescueStandardError::MSG_IMPLICIT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ReturnNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#86
  def chained_send?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#89
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#44
  def on_return(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#42
  def return_nil_node?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#39
  def return_node?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#76
  def correct_style?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#72
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#81
  def scoped_node?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#35
RuboCop::Cop::Style::ReturnNil::RETURN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/return_nil.rb#36
RuboCop::Cop::Style::ReturnNil::RETURN_NIL_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#121
  def check_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#94
  def modifier_if_safe_navigation_candidate(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#109
  def not_nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#117
  def on_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#111
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#132
  def use_var_only_in_unless_modifier?(node, variable); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#278
  def add_safe_nav_to_all_methods_in_chain(corrector, start_method, method_chain); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#176
  def allowed_if_condition?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#138
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#270
  def begin_range(node, method_call); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#232
  def chain_length(method_chain, method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#157
  def comments(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#274
  def end_range(node, method_call); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#214
  def extract_common_parts(method_chain, checked_variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#185
  def extract_parts(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#204
  def extract_parts_from_and(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#194
  def extract_parts_from_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#222
  def find_matching_receiver_invocation(method_chain, checked_variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#150
  def handle_comments(corrector, node, method_call); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#291
  def max_chain_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#180
  def method_call(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#266
  def method_called?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#258
  def negated?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#163
  def relevant_comment_ranges(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#252
  def unsafe_method?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#240
  def unsafe_method_used?(method_chain, method); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#87
RuboCop::Cop::Style::SafeNavigation::LOGIC_JUMP_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/safe_navigation.rb#85
RuboCop::Cop::Style::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Sample < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#41
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#37
  def sample_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#123
  def correction(shuffle_arg, method, method_args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#139
  def extract_source(args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#117
  def message(shuffle_arg, method, method_args, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#58
  def offensive?(method, method_args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#95
  def range_size(range_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#130
  def sample_arg(method, method_args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#69
  def sample_size(method_args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#78
  def sample_size_for_one_arg(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#88
  def sample_size_for_two_args(first, second); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#111
  def source_range(shuffle_node, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#33
RuboCop::Cop::Style::Sample::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/sample.rb#34
RuboCop::Cop::Style::Sample::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SelectByRegexp < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#78
  def calls_lvar?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#64
  def creates_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#73
  def env_const?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#86
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#55
  def regexp_match?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#118
  def extract_send_node(block_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#127
  def find_regexp(node, block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#138
  def match_predicate_without_receiver?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#99
  def receiver_allowed?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#105
  def register_offense(node, block_node, regexp); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#49
RuboCop::Cop::Style::SelectByRegexp::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#52
RuboCop::Cop::Style::SelectByRegexp::REGEXP_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#51
RuboCop::Cop::Style::SelectByRegexp::REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/select_by_regexp.rb#50
RuboCop::Cop::Style::SelectByRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SelfAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#33
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#29
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#25
  def on_lvasgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#94
  def apply_autocorrect(corrector, node, rhs, operator, new_rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#74
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#89
  def autocorrect_boolean_node(corrector, node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#84
  def autocorrect_send_node(corrector, node, rhs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#39
  def check(node, var_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#62
  def check_boolean_node(node, rhs, var_name, var_type); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#50
  def check_send_node(node, rhs, var_name, var_type); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#21
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#18
RuboCop::Cop::Style::SelfAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/self_assignment.rb#19
RuboCop::Cop::Style::SelfAssignment::OPS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Semicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#45
  def on_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#39
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#63
  def check_for_line_terminator_or_opener; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#72
  def each_semicolon; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#103
  def expressions_per_line(exprs); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#117
  def find_range_node(token_before_semicolon); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#109
  def find_semicolon_positions(line); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#123
  def range_nodes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#83
  def register_semicolon(line, column, after_expression, token_before_semicolon = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#79
  def tokens_for_lines; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#35
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/semicolon.rb#33
RuboCop::Cop::Style::Semicolon::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Send < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/send.rb#20
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/send.rb#20
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/send.rb#17
RuboCop::Cop::Style::Send::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/send.rb#18
RuboCop::Cop::Style::Send::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SignalException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#120
  def custom_fail_methods(param0); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#117
  def kernel_call?(param0 = T.unsafe(nil), param1); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#122
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#127
  def on_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#139
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#204
  def allow(method_name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#186
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#165
  def check_scope(method_name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#178
  def check_send(method_name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#198
  def command_or_kernel_call?(name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#208
  def each_command_or_kernel_call(method_name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#154
  def message(method_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#111
RuboCop::Cop::Style::SignalException::FAIL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#112
RuboCop::Cop::Style::SignalException::RAISE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/signal_exception.rb#114
RuboCop::Cop::Style::SignalException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SingleArgumentDig < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_argument_dig.rb#42
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_argument_dig.rb#38
  def single_argument_dig?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/single_argument_dig.rb#34
RuboCop::Cop::Style::SingleArgumentDig::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/single_argument_dig.rb#35
RuboCop::Cop::Style::SingleArgumentDig::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SingleLineBlockParams < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#36
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#105
  def args_match?(method_name, args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#69
  def autocorrect(corrector, node, preferred_block_arguments, joined_block_arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#57
  def build_preferred_arguments_map(node, preferred_arguments); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#79
  def eligible_arguments?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#83
  def eligible_method?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#95
  def method_name(method); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#91
  def method_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#87
  def methods; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#99
  def target_args(method_name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_block_params.rb#34
RuboCop::Cop::Style::SingleLineBlockParams::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SingleLineMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#41
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#41
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#60
  def allow_empty?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#52
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#97
  def break_line_before(corrector, node, range, indent_steps: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#88
  def correct_to_endless(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#64
  def correct_to_endless?(body_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#74
  def correct_to_multiline(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#136
  def disallow_endless_method_style?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#104
  def each_part(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#121
  def method_body_source(method_body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#114
  def move_comment(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#132
  def require_parentheses?(method_body); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#38
RuboCop::Cop::Style::SingleLineMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/single_line_methods.rb#39
RuboCop::Cop::Style::SingleLineMethods::NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SlicingWithRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/slicing_with_range.rb#40
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/slicing_with_range.rb#38
  def range_till_minus_one?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/slicing_with_range.rb#34
RuboCop::Cop::Style::SlicingWithRange::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/slicing_with_range.rb#35
RuboCop::Cop::Style::SlicingWithRange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SoleNestedConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#59
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#238
  def allow_modifier?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#223
  def arguments_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#81
  def assigned_variables(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#98
  def autocorrect(corrector, node, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#110
  def autocorrect_outer_condition_basic(corrector, node, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#125
  def autocorrect_outer_condition_modify_form(corrector, node, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#145
  def correct_for_basic_condition_style(corrector, node, if_branch, and_operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#175
  def correct_for_comment(corrector, node, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#136
  def correct_for_guard_condition_style(corrector, outer_condition, if_branch, and_operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#165
  def correct_for_outer_condition_modify_form_style(corrector, node, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#130
  def correct_from_unless_to_if(corrector, node, is_modify_form: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#182
  def correct_outer_condition(corrector, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#193
  def insert_bang(corrector, node, is_modify_form); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#206
  def insert_bang_for_and(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#89
  def offending_branch?(node, branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#242
  def outer_condition_modify_form?(node, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#234
  def replace_condition(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#218
  def require_parentheses?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#74
  def use_variable_assignment_in_condition?(condition, if_branch); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#155
  def wrap_condition(corrector, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#229
  def wrap_condition?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#55
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/sole_nested_conditional.rb#53
RuboCop::Cop::Style::SoleNestedConditional::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SpecialGlobalVars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RequireLibrary
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#177
  def autocorrect(corrector, node, global_var); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#169
  def message(global_var); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#153
  def on_gvar(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#148
  def on_new_investigation; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#248
  def add_require_english?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#242
  def english_name_replacement(preferred_name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#191
  def format_english_message(global_var); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#213
  def format_list(items); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#199
  def format_message(english, regular, global); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#236
  def matching_styles(global); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#228
  def preferred_names(global); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#217
  def replacement(node, global_var); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#252
  def should_require_english?(global_var); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#129
RuboCop::Cop::Style::SpecialGlobalVars::BUILTIN_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#101
RuboCop::Cop::Style::SpecialGlobalVars::ENGLISH_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#146
RuboCop::Cop::Style::SpecialGlobalVars::LIBRARY_NAME = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#94
RuboCop::Cop::Style::SpecialGlobalVars::MSG_BOTH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#97
RuboCop::Cop::Style::SpecialGlobalVars::MSG_ENGLISH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#99
RuboCop::Cop::Style::SpecialGlobalVars::MSG_REGULAR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#123
RuboCop::Cop::Style::SpecialGlobalVars::NON_ENGLISH_VARS = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#125
RuboCop::Cop::Style::SpecialGlobalVars::PERL_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/style/special_global_vars.rb#140
RuboCop::Cop::Style::SpecialGlobalVars::STYLE_VARS_MAP = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::StabbyLambdaParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#28
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#54
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#46
  def missing_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#58
  def missing_parentheses_corrector(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#73
  def parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#50
  def redundant_parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#69
  def stabby_lambda_with_args?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#62
  def unwanted_parentheses_corrector(corrector, node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#27
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_NO_REQUIRE = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/stabby_lambda_parentheses.rb#26
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_REQUIRE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StaticClass < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp

  # source://rubocop/1.36.0/lib/rubocop/cop/style/static_class.rb#51
  def on_class(class_node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/static_class.rb#59
  def class_convertible_to_module?(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/static_class.rb#83
  def class_elements(class_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/static_class.rb#71
  def extend_call?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/static_class.rb#75
  def sclass_convertible_to_module?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/static_class.rb#49
RuboCop::Cop::Style::StaticClass::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StderrPuts < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#32
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#25
  def stderr_puts?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#43
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#47
  def stderr_gvar?(sym); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#51
  def stderr_puts_range(send); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#21
RuboCop::Cop::Style::StderrPuts::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/stderr_puts.rb#22
RuboCop::Cop::Style::StderrPuts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StringChars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_chars.rb#29
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_chars.rb#27
RuboCop::Cop::Style::StringChars::BAD_ARGUMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_chars.rb#25
RuboCop::Cop::Style::StringChars::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_chars.rb#26
RuboCop::Cop::Style::StringChars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StringConcatenation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#69
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#73
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#62
  def string_concatenation?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#116
  def collect_parts(node, parts = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#141
  def corrected_ancestor?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#108
  def find_topmost_plus_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#162
  def handle_quotes(parts); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#135
  def heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#98
  def line_end_concatenation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#172
  def mode; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#127
  def plus_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#86
  def register_offense(topmost_plus_node, parts); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#145
  def replacement(parts); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#168
  def single_quoted?(str_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#131
  def uncorrectable?(part); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#58
RuboCop::Cop::Style::StringConcatenation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_concatenation.rb#59
RuboCop::Cop::Style::StringConcatenation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StringHashKeys < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_hash_keys.rb#42
  def on_pair(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_hash_keys.rb#30
  def receive_environments_method?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_hash_keys.rb#25
  def string_hash_key?(param0 = T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_hash_keys.rb#22
RuboCop::Cop::Style::StringHashKeys::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StringLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#37
  def on_dstr(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#127
  def accept_child_double_quotes?(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#71
  def all_string_literals?(nodes); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#61
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#109
  def check_multiline_quote_style(node, quote); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#105
  def consistent_multiline?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#75
  def detect_quote_styles(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#87
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#97
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#65
  def register_offense(node, message: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#123
  def unexpected_double_quotes?(quote); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#119
  def unexpected_single_quotes?(quote); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals.rb#35
RuboCop::Cop::Style::StringLiterals::MSG_INCONSISTENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StringLiteralsInInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals_in_interpolation.rb#28
  def autocorrect(corrector, node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals_in_interpolation.rb#34
  def message(_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_literals_in_interpolation.rb#41
  def offense?(node); end
end

class RuboCop::Cop::Style::StringMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_methods.rb#23
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/string_methods.rb#23
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/string_methods.rb#21
RuboCop::Cop::Style::StringMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Strip < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/strip.rb#24
  def lstrip_rstrip(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/strip.rb#29
  def on_send(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/strip.rb#20
RuboCop::Cop::Style::Strip::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/strip.rb#21
RuboCop::Cop::Style::Strip::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StructInheritance < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/struct_inheritance.rb#33
  def on_class(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/struct_inheritance.rb#45
  def struct_constructor?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/struct_inheritance.rb#52
  def correct_parent(parent, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/struct_inheritance.rb#62
  def range_for_empty_class_body(class_node, struct_new); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/struct_inheritance.rb#30
RuboCop::Cop::Style::StructInheritance::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SwapValues < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#30
  def on_asgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#30
  def on_casgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#30
  def on_cvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#30
  def on_gvasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#30
  def on_ivasgn(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#30
  def on_lvasgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#47
  def allowed_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#104
  def correction_range(tmp_assign, y_assign); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#81
  def lhs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#66
  def message(x_assign, y_assign); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#75
  def replacement(x_assign); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#95
  def rhs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#60
  def simple_assignment?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#51
  def swapping_values?(tmp_assign, x_assign, y_assign); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#25
RuboCop::Cop::Style::SwapValues::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/swap_values.rb#28
RuboCop::Cop::Style::SwapValues::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::SymbolArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#48
  def on_array(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#67
  def build_bracketed_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#88
  def symbol_without_quote?(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#60
  def symbols_contain_spaces?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#80
  def to_symbol_literal(string); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#45
    def largest_brackets; end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#45
    def largest_brackets=(_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#42
RuboCop::Cop::Style::SymbolArray::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_array.rb#41
RuboCop::Cop::Style::SymbolArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SymbolLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_literal.rb#20
  def on_sym(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_literal.rb#18
RuboCop::Cop::Style::SymbolLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SymbolProc < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#138
  def destructuring_block_argument?(argument_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#118
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#118
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#100
  def proc_node?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#106
  def symbol_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#103
  def symbol_proc_receiver?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#206
  def allow_comments?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#202
  def allow_if_method_has_argument?(send_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#153
  def allowed_method_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#166
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#178
  def autocorrect_with_args(corrector, node, args, method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#174
  def autocorrect_without_args(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#192
  def begin_pos_for_replacement(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#187
  def block_range_with_space(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#157
  def register_offense(node, method_name, block_method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#149
  def unsafe_array_usage?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#145
  def unsafe_hash_usage?(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#113
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#96
RuboCop::Cop::Style::SymbolProc::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/symbol_proc.rb#97
RuboCop::Cop::Style::SymbolProc::SUPER_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#509
    def correct(corrector, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#513
    def move_assignment_inside_condition(corrector, node); end

    private

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#527
    def correction(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#540
    def element_assignment?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#544
    def extract_branches(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#557
    def move_branch_inside_condition(corrector, branch, assignment); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#552
    def remove_parentheses(corrector, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/conditional_assignment.rb#531
    def ternary(node); end
  end
end

class RuboCop::Cop::Style::TernaryParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#193
  def method_name(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#69
  def on_if(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#100
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#183
  def below_ternary_precedence?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#131
  def complex_condition?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#89
  def condition_as_parenthesized_one_line_pattern_matching?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#198
  def correct_parenthesized(corrector, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#208
  def correct_unparenthesized(corrector, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#151
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#141
  def non_complex_expression?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#145
  def non_complex_send?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#113
  def offense?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#85
  def only_closing_parenthesis_is_last_line?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#169
  def parenthesized?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#161
  def require_parentheses?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#165
  def require_parentheses_when_complex?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#179
  def unparenthesized_method_call?(child); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#173
  def unsafe_autocorrect?(condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#212
  def whitespace_after?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#66
RuboCop::Cop::Style::TernaryParentheses::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#67
RuboCop::Cop::Style::TernaryParentheses::MSG_COMPLEX = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#64
RuboCop::Cop::Style::TernaryParentheses::NON_COMPLEX_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/ternary_parentheses.rb#63
RuboCop::Cop::Style::TernaryParentheses::VARIABLE_TYPES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::TopLevelMethodDefinition < ::RuboCop::Cop::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#79
  def define_method_block?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#60
  def on_block(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#52
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#52
  def on_defs(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#60
  def on_numblock(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#52
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#70
  def top_level_method_definition?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#48
RuboCop::Cop::Style::TopLevelMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/top_level_method_definition.rb#50
RuboCop::Cop::Style::TopLevelMethodDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::TrailingBodyOnClass < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_class.rb#25
  def on_class(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_class.rb#23
RuboCop::Cop::Style::TrailingBodyOnClass::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_method_definition.rb#38
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_method_definition.rb#38
  def on_defs(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_method_definition.rb#36
RuboCop::Cop::Style::TrailingBodyOnMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingBodyOnModule < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_module.rb#25
  def on_module(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_body_on_module.rb#23
RuboCop::Cop::Style::TrailingBodyOnModule::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingCommaInArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_arguments.rb#91
  def on_csend(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_arguments.rb#91
  def on_send(node); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_arguments.rb#100
    def autocorrect_incompatible_with; end
  end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#88
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#67
  def on_block(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#83
  def arg_count(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#95
  def argument_tokens(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#91
  def last_comma(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#87
  def trailing_comma?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#79
  def useless_trailing_comma?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_block_args.rb#65
RuboCop::Cop::Style::TrailingCommaInBlockArgs::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingCommaInHashLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#91
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingMethodEndStatement < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_method_end_statement.rb#41
  def on_def(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_method_end_statement.rb#55
  def body_and_end_on_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_method_end_statement.rb#51
  def trailing_end?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_method_end_statement.rb#39
RuboCop::Cop::Style::TrailingMethodEndStatement::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingUnderscoreVariable < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#41
  def on_masgn(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#92
  def allow_named_underscore_variables; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#125
  def children_offenses(variables); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#57
  def find_first_offense(variables); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#66
  def find_first_possible_offense(variables); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#108
  def main_node_offense(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#146
  def range_for_parentheses(offense, left); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#88
  def reverse_index(collection, item); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#80
  def splat_variable_before?(first_offense, variables); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#96
  def unneeded_ranges(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#133
  def unused_range(node_type, mlhs_node, right); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#129
  def unused_variables_only?(offense, variables); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#36
RuboCop::Cop::Style::TrailingUnderscoreVariable::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/trailing_underscore_variable.rb#37
RuboCop::Cop::Style::TrailingUnderscoreVariable::UNDERSCORE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrivialAccessors < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#190
  def looks_like_trivial_writer?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#104
  def on_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#104
  def on_defs(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#222
  def accessor(kind, method_name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#161
  def allow_dsl_writers?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#157
  def allow_predicates?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#195
  def allowed_method_name?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#169
  def allowed_method_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#204
  def allowed_reader?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#200
  def allowed_writer?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#142
  def autocorrect(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#234
  def autocorrect_class(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#226
  def autocorrect_instance(corrector, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#173
  def dsl_writer?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#153
  def exact_name_match?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#165
  def ignore_class_methods?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#115
  def in_module_or_instance_eval?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#181
  def looks_like_trivial_reader?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#208
  def names_match?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#129
  def on_method_def(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#248
  def top_level_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#214
  def trivial_accessor_kind(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#177
  def trivial_reader?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#185
  def trivial_writer?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/trivial_accessors.rb#102
RuboCop::Cop::Style::TrivialAccessors::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::UnlessElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_else.rb#28
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_else.rb#45
  def range_between_condition_and_else(node, condition); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_else.rb#49
  def range_between_else_and_end(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/unless_else.rb#26
RuboCop::Cop::Style::UnlessElse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::UnlessLogicalOperators < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#61
  def and_with_or?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#66
  def logical_operator?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#70
  def on_if(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#56
  def or_with_and?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#82
  def mixed_logical_operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#89
  def mixed_precedence_and?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#96
  def mixed_precedence_or?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#53
RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/unless_logical_operators.rb#52
RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_MIXED_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::UnpackFirst < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unpack_first.rb#38
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unpack_first.rb#31
  def unpack_and_first_element?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/unpack_first.rb#54
  def first_element_range(node, unpack_call); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/unpack_first.rb#26
RuboCop::Cop::Style::UnpackFirst::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/unpack_first.rb#28
RuboCop::Cop::Style::UnpackFirst::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::VariableInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/variable_interpolation.rb#25
  def on_node_with_interpolations(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/variable_interpolation.rb#35
  def message(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/variable_interpolation.rb#39
  def var_nodes(nodes); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/variable_interpolation.rb#22
RuboCop::Cop::Style::VariableInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WhenThen < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/when_then.rb#25
  def on_when(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/when_then.rb#23
RuboCop::Cop::Style::WhenThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WhileUntilDo < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/while_until_do.rb#36
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/while_until_do.rb#36
  def on_while(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/while_until_do.rb#34
RuboCop::Cop::Style::WhileUntilDo::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WhileUntilModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/while_until_modifier.rb#42
  def on_until(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/while_until_modifier.rb#42
  def on_while(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/while_until_modifier.rb#40
RuboCop::Cop::Style::WhileUntilModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WordArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#53
  def on_array(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#85
  def build_bracketed_array(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#65
  def complex_content?(strings, complex_regex: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#76
  def invalid_percent_array_contents?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#81
  def word_regex; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#50
    def largest_brackets; end

    # source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#50
    def largest_brackets=(_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#47
RuboCop::Cop::Style::WordArray::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/word_array.rb#46
RuboCop::Cop::Style::WordArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::YodaCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#88
  def file_constant_equal_program_name?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#92
  def on_send(node); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#140
  def actual_code_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#133
  def corrected_code(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#104
  def enforce_yoda?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#109
  def equality_only?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#164
  def interpolation?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#129
  def message(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#148
  def non_equality_operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#152
  def noncommutative_operator?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#160
  def program_name?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#144
  def reverse_comparison(operator); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#156
  def source_file_path_constant?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#118
  def valid_yoda?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#114
  def yoda_compatible_condition?(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#82
RuboCop::Cop::Style::YodaCondition::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#80
RuboCop::Cop::Style::YodaCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#83
RuboCop::Cop::Style::YodaCondition::NONCOMMUTATIVE_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#84
RuboCop::Cop::Style::YodaCondition::PROGRAM_NAMES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#85
RuboCop::Cop::Style::YodaCondition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# source://rubocop/1.36.0/lib/rubocop/cop/style/yoda_condition.rb#81
RuboCop::Cop::Style::YodaCondition::REVERSE_COMPARISON = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::ZeroLengthPredicate < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#118
  def non_polymorphic_collection?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#88
  def nonzero_length_predicate(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#42
  def on_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#109
  def other_receiver(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#80
  def zero_length_predicate(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#101
  def zero_length_receiver(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#64
  def check_nonzero_length_predicate(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#49
  def check_zero_length_predicate(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#93
  def replacement(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#38
RuboCop::Cop::Style::ZeroLengthPredicate::NONZERO_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#40
RuboCop::Cop::Style::ZeroLengthPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/style/zero_length_predicate.rb#37
RuboCop::Cop::Style::ZeroLengthPredicate::ZERO_MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#109
  def empty_brackets?(left_bracket_token, right_bracket_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#103
  def empty_offense(node, range, message, command); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#93
  def empty_offenses(node, left, right, message); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#68
  def extra_space?(token, side); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#127
  def no_space_between?(left_bracket_token, right_bracket_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#38
  def no_space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#119
  def offending_empty_no_space?(config, left_token, right_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#115
  def offending_empty_space?(config, left_token, right_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#33
  def on_new_investigation; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#78
  def reposition(src, pos, step); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#16
  def side_space_range(range:, side:); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#123
  def space_between?(left_bracket_token, right_bracket_token); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#84
  def space_offense(node, token, side, message, command); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#53
  def space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#9
RuboCop::Cop::SurroundingSpace::NO_SPACE_COMMAND = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#12
RuboCop::Cop::SurroundingSpace::SINGLE_SPACE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/surrounding_space.rb#10
RuboCop::Cop::SurroundingSpace::SPACE_COMMAND = T.let(T.unsafe(nil), String)

module RuboCop::Cop::SymbolHelp
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/symbol_help.rb#8
  def hash_key?(node); end
end

module RuboCop::Cop::TargetRubyVersion
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/target_ruby_version.rb#11
  def minimum_target_ruby_version(version); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/target_ruby_version.rb#7
  def required_minimum_ruby_version; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/target_ruby_version.rb#15
  def support_target_ruby_version?(version); end
end

class RuboCop::Cop::Team
  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#17
  def initialize(cops, config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#51
  def autocorrect?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#13
  def cops; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#55
  def debug?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#13
  def errors; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#113
  def external_dependency_checksum; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#94
  def forces; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#61
  def inspect_file(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#66
  def investigate(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#13
  def updated_source_file; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#13
  def updated_source_file?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#13
  def warnings; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#120
  def autocorrect(processed_source, report); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#179
  def autocorrect_report(report); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#139
  def be_ready; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#185
  def collate_corrections(report); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#197
  def each_corrector(report); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#247
  def handle_error(error, location, cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#239
  def handle_warning(error, location); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#153
  def investigate_partial(cops, processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#224
  def process_errors(file, errors); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#147
  def reset; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#159
  def roundup_relevant_cops(filename); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#173
  def support_target_rails_version?(cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#167
  def support_target_ruby_version?(cop); end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#212
  def suppress_clobbering; end

  # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#218
  def validate_config; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#99
    def forces_for(cops); end

    # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#36
    def mobilize(cop_classes, config, options = T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#42
    def mobilize_cops(cop_classes, config, options = T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/cop/team.rb#28
    def new(cop_or_classes, config, options = T.unsafe(nil)); end
  end
end

module RuboCop::Cop::TrailingBody
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_body.rb#12
  def body_on_first_line?(node, body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_body.rb#16
  def first_part_of(body); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_body.rb#7
  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#104
  def allowed_multiline_argument?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#167
  def any_heredoc?(items); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#159
  def autocorrect_range(item); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#133
  def avoid_comma(kind, comma_begin_pos, extra_info); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#82
  def brackets?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#19
  def check(node, items, kind, begin_pos, end_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#37
  def check_comma(node, kind, comma_pos); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#43
  def check_literal(node, kind); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#30
  def comma_offset(items, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#108
  def elements(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#54
  def extra_avoid_comma_info; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#171
  def heredoc?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#189
  def heredoc_send?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#76
  def inside_comment?(range, comma_offset); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#93
  def method_name_and_arguments_on_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#89
  def multiline?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#123
  def no_elements_on_same_line?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#129
  def on_same_line?(range1, range2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#147
  def put_comma(items, kind); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#65
  def should_have_comma?(style, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#15
  def style_parameter_name; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/trailing_comma.rb#11
RuboCop::Cop::TrailingComma::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::UncommunicativeName
  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#12
  def check(node, args); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#95
  def allow_nums; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#87
  def allowed_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#78
  def arg_range(arg, length); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#45
  def case_offense(node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#64
  def ends_with_num?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#91
  def forbidden_names; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#83
  def forbidden_offense(node, range, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#36
  def issue_offenses(node, range, name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#68
  def length_offense(node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#74
  def long_enough?(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#99
  def min_length; end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#53
  def name_type(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#60
  def num_offense(node, range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#49
  def uppercase?(name); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#7
RuboCop::Cop::UncommunicativeName::CASE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#10
RuboCop::Cop::UncommunicativeName::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#9
RuboCop::Cop::UncommunicativeName::LENGTH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/uncommunicative_name.rb#8
RuboCop::Cop::UncommunicativeName::NUM_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/unused_arg_corrector.rb#12
    def correct(corrector, processed_source, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/unused_arg_corrector.rb#31
    def correct_for_blockarg_type(corrector, node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/correctors/unused_arg_corrector.rb#10
    def processed_source; end
  end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#34
  def add_parentheses(node, corrector); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#55
  def args_begin(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#67
  def args_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#80
  def begins_its_line?(range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#16
  def comment_line?(line_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#21
  def comment_lines?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#161
  def compatible_external_encoding_for?(src); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#102
  def double_quotes_required?(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#116
  def escape_string(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#86
  def first_part_of_call_chain(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#151
  def indent(node, offset: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#133
  def interpret_string_escapes(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#137
  def line(node_or_range); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#25
  def line_range(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#112
  def needs_escaping?(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#71
  def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#29
  def parentheses?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#145
  def same_line?(node1, node2); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#120
  def to_string_literal(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#155
  def to_supported_styles(enforced_style); end

  # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#129
  def trim_string_interpolation_escape_character(str); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#34
    def add_parentheses(node, corrector); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#55
    def args_begin(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#67
    def args_end(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#80
    def begins_its_line?(range); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#16
    def comment_line?(line_source); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#21
    def comment_lines?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#102
    def double_quotes_required?(string); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#116
    def escape_string(string); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#86
    def first_part_of_call_chain(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#151
    def indent(node, offset: T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#133
    def interpret_string_escapes(string); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#137
    def line(node_or_range); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#25
    def line_range(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#112
    def needs_escaping?(string); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#71
    def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#29
    def parentheses?(node); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#145
    def same_line?(node1, node2); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#120
    def to_string_literal(string); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#155
    def to_supported_styles(enforced_style); end

    # source://rubocop/1.36.0/lib/rubocop/cop/util.rb#129
    def trim_string_interpolation_escape_character(str); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/util.rb#11
RuboCop::Cop::Util::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)

module RuboCop::Cop::Utils; end

class RuboCop::Cop::Utils::FormatString
  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#89
  def initialize(string); end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#93
  def format_sequences; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#105
  def max_digit_dollar_num; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#101
  def named_interpolation?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#97
  def valid?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#117
  def mixed_formats?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#111
  def parse; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#8
RuboCop::Cop::Utils::FormatString::DIGIT_DOLLAR = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#9
RuboCop::Cop::Utils::FormatString::FLAG = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Utils::FormatString::FormatSequence
  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#46
  def initialize(match); end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#61
  def annotated?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#70
  def arity; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def begin_pos; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def end_pos; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def flags; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#74
  def max_digit_dollar_num; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#57
  def percent?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def precision; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#78
  def style; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#65
  def template?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def type; end

  # source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#44
  def width; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#15
RuboCop::Cop::Utils::FormatString::NAME = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#11
RuboCop::Cop::Utils::FormatString::NUMBER = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#10
RuboCop::Cop::Utils::FormatString::NUMBER_ARG = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#13
RuboCop::Cop::Utils::FormatString::PRECISION = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#18
RuboCop::Cop::Utils::FormatString::SEQUENCE = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#16
RuboCop::Cop::Utils::FormatString::TEMPLATE_NAME = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#14
RuboCop::Cop::Utils::FormatString::TYPE = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/cop/utils/format_string.rb#12
RuboCop::Cop::Utils::FormatString::WIDTH = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::VariableForce < ::RuboCop::Cop::Force
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#75
  def investigate(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#84
  def process_node(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#70
  def variable_table; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#379
  def after_declaring_variable(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#379
  def after_entering_scope(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#379
  def after_leaving_scope(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#379
  def before_declaring_variable(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#379
  def before_entering_scope(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#379
  def before_leaving_scope(arg); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#349
  def descendant_reference(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#339
  def each_descendant_reference(loop_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#324
  def find_variables_in_loop(loop_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#93
  def inspect_variables_in_scope(scope_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#305
  def mark_assignments_as_referenced_in_loop(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#112
  def node_handler_method_name(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#99
  def process_children(origin_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#241
  def process_loop(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#170
  def process_regexp_named_captures(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#256
  def process_rescue(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#275
  def process_scope(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#294
  def process_send(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#152
  def process_variable_assignment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#140
  def process_variable_declaration(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#229
  def process_variable_multiple_assignment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#194
  def process_variable_operator_assignment(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#236
  def process_variable_referencing(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#267
  def process_zero_arity_super(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#188
  def regexp_captured_names(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#362
  def scanned_node?(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#366
  def scanned_nodes; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#107
  def skip_children!; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#288
  def twisted_nodes(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#32
RuboCop::Cop::VariableForce::ARGUMENT_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#16
  def initialize(node, variable); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#67
  def meta_assignment_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#56
  def multiple_assignment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#29
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#12
  def node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#62
  def operator; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#50
  def operator_assignment?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#37
  def reference!(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#12
  def referenced; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#12
  def referenced?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#12
  def references; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#46
  def regexp_named_capture?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#33
  def scope; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#42
  def used?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#12
  def variable; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#85
  def multiple_assignment_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#77
  def operator_assignment_node; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force/assignment.rb#10
RuboCop::Cop::VariableForce::Assignment::MULTIPLE_LEFT_HAND_SIDE_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::AssignmentReference < ::Struct
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#65
  def assignment?; end

  def node; end
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RuboCop::Cop::VariableForce::Branch
  class << self
    # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#8
    def of(target_node, scope: T.unsafe(nil)); end
  end
end

class RuboCop::Cop::VariableForce::Branch::And < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def left_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def right_body?; end
end

class RuboCop::Cop::VariableForce::Branch::Base < ::Struct
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#121
  def ==(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#92
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#88
  def branched?; end

  def child_node; end
  def child_node=(_); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#70
  def control_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#80
  def each_ancestor(include_self: T.unsafe(nil), &block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#121
  def eql?(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#104
  def exclusive_with?(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#129
  def hash; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#96
  def may_jump_to_other_branch?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#100
  def may_run_incompletely?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#74
  def parent; end

  def scope; end
  def scope=(_); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#135
  def scan_ancestors; end

  class << self
    def [](*_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#43
    def classes; end

    # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#56
    def define_predicate(name, child_index: T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#47
    def inherited(subclass); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#52
    def type; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#325
RuboCop::Cop::VariableForce::Branch::CLASSES_BY_TYPE = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::VariableForce::Branch::Case < ::RuboCop::Cop::VariableForce::Branch::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#224
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def else_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def target?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def when_clause?; end
end

class RuboCop::Cop::VariableForce::Branch::CaseMatch < ::RuboCop::Cop::VariableForce::Branch::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#239
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def else_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def in_pattern?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def target?; end
end

class RuboCop::Cop::VariableForce::Branch::Ensure < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#320
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def ensure_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def main_body?; end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#282
  def may_jump_to_other_branch?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#286
  def may_run_incompletely?; end
end

class RuboCop::Cop::VariableForce::Branch::For < ::RuboCop::Cop::VariableForce::Branch::Base
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#252
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def collection?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def element?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::If < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def falsey_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def truthy_body?; end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#259
  def always_run?; end
end

class RuboCop::Cop::VariableForce::Branch::Or < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def left_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def right_body?; end
end

class RuboCop::Cop::VariableForce::Branch::Rescue < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#304
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def else_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def main_body?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def rescue_clause?; end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#150
  def always_run?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#146
  def conditional_clause?; end
end

class RuboCop::Cop::VariableForce::Branch::Until < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::While < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

module RuboCop::Cop::VariableForce::Branchable
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branchable.rb#9
  def branch; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/branchable.rb#15
  def run_exclusively_with?(other); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#39
RuboCop::Cop::VariableForce::LOGICAL_OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#47
RuboCop::Cop::VariableForce::LOOP_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#42
RuboCop::Cop::VariableForce::MULTIPLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#40
RuboCop::Cop::VariableForce::OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#46
RuboCop::Cop::VariableForce::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#29
RuboCop::Cop::VariableForce::REGEXP_NAMED_CAPTURE_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#49
RuboCop::Cop::VariableForce::RESCUE_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/reference.rb#16
  def initialize(node, scope); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/reference.rb#41
  def explicit?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/reference.rb#14
  def node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/reference.rb#14
  def scope; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force/reference.rb#10
RuboCop::Cop::VariableForce::Reference::VARIABLE_REFERENCE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#54
RuboCop::Cop::VariableForce::SCOPE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#56
RuboCop::Cop::VariableForce::SEND_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::Scope
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#22
  def initialize(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#35
  def ==(other); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#43
  def body_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#61
  def each_node(&block); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#57
  def include?(target_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#18
  def naked_top_level; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#18
  def naked_top_level?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#39
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#18
  def node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#18
  def variables; end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#100
  def ancestor_node?(target_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#90
  def belong_to_inner_scope?(target_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#79
  def belong_to_outer_scope?(target_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#70
  def scan_node(node, &block); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force/scope.rb#10
RuboCop::Cop::VariableForce::Scope::OUTER_SCOPE_CHILD_INDICES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#53
RuboCop::Cop::VariableForce::TWISTED_SCOPE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#28
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#30
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#44
RuboCop::Cop::VariableForce::VARIABLE_REFERENCE_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::Variable
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#15
  def initialize(name, declaration_node, scope); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#92
  def argument?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#31
  def assign(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def assignments; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#100
  def block_argument?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#72
  def capture_with_block!; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def captured_by_block; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def captured_by_block?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def declaration_node; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#108
  def explicit_block_local_variable?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#66
  def in_modifier_if?(assignment); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#104
  def keyword_argument?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#96
  def method_argument?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#40
  def reference!(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#35
  def referenced?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def references; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#11
  def scope; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#88
  def should_be_unused?; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#84
  def used?; end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable.rb#9
RuboCop::Cop::VariableForce::Variable::VARIABLE_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::VariableForce::VariableReference < ::Struct
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#59
  def assignment?; end

  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::VariableForce::VariableTable
  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#12
  def initialize(hook_receiver = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#111
  def accessible_variables; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#56
  def assign_to_variable(name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#40
  def current_scope; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#44
  def current_scope_level; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#48
  def declare_variable(name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#94
  def find_variable(name); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#16
  def invoke_hook(hook_name, *args); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#32
  def pop_scope; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#24
  def push_scope(scope_node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#68
  def reference_variable(name, node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#20
  def scope_stack; end

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#107
  def variable_exist?(name); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/variable_force/variable_table.rb#120
  def mark_variable_as_captured_by_block_if_so(variable); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/variable_force.rb#51
RuboCop::Cop::VariableForce::ZERO_ARITY_SUPER_TYPE = T.let(T.unsafe(nil), Symbol)

module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/visibility_help.rb#32
  def visibility_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/visibility_help.rb#23
  def find_visibility_end(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/visibility_help.rb#18
  def find_visibility_start(node); end

  # source://rubocop/1.36.0/lib/rubocop/cop/mixin/visibility_help.rb#13
  def node_visibility(node); end
end

# source://rubocop/1.36.0/lib/rubocop/cop/mixin/visibility_help.rb#9
RuboCop::Cop::VisibilityHelp::VISIBILITY_SCOPES = T.let(T.unsafe(nil), Array)

class RuboCop::DirectiveComment
  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#30
  def initialize(comment, cop_registry = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#80
  def all_cops?; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#28
  def comment; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#85
  def cop_names; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#28
  def cop_registry; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#28
  def cops; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#91
  def department_names; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#105
  def directive_count; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#60
  def disabled?; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#75
  def disabled_all?; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#65
  def enabled?; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#70
  def enabled_all?; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#96
  def in_directive_department?(cop); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#110
  def line_number; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#42
  def match?(cop_names); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#55
  def match_captures; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#28
  def mode; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#101
  def overridden_by_department?(cop); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#46
  def range; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#37
  def single_line?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#130
  def all_cop_names; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#134
  def cop_names_for_department(department); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#126
  def department?(name); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#140
  def exclude_redundant_directive_cop(cops); end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#120
  def parsed_cop_names; end

  # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#116
  def splitted_cops_string; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#24
    def before_comment(line); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#17
RuboCop::DirectiveComment::COPS_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#15
RuboCop::DirectiveComment::COP_NAMES_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#13
RuboCop::DirectiveComment::COP_NAME_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#19
RuboCop::DirectiveComment::DIRECTIVE_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#11
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/directive_comment.rb#9
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP_DEPARTMENT = T.let(T.unsafe(nil), String)

class RuboCop::Error < ::StandardError; end

class RuboCop::ErrorWithAnalyzedFileLocation < ::RuboCop::Error
  # source://rubocop/1.36.0/lib/rubocop/error.rb#14
  def initialize(cause:, node:, cop:); end

  # source://rubocop/1.36.0/lib/rubocop/error.rb#21
  def cause; end

  # source://rubocop/1.36.0/lib/rubocop/error.rb#27
  def column; end

  # source://rubocop/1.36.0/lib/rubocop/error.rb#21
  def cop; end

  # source://rubocop/1.36.0/lib/rubocop/error.rb#23
  def line; end

  # source://rubocop/1.36.0/lib/rubocop/error.rb#31
  def message; end
end

module RuboCop::ExcludeLimit
  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#10
  def exclude_limit(parameter_name, method_name: T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/cop/exclude_limit.rb#22
  def transform(parameter_name); end
end

module RuboCop::Ext; end

module RuboCop::Ext::ProcessedSource
  # source://rubocop/1.36.0/lib/rubocop/ext/processed_source.rb#7
  def comment_config; end

  # source://rubocop/1.36.0/lib/rubocop/ext/processed_source.rb#11
  def disabled_line_ranges; end
end

module RuboCop::Ext::Range
  # source://rubocop/1.36.0/lib/rubocop/ext/range.rb#8
  def single_line?; end
end

module RuboCop::Ext::RegexpNode
  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_node.rb#19
  def assign_properties(*_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_node.rb#53
  def each_capture(named: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_node.rb#16
  def parsed_tree; end

  private

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_node.rb#68
  def with_interpolations_blanked; end
end

module RuboCop::Ext::RegexpParser; end
module RuboCop::Ext::RegexpParser::Expression; end

module RuboCop::Ext::RegexpParser::Expression::Base
  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#27
  def expression; end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#61
  def loc; end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#23
  def origin; end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#23
  def origin=(_arg0); end

  private

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#67
  def build_location; end
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#78
  def build_location; end
end

class RuboCop::Ext::RegexpParser::Map < ::Parser::Source::Map
  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#11
  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#9
  def begin; end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#9
  def body; end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#9
  def end; end

  # source://rubocop/1.36.0/lib/rubocop/ext/regexp_parser.rb#9
  def quantifier; end
end

class RuboCop::FeatureLoader
  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#27
  def initialize(config_directory_path:, feature:); end

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#32
  def load; end

  private

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#55
  def namespaced_feature; end

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#60
  def namespaced_target; end

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#70
  def relative(feature); end

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#75
  def relative?; end

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#81
  def seems_cannot_load_such_file_error?(error); end

  # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#86
  def target; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/feature_loader.rb#20
    def load(config_directory_path:, feature:); end
  end
end

module RuboCop::FileFinder
  # source://rubocop/1.36.0/lib/rubocop/file_finder.rb#17
  def find_file_upwards(filename, start_dir, stop_dir = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/file_finder.rb#24
  def find_last_file_upwards(filename, start_dir, stop_dir = T.unsafe(nil)); end

  private

  # source://rubocop/1.36.0/lib/rubocop/file_finder.rb#32
  def traverse_files_upwards(filename, start_dir, stop_dir); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/file_finder.rb#9
    def root_level=(level); end

    # source://rubocop/1.36.0/lib/rubocop/file_finder.rb#13
    def root_level?(path, stop_dir); end
  end
end

module RuboCop::Formatter; end

class RuboCop::Formatter::AutoGenConfigFormatter < ::RuboCop::Formatter::ProgressFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/auto_gen_config_formatter.rb#7
  def finished(inspected_files); end
end

class RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#63
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#104
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#89
  def file_started(file, options); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#116
  def finished(inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#57
  def options; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#50
  def output; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/base_formatter.rb#76
  def started(target_files); end
end

class RuboCop::Formatter::ClangStyleFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/clang_style_formatter.rb#11
  def report_file(file, offenses); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/clang_style_formatter.rb#51
  def report_highlighted_area(highlighted_area); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/clang_style_formatter.rb#41
  def report_line(location); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/clang_style_formatter.rb#17
  def report_offense(file, offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/clang_style_formatter.rb#37
  def valid_line?(offense); end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/clang_style_formatter.rb#9
RuboCop::Formatter::ClangStyleFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

module RuboCop::Formatter::Colorizable
  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def black(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def blue(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#21
  def colorize(string, *args); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def cyan(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def green(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def magenta(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#9
  def rainbow; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def red(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def white(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/colorizable.rb#35
  def yellow(string); end
end

class RuboCop::Formatter::DisabledConfigFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#27
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#39
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#33
  def file_started(_file, _file_info); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#47
  def finished(_inspected_files); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#68
  def command; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#148
  def cop_config_params(default_cfg, cfg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#168
  def default_config(cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#207
  def excludes(offending_files, cop_name, parent); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#228
  def merge_mode_for_exclude?(cfg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#93
  def output_cop(cop_name, offense_count); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#120
  def output_cop_comments(output_buffer, cfg, cop_name, offense_count); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#172
  def output_cop_config(output_buffer, cfg, cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#155
  def output_cop_param_comments(output_buffer, params, default_cfg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#197
  def output_exclude_list(output_buffer, offending_files, cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#232
  def output_exclude_path(output_buffer, exclude_path, parent); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#186
  def output_offending_files(output_buffer, cfg, cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#87
  def output_offenses; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#245
  def safe_autocorrect?(config); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#107
  def set_max(cfg, cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#64
  def show_offense_counts?; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#60
  def show_timestamp?; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#140
  def supports_safe_autocorrect?(cop_class, default_cfg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#144
  def supports_unsafe_autocorrect?(cop_class, default_cfg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#83
  def timestamp; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#24
    def config_to_allow_offenses; end

    # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#24
    def config_to_allow_offenses=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#24
    def detected_styles; end

    # source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#24
    def detected_styles=(_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/disabled_config_formatter.rb#10
RuboCop::Formatter::DisabledConfigFormatter::HEADING = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::EmacsStyleFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/emacs_style_formatter.rb#9
  def file_finished(file, offenses); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/emacs_style_formatter.rb#24
  def message(offense); end
end

class RuboCop::Formatter::FileListFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/file_list_formatter.rb#13
  def file_finished(file, offenses); end
end

class RuboCop::Formatter::FormatterSet < ::Array
  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#39
  def initialize(options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#55
  def add_formatter(formatter_type, output_path = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#67
  def close_output_files; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#50
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#44
  def file_started(file, options); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#34
  def finished(*args); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#34
  def started(*args); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#86
  def builtin_formatter_class(specified_key); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#99
  def custom_formatter_class(specified_class_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#75
  def formatter_class(formatter_type); end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#11
RuboCop::Formatter::FormatterSet::BUILTIN_FORMATTERS_FOR_KEYS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/formatter/formatter_set.rb#31
RuboCop::Formatter::FormatterSet::FORMATTER_APIS = T.let(T.unsafe(nil), Array)

class RuboCop::Formatter::FuubarStyleFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#14
  def initialize(*output); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#51
  def count_stats(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#40
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#71
  def progressbar_color; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#20
  def started(target_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#61
  def with_color; end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/fuubar_style_formatter.rb#12
RuboCop::Formatter::FuubarStyleFormatter::RESET_SEQUENCE = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::GitHubActionsFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#14
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#18
  def finished(_inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#10
  def started(_target_files); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#29
  def github_escape(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#41
  def github_severity(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#33
  def minimum_severity_to_fail; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#45
  def report_offense(file, offense); end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/git_hub_actions_formatter.rb#8
RuboCop::Formatter::GitHubActionsFormatter::ESCAPE_MAP = T.let(T.unsafe(nil), Hash)

class RuboCop::Formatter::HTMLFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#30
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#40
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#28
  def files; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#45
  def finished(inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#51
  def render_html; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#36
  def started(target_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#28
  def summary; end
end

class RuboCop::Formatter::HTMLFormatter::Color < ::Struct
  def alpha; end
  def alpha=(_); end
  def blue; end
  def blue=(_); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#20
  def fade_out(amount); end

  def green; end
  def green=(_); end
  def red; end
  def red=(_); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#16
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#12
RuboCop::Formatter::HTMLFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#78
  def initialize(files, summary); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#125
  def base64_encoded_logo_image; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#85
  def binding; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#90
  def decorated_message(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#121
  def escape(string); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#76
  def files; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#101
  def highlight_source_tag(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#94
  def highlighted_source_line(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#117
  def possible_ellipses(location); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#112
  def source_after_highlight(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#107
  def source_before_highlight(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#76
  def summary; end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#74
RuboCop::Formatter::HTMLFormatter::ERBContext::LOGO_IMAGE_PATH = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#66
RuboCop::Formatter::HTMLFormatter::ERBContext::SEVERITY_COLORS = T.let(T.unsafe(nil), Hash)

class RuboCop::Formatter::HTMLFormatter::FileOffenses < ::Struct
  def offenses; end
  def offenses=(_); end
  def path; end
  def path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Formatter::HTMLFormatter::Summary < ::Struct
  def inspected_files; end
  def inspected_files=(_); end
  def offense_count; end
  def offense_count=(_); end
  def target_files; end
  def target_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/html_formatter.rb#13
RuboCop::Formatter::HTMLFormatter::TEMPLATE_PATH = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::JSONFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#14
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#23
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#28
  def finished(inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#43
  def hash_for_file(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#65
  def hash_for_location(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#50
  def hash_for_offense(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#33
  def metadata_hash; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#12
  def output_hash; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/json_formatter.rb#19
  def started(target_files); end
end

class RuboCop::Formatter::JUnitFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#18
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#55
  def add_testcase_element_to_testsuite_element(file, target_offenses, cop); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#64
  def classname_attribute_value(file); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#29
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#68
  def finished(_inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#51
  def offenses_for_cop(all_offenses, cop); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#47
  def relevant_for_output?(options, target_offenses); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#80
  def add_failure_to(testcase, offenses, cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/junit_formatter.rb#75
  def reset_count; end
end

class RuboCop::Formatter::MarkdownFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::Formatter::TextUtil
  include ::RuboCop::PathUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#11
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#21
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#9
  def files; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#26
  def finished(inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#17
  def started(target_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#9
  def summary; end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#73
  def possible_ellipses(location); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#33
  def render_markdown; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#67
  def write_code(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#61
  def write_context(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#42
  def write_file_messages; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/markdown_formatter.rb#54
  def write_heading(file); end
end

class RuboCop::Formatter::OffenseCountFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#41
  def file_finished(_file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#49
  def finished(_inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#17
  def offense_counts; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#71
  def ordered_offense_counts(offense_counts); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#54
  def report_summary(offense_counts); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#19
  def started(target_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/offense_count_formatter.rb#75
  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::PacmanFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#19
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#50
  def cols; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#37
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#33
  def file_started(_file, _options); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#43
  def next_step(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#64
  def pacdots(number); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#12
  def progress_line; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#12
  def progress_line=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#26
  def started(target_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#68
  def step(character); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#57
  def update_progress_line; end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#14
RuboCop::Formatter::PacmanFormatter::FALLBACK_TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#15
RuboCop::Formatter::PacmanFormatter::GHOST = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#17
RuboCop::Formatter::PacmanFormatter::PACDOT = T.let(T.unsafe(nil), Rainbow::Presenter)

# source://rubocop/1.36.0/lib/rubocop/formatter/pacman_formatter.rb#16
RuboCop::Formatter::PacmanFormatter::PACMAN = T.let(T.unsafe(nil), Rainbow::Presenter)

class RuboCop::Formatter::ProgressFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/progress_formatter.rb#13
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/progress_formatter.rb#24
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/progress_formatter.rb#33
  def finished(inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/progress_formatter.rb#50
  def report_file_as_mark(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/progress_formatter.rb#18
  def started(target_files); end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/progress_formatter.rb#11
RuboCop::Formatter::ProgressFormatter::DOT = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::QuietFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/quiet_formatter.rb#8
  def report_summary(file_count, offense_count, correction_count, correctable_count); end
end

class RuboCop::Formatter::SimpleTextFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#29
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#36
  def finished(inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#43
  def report_file(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#57
  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#23
  def started(_target_files); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#85
  def annotate_message(msg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#80
  def colored_severity_code(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#73
  def count_stats(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#89
  def message(offense); end
end

# source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#14
RuboCop::Formatter::SimpleTextFormatter::COLOR_FOR_SEVERITY = T.let(T.unsafe(nil), Hash)

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#110
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_autocorrect: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#123
  def summary; end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#160
  def correctable; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#153
  def corrections; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#142
  def files; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#146
  def offenses; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/simple_text_formatter.rb#140
  def rainbow; end
end

class RuboCop::Formatter::TapFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#14
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#8
  def started(target_files); end

  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#66
  def annotate_message(msg); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#70
  def message(offense); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#39
  def report_highlighted_area(highlighted_area); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#29
  def report_line(location); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/tap_formatter.rb#46
  def report_offense(file, offense); end
end

module RuboCop::Formatter::TextUtil
  private

  # source://rubocop/1.36.0/lib/rubocop/formatter/text_util.rb#9
  def pluralize(number, thing, options = T.unsafe(nil)); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/formatter/text_util.rb#9
    def pluralize(number, thing, options = T.unsafe(nil)); end
  end
end

class RuboCop::Formatter::WorstOffendersFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#24
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#31
  def finished(_inspected_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#17
  def offense_counts; end

  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#52
  def ordered_offense_counts(offense_counts); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#36
  def report_summary(offense_counts); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#19
  def started(target_files); end

  # source://rubocop/1.36.0/lib/rubocop/formatter/worst_offenders_formatter.rb#56
  def total_offense_count(offense_counts); end
end

class RuboCop::IncorrectCopNameError < ::StandardError; end

class RuboCop::Lockfile
  # source://rubocop/1.36.0/lib/rubocop/lockfile.rb#9
  def dependencies; end

  # source://rubocop/1.36.0/lib/rubocop/lockfile.rb#16
  def gems; end

  # source://rubocop/1.36.0/lib/rubocop/lockfile.rb#24
  def includes_gem?(name); end

  private

  # source://rubocop/1.36.0/lib/rubocop/lockfile.rb#30
  def parser; end
end

class RuboCop::MagicComment
  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#32
  def initialize(comment); end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#36
  def any?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#104
  def encoding_specified?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#86
  def frozen_string_literal; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#55
  def frozen_string_literal?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#70
  def frozen_string_literal_specified?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#100
  def shareable_constant_value; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#77
  def shareable_constant_value_specified?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#115
  def typed; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#111
  def typed_specified?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#43
  def valid?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#59
  def valid_literal_value?; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#63
  def valid_shareable_constant_value?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#131
  def extract(pattern); end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#121
  def specified?(value); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#23
    def parse(comment); end
  end
end

class RuboCop::MagicComment::EditorComment < ::RuboCop::MagicComment
  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#139
  def encoding; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#144
  def without(type); end

  private

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#159
  def match(keyword); end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#174
  def tokens; end
end

class RuboCop::MagicComment::EmacsComment < ::RuboCop::MagicComment::EditorComment
  private

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#198
  def extract_frozen_string_literal; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#202
  def extract_shareable_constant_value; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#207
  def extract_typed; end
end

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#192
RuboCop::MagicComment::EmacsComment::FORMAT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#194
RuboCop::MagicComment::EmacsComment::OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#191
RuboCop::MagicComment::EmacsComment::REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#193
RuboCop::MagicComment::EmacsComment::SEPARATOR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#11
RuboCop::MagicComment::KEYWORDS = T.let(T.unsafe(nil), Hash)

class RuboCop::MagicComment::SimpleComment < ::RuboCop::MagicComment
  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#263
  def encoding; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#268
  def without(type); end

  private

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#285
  def extract_frozen_string_literal; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#289
  def extract_shareable_constant_value; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#293
  def extract_typed; end
end

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#10
RuboCop::MagicComment::TOKEN = T.let(T.unsafe(nil), Regexp)

class RuboCop::MagicComment::VimComment < ::RuboCop::MagicComment::EditorComment
  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#234
  def encoding; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#245
  def extract_typed; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#239
  def frozen_string_literal; end

  # source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#242
  def shareable_constant_value; end
end

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#220
RuboCop::MagicComment::VimComment::FORMAT = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#223
RuboCop::MagicComment::VimComment::KEYWORDS = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#222
RuboCop::MagicComment::VimComment::OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#219
RuboCop::MagicComment::VimComment::REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/magic_comment.rb#221
RuboCop::MagicComment::VimComment::SEPARATOR = T.let(T.unsafe(nil), String)

module RuboCop::Minitest; end

# source://rubocop-minitest/0.22.2/lib/rubocop/minitest.rb#8
RuboCop::Minitest::CONFIG = T.let(T.unsafe(nil), Hash)

module RuboCop::Minitest::Inject
  class << self
    # source://rubocop-minitest/0.22.2/lib/rubocop/minitest/inject.rb#8
    def defaults!; end
  end
end

module RuboCop::Minitest::Version
  class << self
    # source://rubocop-minitest/0.22.2/lib/rubocop/minitest/version.rb#9
    def document_version; end
  end
end

# source://rubocop-minitest/0.22.2/lib/rubocop/minitest/version.rb#7
RuboCop::Minitest::Version::STRING = T.let(T.unsafe(nil), String)

module RuboCop::NameSimilarity
  private

  # source://rubocop/1.36.0/lib/rubocop/name_similarity.rb#9
  def find_similar_name(target_name, names); end

  # source://rubocop/1.36.0/lib/rubocop/name_similarity.rb#15
  def find_similar_names(target_name, names); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/name_similarity.rb#9
    def find_similar_name(target_name, names); end

    # source://rubocop/1.36.0/lib/rubocop/name_similarity.rb#15
    def find_similar_names(target_name, names); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/ast_aliases.rb#5
RuboCop::NodePattern = RuboCop::AST::NodePattern

class RuboCop::OptionArgumentError < ::StandardError; end

class RuboCop::Options
  # source://rubocop/1.36.0/lib/rubocop/options.rb#21
  def initialize; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#26
  def parse(command_line_args); end

  private

  # source://rubocop/1.36.0/lib/rubocop/options.rb#217
  def add_additional_modes(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#140
  def add_autocorrection_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#200
  def add_cache_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#75
  def add_check_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#163
  def add_config_generation_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#179
  def add_cop_selection_csv_option(option, opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#229
  def add_general_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#105
  def add_output_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#207
  def add_server_options(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#191
  def add_severity_option(opts); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#56
  def args_from_env; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#48
  def args_from_file; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#60
  def define_options; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#241
  def handle_deprecated_option(old_option, new_option); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#275
  def long_opt_symbol(args); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#264
  def option(opts, *args); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#246
  def rainbow; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#280
  def require_feature(file); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#256
  def section(opts, heading, &_block); end
end

# source://rubocop/1.36.0/lib/rubocop/options.rb#19
RuboCop::Options::DEFAULT_MAXIMUM_EXCLUSION_ITEMS = T.let(T.unsafe(nil), Integer)

# source://rubocop/1.36.0/lib/rubocop/options.rb#18
RuboCop::Options::EXITING_OPTIONS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/options.rb#14
RuboCop::Options::E_STDIN_NO_PATH = T.let(T.unsafe(nil), String)

module RuboCop::OptionsHelp; end

# source://rubocop/1.36.0/lib/rubocop/options.rb#469
RuboCop::OptionsHelp::FORMATTER_OPTION_LIST = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/options.rb#468
RuboCop::OptionsHelp::MAX_EXCL = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/options.rb#471
RuboCop::OptionsHelp::TEXT = T.let(T.unsafe(nil), Hash)

class RuboCop::OptionsValidator
  # source://rubocop/1.36.0/lib/rubocop/options.rb#328
  def initialize(options); end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#442
  def boolean_or_empty_cache?; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#410
  def disable_parallel_when_invalid_option_combo; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#434
  def display_only_fail_level_offenses_with_autocorrect?; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#438
  def except_syntax?; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#446
  def incompatible_options; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#423
  def invalid_arguments_for_parallel; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#429
  def only_includes_redundant_disable?; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#363
  def validate_auto_gen_config; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#402
  def validate_autocorrect; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#458
  def validate_cache_enabled_for_cache_root; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#337
  def validate_compatibility; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#332
  def validate_cop_options; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#384
  def validate_display_only_correctable_and_autocorrect; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#376
  def validate_display_only_failed; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#393
  def validate_display_only_failed_and_display_only_correctable; end

  # source://rubocop/1.36.0/lib/rubocop/options.rb#450
  def validate_exclude_limit_option; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/options.rb#297
    def validate_cop_list(names); end

    private

    # source://rubocop/1.36.0/lib/rubocop/options.rb#314
    def format_message_from(name, cop_names); end
  end
end

module RuboCop::Packaging; end

# source://rubocop-packaging/0.5.2/lib/rubocop/packaging.rb#10
RuboCop::Packaging::CONFIG = T.let(T.unsafe(nil), Hash)

module RuboCop::Packaging::Inject
  class << self
    # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/inject.rb#8
    def defaults!; end
  end
end

module RuboCop::Packaging::LibHelperModule
  # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/lib_helper_module.rb#25
  def inspected_file_falls_in_lib?; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/lib_helper_module.rb#30
  def inspected_file_is_gemspec?; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/lib_helper_module.rb#36
  def inspected_file_is_not_in_lib_or_gemspec?; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/lib_helper_module.rb#9
  def root_dir; end

  # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/lib_helper_module.rb#14
  def target_falls_in_lib?(str); end

  # source://rubocop-packaging/0.5.2/lib/rubocop/packaging/lib_helper_module.rb#20
  def target_falls_in_lib_using_file?(str); end
end

# source://rubocop-packaging/0.5.2/lib/rubocop/packaging/version.rb#5
RuboCop::Packaging::VERSION = T.let(T.unsafe(nil), String)

module RuboCop::PathUtil
  private

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#53
  def absolute?(path); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#79
  def hidden_dir?(path); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#66
  def hidden_file?(path); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#57
  def hidden_file_in_not_hidden_dir?(pattern, path); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#36
  def match_path?(pattern, path); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#71
  def maybe_hidden_file?(path); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#8
  def relative_path(path, base_dir = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/path_util.rb#25
  def smart_path(path); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#53
    def absolute?(path); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#79
    def hidden_dir?(path); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#66
    def hidden_file?(path); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#57
    def hidden_file_in_not_hidden_dir?(pattern, path); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#36
    def match_path?(pattern, path); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#71
    def maybe_hidden_file?(path); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#8
    def relative_path(path, base_dir = T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/path_util.rb#25
    def smart_path(path); end
  end
end

module RuboCop::Platform
  class << self
    # source://rubocop/1.36.0/lib/rubocop/platform.rb#7
    def windows?; end
  end
end

# source://rubocop/1.36.0/lib/rubocop/ast_aliases.rb#6
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#14
  def initialize(url, base_dir); end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#19
  def file; end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#32
  def inherit_from_remote(file, path); end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#10
  def uri; end

  private

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#95
  def cache_name_from_uri; end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#78
  def cache_path; end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#82
  def cache_path_exists?; end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#86
  def cache_path_expired?; end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#101
  def cloned_url; end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#53
  def generate_request(uri); end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#62
  def handle_response(response, limit, &block); end

  # source://rubocop/1.36.0/lib/rubocop/remote_config.rb#40
  def request(uri = T.unsafe(nil), limit = T.unsafe(nil), &block); end
end

# source://rubocop/1.36.0/lib/rubocop/remote_config.rb#12
RuboCop::RemoteConfig::CACHE_LIFETIME = T.let(T.unsafe(nil), Integer)

class RuboCop::ResultCache
  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#88
  def initialize(file, team, options, config_store, cache_root = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#101
  def debug?; end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#109
  def load; end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#86
  def path; end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#114
  def save(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#105
  def valid?; end

  private

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#147
  def any_symlink?(path); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#233
  def context_checksum(team, options); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#190
  def digest(path); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#158
  def file_checksum(file, config_store); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#217
  def relevant_options_digest(options); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#175
  def rubocop_checksum; end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#201
  def rubocop_extra_features; end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#143
  def symlink_protection_triggered?(path); end

  # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#224
  def team_checksum(team); end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#82
    def allow_symlinks_in_cache_location?(config_store); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#76
    def cache_root(config_store); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#29
    def cleanup(config_store, verbose, cache_root = T.unsafe(nil)); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#171
    def inhibit_cleanup; end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#171
    def inhibit_cleanup=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#43
    def rubocop_required_features; end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#43
    def rubocop_required_features=(_arg0); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#171
    def source_checksum; end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#171
    def source_checksum=(_arg0); end

    private

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#66
    def remove_files(files, dirs, remove_count); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#53
    def remove_oldest_files(files, dirs, cache_root, verbose); end

    # source://rubocop/1.36.0/lib/rubocop/result_cache.rb#49
    def requires_file_removal?(file_count, config_store); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/result_cache.rb#17
RuboCop::ResultCache::DL_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://rubocop/1.36.0/lib/rubocop/result_cache.rb#13
RuboCop::ResultCache::NON_CHANGING = T.let(T.unsafe(nil), Array)

class RuboCop::Runner
  # source://rubocop/1.36.0/lib/rubocop/runner.rb#33
  def initialize(options, config_store); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#31
  def aborting=(_arg0); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#57
  def aborting?; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#30
  def errors; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#41
  def run(paths); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#30
  def warnings; end

  private

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#170
  def add_redundant_disables(file, offenses, source); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#144
  def cached_result(file, team); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#222
  def cached_run?; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#300
  def check_for_infinite_loop(processed_source, offenses_by_iteration); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#196
  def check_for_redundant_disables?(source); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#380
  def considered_failure?(offense); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#413
  def default_config(cop_name); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#244
  def do_inspection_loop(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#107
  def each_inspected_file(files); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#217
  def file_finished(file, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#148
  def file_offense_cache(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#136
  def file_offenses(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#212
  def file_started(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#360
  def filter_cop_classes(cop_classes, config); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#208
  def filtered_run?; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#78
  def find_target_files(paths); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#371
  def formatter_set; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#425
  def get_processed_source(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#314
  def inspect_file(processed_source, team = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#89
  def inspect_files(files); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#275
  def iterate_until_no_changes(source, offenses_by_iteration); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#122
  def list_files(paths); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#409
  def mark_as_safe_by_config?(config); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#417
  def minimum_severity_to_fail; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#321
  def mobilize_team(processed_source); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#326
  def mobilized_cop_classes(config); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#389
  def offenses_to_report(offenses); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#126
  def process_file(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#350
  def qualify_option_cop_names; end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#200
  def redundant_cop_disable_directive(file); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#234
  def save_in_cache(cache, offenses); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#443
  def standby_team(config); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#367
  def style_guide_cops_only?(config); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#401
  def supports_safe_autocorrect?(offense); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#185
  def team_for_redundant_disables(file, offenses, source); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#65
  def warm_cache(target_files); end
end

class RuboCop::Runner::InfiniteCorrectionLoop < ::StandardError
  # source://rubocop/1.36.0/lib/rubocop/runner.rb#14
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/runner.rb#12
  def offenses; end
end

# source://rubocop/1.36.0/lib/rubocop/runner.rb#28
RuboCop::Runner::MAX_ITERATIONS = T.let(T.unsafe(nil), Integer)

module RuboCop::Sorbet; end

# source://rubocop-sorbet//lib/rubocop/sorbet.rb#11
RuboCop::Sorbet::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-sorbet//lib/rubocop/sorbet.rb#10
RuboCop::Sorbet::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

class RuboCop::Sorbet::Error < ::StandardError; end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::Sorbet::Inject
  class << self
    # source://rubocop-sorbet//lib/rubocop/sorbet/inject.rb#10
    def defaults!; end
  end
end

# source://rubocop-sorbet//lib/rubocop/sorbet.rb#9
RuboCop::Sorbet::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# source://rubocop-sorbet//lib/rubocop/sorbet/version.rb#4
RuboCop::Sorbet::VERSION = T.let(T.unsafe(nil), String)

class RuboCop::StringInterpreter
  class << self
    # source://rubocop/1.36.0/lib/rubocop/string_interpreter.rb#24
    def interpret(string); end

    private

    # source://rubocop/1.36.0/lib/rubocop/string_interpreter.rb#51
    def interpret_hex(escape); end

    # source://rubocop/1.36.0/lib/rubocop/string_interpreter.rb#55
    def interpret_octal(escape); end

    # source://rubocop/1.36.0/lib/rubocop/string_interpreter.rb#33
    def interpret_string_escape(escape); end

    # source://rubocop/1.36.0/lib/rubocop/string_interpreter.rb#43
    def interpret_unicode(escape); end
  end
end

class RuboCop::TargetFinder
  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#10
  def initialize(config_store, options = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#145
  def all_cops_include; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#116
  def combined_exclude_glob_patterns(base_dir); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#172
  def configured_include?(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#19
  def debug?; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#23
  def fail_fast?; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#31
  def find(args, mode); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#83
  def find_files(base_dir, flags); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#15
  def force_exclusion?; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#176
  def included_file?(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#180
  def process_explicit_path(path, mode); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#149
  def ruby_executable?(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#123
  def ruby_extension?(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#127
  def ruby_extensions; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#168
  def ruby_file?(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#134
  def ruby_filename?(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#138
  def ruby_filenames; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#160
  def ruby_interpreters(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#164
  def stdin?; end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#108
  def symlink_excluded_or_infinite_loop?(base_dir, current_dir, exclude_pattern, flags); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#56
  def target_files_in_dir(base_dir = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#69
  def to_inspect?(file, hidden_files, base_dir_config); end

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#96
  def wanted_dir_patterns(base_dir, exclude_pattern, flags); end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_finder.rb#197
  def order; end
end

# source://rubocop/1.36.0/lib/rubocop/target_finder.rb#8
RuboCop::TargetFinder::HIDDEN_PATH_SUBSTRING = T.let(T.unsafe(nil), String)

class RuboCop::TargetRuby
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#248
  def initialize(config); end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#264
  def rubocop_version_with_support; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#252
  def source; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#260
  def supported?; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#256
  def version; end

  class << self
    # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#233
    def supported_versions; end
  end
end

class RuboCop::TargetRuby::BundlerLockFile < ::RuboCop::TargetRuby::Source
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#107
  def name; end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#140
  def bundler_lock_file_path; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#113
  def find_version; end
end

# source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#8
RuboCop::TargetRuby::DEFAULT_VERSION = T.let(T.unsafe(nil), Float)

class RuboCop::TargetRuby::Default < ::RuboCop::TargetRuby::Source
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#222
  def name; end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#228
  def find_version; end
end

class RuboCop::TargetRuby::GemspecFile < ::RuboCop::TargetRuby::Source
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#158
  def gem_requirement?(param0 = T.unsafe(nil)); end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#162
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#153
  def required_ruby_version(param0); end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#209
  def find_default_minimal_known_ruby(right_hand_side); end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#168
  def find_version; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#178
  def gemspec_filename; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#185
  def gemspec_filepath; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#205
  def version_from_array(array); end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#190
  def version_from_gemspec_file(file); end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#195
  def version_from_right_hand_side(right_hand_side); end
end

# source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#150
RuboCop::TargetRuby::GemspecFile::GEMSPEC_EXTENSION = T.let(T.unsafe(nil), String)

class RuboCop::TargetRuby::RuboCopConfig < ::RuboCop::TargetRuby::Source
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#39
  def name; end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#45
  def find_version; end
end

class RuboCop::TargetRuby::RubyVersionFile < ::RuboCop::TargetRuby::Source
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#56
  def name; end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#62
  def filename; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#70
  def find_version; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#66
  def pattern; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#77
  def version_file; end
end

# source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#53
RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_FILENAME = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#54
RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)

class RuboCop::TargetRuby::Source
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#26
  def initialize(config); end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#24
  def name; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#31
  def to_s; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#24
  def version; end
end

class RuboCop::TargetRuby::ToolVersionsFile < ::RuboCop::TargetRuby::RubyVersionFile
  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#89
  def name; end

  private

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#95
  def filename; end

  # source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#99
  def pattern; end
end

# source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#86
RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_FILENAME = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/target_ruby.rb#87
RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop/1.36.0/lib/rubocop/ast_aliases.rb#7
RuboCop::Token = RuboCop::AST::Token

module RuboCop::Util
  class << self
    # source://rubocop/1.36.0/lib/rubocop/util.rb#6
    def silence_warnings; end
  end
end

class RuboCop::ValidationError < ::RuboCop::Error; end

module RuboCop::Version
  class << self
    # source://rubocop/1.36.0/lib/rubocop/version.rb#89
    def document_version; end

    # source://rubocop/1.36.0/lib/rubocop/version.rb#39
    def extension_versions(env); end

    # source://rubocop/1.36.0/lib/rubocop/version.rb#73
    def feature_version(feature); end

    # source://rubocop/1.36.0/lib/rubocop/version.rb#17
    def version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
  end
end

# source://rubocop/1.36.0/lib/rubocop/version.rb#12
RuboCop::Version::CANONICAL_FEATURE_NAMES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/version.rb#14
RuboCop::Version::EXTENSION_PATH_NAMES = T.let(T.unsafe(nil), Hash)

# source://rubocop/1.36.0/lib/rubocop/version.rb#8
RuboCop::Version::MSG = T.let(T.unsafe(nil), String)

# source://rubocop/1.36.0/lib/rubocop/version.rb#6
RuboCop::Version::STRING = T.let(T.unsafe(nil), String)

class RuboCop::Warning < ::StandardError; end

module RuboCop::YAMLDuplicationChecker
  class << self
    # source://rubocop/1.36.0/lib/rubocop/yaml_duplication_checker.rb#7
    def check(yaml_string, filename, &on_duplicated); end

    private

    # source://rubocop/1.36.0/lib/rubocop/yaml_duplication_checker.rb#21
    def traverse(tree, &on_duplicated); end
  end
end
